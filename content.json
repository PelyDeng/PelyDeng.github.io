{"meta":{"title":"牧场小站","subtitle":"","description":"IT 小站， 记录美好码园生活","author":"Peilin Deng","url":"http://pdyun.cc","root":"/"},"pages":[{"title":"关于我","date":"2021-08-06T12:56:57.000Z","updated":"2021-08-07T08:23:50.870Z","comments":false,"path":"about/index.html","permalink":"http://pdyun.cc/about/index.html","excerpt":"","text":"正在播放《每天一遍，可莉完蛋》 ●━───────00:04 ⇆ ᐊ Ⅱ ᐅ ↻ 念两句诗 挑选中... jinrishici.load(function(result) { poem.innerHTML = result.data.content info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》' document.getElementById(\"poem\").value(poem); document.getElementById(\"info\").value(info); });"},{"title":"所有分类","date":"2021-08-06T12:55:40.000Z","updated":"2021-08-07T05:19:51.774Z","comments":false,"path":"categories/index.html","permalink":"http://pdyun.cc/categories/index.html","excerpt":"","text":""},{"title":"标签页","date":"2021-08-06T12:56:28.000Z","updated":"2021-08-07T05:20:48.804Z","comments":false,"path":"tags/index.html","permalink":"http://pdyun.cc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"外网访问家庭网络小记","slug":"外网访问家庭网络小记","date":"2021-08-13T16:16:00.000Z","updated":"2021-08-13T16:44:04.286Z","comments":true,"path":"2021/08/14/外网访问家庭网络小记/","link":"","permalink":"http://pdyun.cc/2021/08/14/%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E7%BD%91%E7%BB%9C%E5%B0%8F%E8%AE%B0/","excerpt":"记录一次家庭内网使用DDNS让外网访问, 同时动态更新域名123此篇文章献给&#x27;懒人&#x27;同学~ 相信很多同学在自己家里学习啥的搞些小网站小程序, 比如部署一些在线看视频丶个人网盘丶个人博客等的网站, 但是在公司时想访问记录或查询一些资料, 但是又因为访问不了家庭网络而烦躁... 在此分享能使用任意外网访问家庭内网, 同时动态更新域名的方法.当然在此之前我使用过花生壳、公云等一些软件, 他也可以让你从外网访问家庭内网, 但是别的不说, 他限速而且收费呀… 自己搭建可以全速使用家里的带宽步骤如下: 一. 外网访问","text":"记录一次家庭内网使用DDNS让外网访问, 同时动态更新域名123此篇文章献给&#x27;懒人&#x27;同学~ 相信很多同学在自己家里学习啥的搞些小网站小程序, 比如部署一些在线看视频丶个人网盘丶个人博客等的网站, 但是在公司时想访问记录或查询一些资料, 但是又因为访问不了家庭网络而烦躁... 在此分享能使用任意外网访问家庭内网, 同时动态更新域名的方法.当然在此之前我使用过花生壳、公云等一些软件, 他也可以让你从外网访问家庭内网, 但是别的不说, 他限速而且收费呀… 自己搭建可以全速使用家里的带宽步骤如下: 一. 外网访问 1. 申请公网IP 想访问家庭网络必定需要找家里开网络的运营商, 让他们给开公网IP, 我家里使用的是电信宽带, 电话直接打 10000 号人工服务让他们帮忙开通, 理由嘛很简单( 找个借口说家里安装监控就给你开了 ) , 电信现在默认都是给的私网IP. 2. 光猫改为桥接模式 申请完公网IP先别急着挂, 还需要让他们把宽带网络改成桥接模式, 后面我们路由器使用拨号上网 3. 查询宽带账号和密码 由于路由器现在是使用拨号上网, 所以还需要找他运营商拿到宽带的账户和密码, 这些都是必要条件 4. 设备网线连接 我们使用网线连接 光猫的网口 和 路由器WAN口, 主机的网线则联通路由器的LAN口, ( WAN口是连接外部网络, LAN口是连接内部网络, 家里的电脑网线都可以用LAN接口连接, 并且此时我们电脑是没有网络的 ) 12graph LR光猫网口 --&gt; 路由器WAN口 12graph LR路由器LAN口 --&gt; 电脑网口 5. 设置路由器 此时已经具备的条件:公网ip, 宽带改为桥接模式, 宽带账号和密码, 设备网线正确连接 开始设置路由器: 我的路由器设备使用的小米路由器, 暂以小米路由器为例, 路由器网关是 192.168.31.1 , 自己的路由器网关自己搜一下, 然后输入路由器用户名密码 上网设置如图, 上网方式选择PPPOE手动拨号, 然后输入宽带的账号和密码即可 拨号成功应该就可以上网了~~~ 6. 检查IP地址 百度查询自己本机的IP是否与路由器拨号成功获得的IP地址相同.++如果不同, 那一般都是私网ip 没有申请公网ip的.++ 7. 路由转发 一般路由器都拥有路由转发功能, 可以自己配置转发规则. 端口转发: 映射端口, 访问外网 ip:端口, 会直接映射到内网的ip:端口如: **访问外网地址 22.135.173.55:8848, 会被转发到内网 192.168.31.26:8000 ** 8. 测试 我本地电脑随便开启一个服务部署成功, 内网ip:port 192.168.31.26:8401 接着使用外网ip访问, 注意自己映射的端口哦访问成功~~ 二. 设置动态更新域名12由于电信给的公网IP是动态IP, 每次关闭重启光猫都会更换公网IP地址, 所以这也是个很头疼的事情... 个人方案解决了该情况 1. 准备域名 ( 本方案只支持腾讯云域名, 对接腾讯云API ) 我使用的方法, 使用Python写了一个脚本, 动态去更新域名, 需要准备一个腾讯云的域名。提供购买链接 https://buy.cloud.tencent.com/domain?from=console 2. 开通腾讯云 API 密钥 API 密钥代表你的账号身份和所拥有的权限，使用腾讯云 API 可以操作您名下的所有腾讯云资源。给上链接 https://console.cloud.tencent.com/cam/capi 开通完后新建密钥( 单机即可, 自动创建 ): 3. 安装Python3 由于使用的 Python 写的脚本, 需要环境拥有Python, 版本 3 及以上.安装方法参考 https://www.cnblogs.com/weven/p/7252917.html安装完成后查看Python版本: 4. 献上脚本 复制以下代码 保存为 xxx.py 格式就行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197VERSION = 1from hashlib import sha1import jsonimport timeimport base64import hmacclass DDnsHelper(): def __init__(self, mid=0, params=&#123;&#125;): pass def excute(self): import requests SecretId = &#x27;*需要填写*&#x27; SecretKey = &#x27;*需要填写*&#x27; runningPause = 20 domainName = &#x27;pelyhome.cc&#x27; # *需要填写你自己的域名* ddnsDomains = [ &#123; # *需要填写你自己的域名* &#x27;name&#x27;: &#x27;@.pelyhome.cc&#x27;, &#x27;value&#x27;: &#x27;&#x27;, # &#x27;always&#x27;: False, # DNS生存时间 &#x27;ttl&#x27;: 600, # 主机记录, 即域名前缀 &#x27;subDomain&#x27;: &#x27;@&#x27;, &#x27;recordId&#x27;: &#x27;&#x27;, # 记录类型 &#x27;recordType&#x27;: &#x27;A&#x27;, # 线路类型, 指定细分解析线路 &#x27;recordLine&#x27;: &#x27;默认&#x27;, &#x27;description&#x27;: &#x27;本地提供api服务的地址&#x27;, # 查看本地域名的接口, 这是自己写的接口, 仅仅返回一个纯粹的本地外网IP地址 &#x27;localDomain&#x27;: &#x27;https://www.hosix.cn/ip&#x27;, &#x27;localValue&#x27;: &#x27;&#x27; &#125; ] class tenXunDDNS_Helper(): def __init__(self): self.running = True self.action = &quot;&quot; self.secretId = SecretId self.nonce = 38651 self.region = &#x27;ap-guangzhou&#x27; self.secretKey = SecretKey self.version = &#x27;2017-03-12&#x27; self.domain = domainName self.url = &#x27;cns.api.qcloud.com/v2/index.php&#x27; self.httpType = &#x27;https://&#x27; self.endpoint = self.httpType + self.url self.ddnsDomain = ddnsDomains self.runningPause = runningPause self.remoteRecords = [] def getServerIp(self): timeStamp = int(time.time()) params = &#123;&#125; params[&#x27;Action&#x27;] = &#x27;RecordList&#x27; params[&#x27;domain&#x27;] = self.domain params[&#x27;Nonce&#x27;] = self.nonce params[&#x27;SecretId&#x27;] = self.secretId params[&#x27;Timestamp&#x27;] = timeStamp s = self.get_string_to_sign(&quot;GET&quot;, self.url, params) Signature = self.sign_str(self.secretKey, s, sha1) params[&#x27;Signature&#x27;] = Signature response = requests.get(self.endpoint, params=params) result = json.loads(response.text) if int(result[&#x27;code&#x27;]) != 0: raise Exception(&#x27;获取域名失败&#x27; + &#x27;:&#x27; + str(result[&#x27;code&#x27;]) + &#x27;:&#x27; + result[&#x27;message&#x27;]) data = result[&#x27;data&#x27;] self.remoteRecords = data[&#x27;records&#x27;] # print(self.remoteRecords) def postServerIp(self, domain): timeStamp = int(time.time()) params = &#123;&#125; params[&#x27;Action&#x27;] = &#x27;RecordCreate&#x27; params[&#x27;domain&#x27;] = self.domain params[&#x27;Nonce&#x27;] = self.nonce params[&#x27;SecretId&#x27;] = self.secretId params[&#x27;Timestamp&#x27;] = timeStamp params[&#x27;subDomain&#x27;] = domain[&#x27;subDomain&#x27;] params[&#x27;recordType&#x27;] = domain[&#x27;recordType&#x27;] params[&#x27;recordLine&#x27;] = domain[&#x27;recordLine&#x27;] params[&#x27;value&#x27;] = domain[&#x27;value&#x27;] params[&#x27;ttl&#x27;] = domain[&#x27;ttl&#x27;] s = self.get_string_to_sign(&quot;GET&quot;, self.url, params) Signature = self.sign_str(self.secretKey, s, sha1) params[&#x27;Signature&#x27;] = Signature response = requests.get(self.endpoint, params=params) result = json.loads(response.text) if int(result[&#x27;code&#x27;]) != 0: raise Exception(&#x27;添加域名失败&#x27; + &#x27;:&#x27; + str(result[&#x27;code&#x27;]) + &#x27;:&#x27; + result[&#x27;message&#x27;]) data = result[&#x27;data&#x27;] print(&#x27;添加域名成功ip:%s,本地ip:%s,域名:%s&#x27; % (domain[&#x27;value&#x27;], domain[&#x27;localValue&#x27;], domain[&#x27;name&#x27;])) def updateServerIp(self, domain): timeStamp = int(time.time()) params = &#123;&#125; params[&#x27;Action&#x27;] = &#x27;RecordModify&#x27; params[&#x27;domain&#x27;] = self.domain params[&#x27;Nonce&#x27;] = self.nonce params[&#x27;SecretId&#x27;] = self.secretId params[&#x27;Timestamp&#x27;] = timeStamp params[&#x27;subDomain&#x27;] = domain[&#x27;subDomain&#x27;] params[&#x27;recordId&#x27;] = domain[&#x27;recordId&#x27;] params[&#x27;recordType&#x27;] = domain[&#x27;recordType&#x27;] params[&#x27;recordLine&#x27;] = domain[&#x27;recordLine&#x27;] params[&#x27;value&#x27;] = domain[&#x27;localValue&#x27;] params[&#x27;ttl&#x27;] = domain[&#x27;ttl&#x27;] s = self.get_string_to_sign(&quot;GET&quot;, self.url, params) Signature = self.sign_str(self.secretKey, s, sha1) params[&#x27;Signature&#x27;] = Signature response = requests.get(self.endpoint, params=params) result = json.loads(response.text) if int(result[&#x27;code&#x27;]) != 0: raise Exception(&#x27;更新域名失败&#x27; + &#x27;:&#x27; + str(result[&#x27;code&#x27;]) + &#x27;:&#x27; + result[&#x27;message&#x27;]) data = result[&#x27;data&#x27;] print(&#x27;更新域名成功源ip:%s,本地ip:%s,域名:%s&#x27; % (domain[&#x27;value&#x27;], domain[&#x27;localValue&#x27;], domain[&#x27;name&#x27;])) def deleteServerIp(self): pass def getLocalDomain(self, domain): res = requests.get(domain[&#x27;localDomain&#x27;]) ip = res.content.decode(&quot;utf-8&quot;).strip() return ip def clearDnsRecord(self): for domain in self.ddnsDomain: if not domain[&#x27;always&#x27;]: domain[&#x27;value&#x27;] = &#x27;&#x27; domain[&#x27;localValue&#x27;] = &#x27;&#x27; def run(self): self.getServerIp() for domain in self.ddnsDomain: if (not domain[&#x27;always&#x27;]): # 获取本地ip try: domain[&#x27;localValue&#x27;] = self.getLocalDomain(domain) except Exception as e: print(&quot;获取本地ip失败 不更新:%s,本地ip:%s,域名:%s&quot; % ( domain[&#x27;value&#x27;], domain[&#x27;localValue&#x27;], domain[&#x27;name&#x27;])) else: continue flag = False for remoteDomain in self.remoteRecords: if (domain[&#x27;subDomain&#x27;] == remoteDomain[&#x27;name&#x27;]): domain[&#x27;recordId&#x27;] = remoteDomain[&#x27;id&#x27;] domain[&#x27;value&#x27;] = remoteDomain[&#x27;value&#x27;] flag = True break if flag: if (domain[&#x27;value&#x27;] == domain[&#x27;localValue&#x27;]): pass # print(&quot;无需更新ip:%s,本地ip:%s,域名:%s&quot; % (domain[&#x27;value&#x27;],domain[&#x27;localValue&#x27;],domain[&#x27;name&#x27;])) else: self.updateServerIp(domain) continue else: domain[&#x27;value&#x27;] = domain[&#x27;localValue&#x27;] self.postServerIp(domain) self.clearDnsRecord() def start(self): start_time = int(time.time()) while self.running: next_time = int(time.time()) + self.runningPause if (next_time - start_time) &gt; self.runningPause: try: self.run() except Exception as e: print(e.__str__()) start_time = start_time + self.runningPause else: time.sleep(self.runningPause / 10) def get_string_to_sign(self, method, endpoint, params): s = method + endpoint + &quot;?&quot; query_str = &quot;&amp;&quot;.join(&quot;%s=%s&quot; % (k, params[k]) for k in sorted(params)) # print(s + query_str) return s + query_str def sign_str(self, key, s, method): hmac_str = hmac.new(key.encode(&quot;utf8&quot;), s.encode(&quot;utf8&quot;), method).digest() return base64.b64encode(hmac_str) t1 = tenXunDDNS_Helper() t1.start()d = DDnsHelper()d.excute() 最后双击运行~ OK 5. 运行原理和注意事项 原理:该脚本是通过查询公网IP接口:https://www.hosix.cn/ip 来判断公网ip是否发生了改变, 如果发生了改变, 就会调用腾讯云API去动态更新域名. 非常简单….. 注意事项: 1.该脚本需要持续运行, 如果是Linux系统, 直接挂后台运行即可, 该脚本资源消耗不高2.如果提示没requests 运行下, 打开cmd窗口输入: pip install requests3.如运行闪退, 请检查域名等是否正确填写 如有问题请评论或留言: &#x35;&#52;&#52;&#x30;&#x31;&#48;&#49;&#x36;&#x35;&#x40;&#x71;&#113;&#46;&#99;&#111;&#x6d;","categories":[{"name":"摘抄笔记","slug":"摘抄笔记","permalink":"http://pdyun.cc/categories/%E6%91%98%E6%8A%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"访问家庭内网","slug":"访问家庭内网","permalink":"http://pdyun.cc/tags/%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E5%86%85%E7%BD%91/"},{"name":"动态DDNS","slug":"动态DDNS","permalink":"http://pdyun.cc/tags/%E5%8A%A8%E6%80%81DDNS/"}],"author":"Peilin Deng"},{"title":"MyBatis 运行时序图","slug":"MyBatis-运行时序图","date":"2021-08-10T11:22:00.000Z","updated":"2021-08-10T12:13:29.943Z","comments":true,"path":"2021/08/10/MyBatis-运行时序图/","link":"","permalink":"http://pdyun.cc/2021/08/10/MyBatis-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%8F%E5%9B%BE/","excerpt":"架构分层","text":"架构分层 1. 创建会话工厂类 2. 创建会话 3. 获取代理对象 4. 调用代理对象方法, 执行SQL","categories":[{"name":"摘抄笔记","slug":"摘抄笔记","permalink":"http://pdyun.cc/categories/%E6%91%98%E6%8A%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://pdyun.cc/tags/MyBatis/"}],"author":"Peilin Deng"},{"title":"MyBatis 整合到 Spring 原理","slug":"A","date":"2021-08-07T07:41:00.000Z","updated":"2021-08-10T12:10:57.727Z","comments":true,"path":"2021/08/07/A/","link":"","permalink":"http://pdyun.cc/2021/08/07/A/","excerpt":"1. xml 配置 通过在Spring的 applicationContext.xml文件中做以下配置, 指定MyBatis 的mapper.xml 文件扫描路径, MapperScannerConfigurer 是 Mybatis 用于整合 Spring 的核心对象.","text":"1. xml 配置 通过在Spring的 applicationContext.xml文件中做以下配置, 指定MyBatis 的mapper.xml 文件扫描路径, MapperScannerConfigurer 是 Mybatis 用于整合 Spring 的核心对象. 1234567&lt;!--配置扫描器，将mybatis的接口实现加入到 IOC容器中 --&gt;&lt;!-- &lt;mybatis-spring:scan #base-package=&quot;com.dpl.crud.dao&quot;/&gt;--&gt; &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.gupaoedu.crud.dao&quot;/&gt; &lt;/bean&gt; 2. MapperScannerConfigurer 对象12345public class MapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware &#123; ...... ......&#125; 该对象实现了几个接口: BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware 1). BeanDefinitionRegistryPostProcessor: 如下, 重写了 ++postProcessBeanDefinitionRegistry++(…) 方法, 在该方法中进行扫描对应的 Mapper 文件 12345678910111213141516171819202122232425@Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123; if (this.processPropertyPlaceHolders) &#123; processPropertyPlaceHolders(); &#125; ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); scanner.setAddToConfig(this.addToConfig); scanner.setAnnotationClass(this.annotationClass); scanner.setMarkerInterface(this.markerInterface); scanner.setSqlSessionFactory(this.sqlSessionFactory); scanner.setSqlSessionTemplate(this.sqlSessionTemplate); scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName); scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName); scanner.setResourceLoader(this.applicationContext); scanner.setBeanNameGenerator(this.nameGenerator); scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass); if (StringUtils.hasText(lazyInitialization)) &#123; scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization)); &#125; scanner.registerFilters(); // *重点在这里 scanner.scan( StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS)); &#125; 重点在 scanner.scan(…)方法 123456789101112public int scan(String... basePackages) &#123; int beanCountAtScanStart = this.registry.getBeanDefinitionCount(); // 继续进入该方法 this.doScan(basePackages); if (this.includeAnnotationConfig) &#123; AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); &#125; return this.registry.getBeanDefinitionCount() - beanCountAtScanStart; &#125; 该方法有两个实现, 首先进入 ClassPathMapperScanner 实现 12345678910111213@Override public Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; // *这里调了父类 ClassPathBeanDefinitionScanner 的doScan 方法, 进入该方法实现 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages); if (beanDefinitions.isEmpty()) &#123; LOGGER.warn(() -&gt; &quot;No MyBatis mapper was found in &#x27;&quot; + Arrays.toString(basePackages) + &quot;&#x27; package. Please check your configuration.&quot;); &#125; else &#123; processBeanDefinitions(beanDefinitions); &#125; return beanDefinitions; &#125; 这里调了父类 ClassPathBeanDefinitionScanner 的 doScan() 方法, 进入该方法实现 123456789101112131415161718192021222324252627282930313233343536373839404142protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;); // *创建 BeanDefinitionHolder 集合, 里面封装的是 BeanDefinition 和 beanName Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet(); String[] var3 = basePackages; int var4 = basePackages.length; for(int var5 = 0; var5 &lt; var4; ++var5) &#123; String basePackage = var3[var5]; Set&lt;BeanDefinition&gt; candidates = this.findCandidateComponents(basePackage); Iterator var8 = candidates.iterator(); while(var8.hasNext()) &#123; BeanDefinition candidate = (BeanDefinition)var8.next(); ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) &#123; this.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName); &#125; if (candidate instanceof AnnotatedBeanDefinition) &#123; AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate); &#125; // 检查每个 BeanDefinition 是否在容器中存在, 不存在则返回true if (this.checkCandidate(beanName, candidate)) &#123; // 创建 BeanDefinitionHolder 对象封装 BeanDefinition BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); // *将创建好的对象注册到 BeanDefinitionRegistry 容器中交由Spring管理 this.registerBeanDefinition(definitionHolder, this.registry); &#125; &#125; &#125; return beanDefinitions; &#125; 上面将mapper对象封装好了注册到 BeanDefinitionRegistry 容器中交由Spring管理, 接着返回 BeanDefinitionHolder 集合继续处理 123456789101112131415@Override public Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages); if (beanDefinitions.isEmpty()) &#123; LOGGER.warn(() -&gt; &quot;No MyBatis mapper was found in &#x27;&quot; + Arrays.toString(basePackages) + &quot;&#x27; package. Please check your configuration.&quot;); &#125; else &#123; // *接下来处理BeanDefinition processBeanDefinitions(beanDefinitions); &#125; return beanDefinitions; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123; GenericBeanDefinition definition; for (BeanDefinitionHolder holder : beanDefinitions) &#123; definition = (GenericBeanDefinition) holder.getBeanDefinition(); String beanClassName = definition.getBeanClassName(); LOGGER.debug(() -&gt; &quot;Creating MapperFactoryBean with name &#x27;&quot; + holder.getBeanName() + &quot;&#x27; and &#x27;&quot; + beanClassName + &quot;&#x27; mapperInterface&quot;); definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); // issue #59 // mapper接口是Bean的原始类，但是Bean的实际类被替换成了 MapperFactoryBean // 这里的 this.mapperFactoryBeanClass 是 MapperFactoryBean.class 对象 // private Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = MapperFactoryBean.class; definition.setBeanClass(this.mapperFactoryBeanClass); definition.getPropertyValues().add(&quot;addToConfig&quot;, this.addToConfig); boolean explicitFactoryUsed = false; if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) &#123; definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, new RuntimeBeanReference(this.sqlSessionFactoryBeanName)); explicitFactoryUsed = true; &#125; else if (this.sqlSessionFactory != null) &#123; definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, this.sqlSessionFactory); explicitFactoryUsed = true; &#125; if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) &#123; if (explicitFactoryUsed) &#123; LOGGER.warn( () -&gt; &quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;); &#125; definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, new RuntimeBeanReference(this.sqlSessionTemplateBeanName)); explicitFactoryUsed = true; &#125; else if (this.sqlSessionTemplate != null) &#123; if (explicitFactoryUsed) &#123; LOGGER.warn( () -&gt; &quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;); &#125; definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, this.sqlSessionTemplate); explicitFactoryUsed = true; &#125; if (!explicitFactoryUsed) &#123; LOGGER.debug(() -&gt; &quot;Enabling autowire by type for MapperFactoryBean with name &#x27;&quot; + holder.getBeanName() + &quot;&#x27;.&quot;); definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE); &#125; definition.setLazyInit(lazyInitialization); &#125; &#125; 这里 mapper接口是Bean的原始类，但是Bean的实际类被替换成了 MapperFactoryBean, MapperFactoryBean 对象又是什么东西? 3. MapperFactoryBean 对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// *要点一: 该类继承了 SqlSessionDaoSupport, SqlSessionDaoSupport 对象里面可以获取 SqlSessionTemplate 对象// SqlSessionTemplate 对象是 DefaultSqlSession 的替代品, 实现同一事务的情况下保证线程安全的, 每次请求的时候都会创建一个新的 SqlSessionpublic class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; &#123; private Class&lt;T&gt; mapperInterface; private boolean addToConfig = true; public MapperFactoryBean() &#123; // intentionally empty &#125; public MapperFactoryBean(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; @Override protected void checkDaoConfig() &#123; super.checkDaoConfig(); notNull(this.mapperInterface, &quot;Property &#x27;mapperInterface&#x27; is required&quot;); Configuration configuration = getSqlSession().getConfiguration(); if (this.addToConfig &amp;&amp; !configuration.hasMapper(this.mapperInterface)) &#123; try &#123; configuration.addMapper(this.mapperInterface); &#125; catch (Exception e) &#123; logger.error(&quot;Error while adding the mapper &#x27;&quot; + this.mapperInterface + &quot;&#x27; to configuration.&quot;, e); throw new IllegalArgumentException(e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; &#125; // *要点二: 该类实现了 FactoryBean&lt;T&gt; 接口, 重写 getObject() 方法, // 从 SqlSessionTemplate 对象中获取 Mapper 接口的代理对象 // 后面的逻辑与之前未整合 Spring 的逻辑一致了..... @Override public T getObject() throws Exception &#123; return getSqlSession().getMapper(this.mapperInterface); &#125; @Override public Class&lt;T&gt; getObjectType() &#123; return this.mapperInterface; &#125; @Override public boolean isSingleton() &#123; return true; &#125; public void setMapperInterface(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; public Class&lt;T&gt; getMapperInterface() &#123; return mapperInterface; &#125; public void setAddToConfig(boolean addToConfig) &#123; this.addToConfig = addToConfig; &#125; public boolean isAddToConfig() &#123; return addToConfig; &#125;&#125; 允许注入MyBatis映射器接口的BeanFactory。 可以使用SqlSessionFactory或预配置的SqlSessionTemplate进行设置。*要点一: 该类继承了 SqlSessionDaoSupport, SqlSessionDaoSupport 对象里面可以获取 SqlSessionTemplate 对象 SqlSessionTemplate 对象是 DefaultSqlSession 的替代品, 实现同一事务的情况下还保证线程安全的, 每次请求的时候都会创建一个新的 DefualtSqlSession *要点二: 该类实现了 FactoryBean 接口, 重写 getObject() 方法, 从 SqlSessionTemplate 对象中获取 Mapper 接口的代理对象 后面的逻辑与之前未整合 Spring 的逻辑一致了….. 4. SqlSessionTemplate 对象为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的?12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class SqlSessionTemplate implements SqlSession, DisposableBean &#123; private final SqlSessionFactory sqlSessionFactory; private final ExecutorType executorType; private final SqlSession sqlSessionProxy; private final PersistenceExceptionTranslator exceptionTranslator; ...... public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) &#123; notNull(sqlSessionFactory, &quot;Property &#x27;sqlSessionFactory&#x27; is required&quot;); notNull(executorType, &quot;Property &#x27;executorType&#x27; is required&quot;); this.sqlSessionFactory = sqlSessionFactory; this.executorType = executorType; this.exceptionTranslator = exceptionTranslator; // 1. 在初始化的时候通过这里创建 SqlSessionFactory 代理类, // 该代理类实现SqlSession接口，定义了方法拦截器，如果调用代理类实例中实现SqlSession接口定义的方法， // 该调用则被导向 SqlSessionInterceptor 的invoke方法 this.sqlSessionProxy = (SqlSession) newProxyInstance( SqlSessionFactory.class.getClassLoader(), new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor() ); &#125; ...... private class SqlSessionInterceptor implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 2. 为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的? // 此处则是关键, 进入该方法 getSqlSession(...) SqlSession sqlSession = getSqlSession(SqlSessionTemplate.this.sqlSessionFactory, SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator); try &#123; // 调用从Spring的事物上下文获取事物范围内的sqlSession对象 Object result = method.invoke(sqlSession, args); //然后判断一下当前的sqlSession是否被Spring托管 如果未被Spring托管则自动commit if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) &#123; // force commit even on non-dirty sessions because some databases require // a commit/rollback before calling close() sqlSession.commit(true); &#125; return result; &#125; catch (Throwable t) &#123; Throwable unwrapped = unwrapThrowable(t); if (SqlSessionTemplate.this.exceptionTranslator != null &amp;&amp; unwrapped instanceof PersistenceException) &#123; // release the connection to avoid a deadlock if the translator is no loaded. See issue #22 closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); sqlSession = null; Throwable translated = SqlSessionTemplate.this.exceptionTranslator .translateExceptionIfPossible((PersistenceException) unwrapped); if (translated != null) &#123; unwrapped = translated; &#125; &#125; throw unwrapped; &#125; finally &#123; if (sqlSession != null) &#123; closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); &#125; &#125; &#125; &#125;&#125; 在初始化的时候在构造方法中创建 SqlSessionFactory 代理类, 该代理类实现SqlSession接口，定义了方法拦截器，如果调用代理类实例中实现SqlSession接口定义的方法，该调用则被导向 SqlSessionInterceptor 的invoke方法 (代理对象的 InvocationHandler 就是 SqlSessionInterceptor，如果把它命名为SqlSessionInvocationHandler则更好理解！） 为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的? 此处则是关键, 进入该方法 SqlSession sqlSession = getSqlSession(SqlSessionTemplate.this.sqlSessionFactory, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator); 123456789101112131415161718192021222324252627public static SqlSession getSqlSession(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) &#123; notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED); notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED); // 进入 TransactionSynchronizationManager.getResource(...) 方法 // 根据sqlSessionFactory从当前线程对应的资源map中获取SqlSessionHolder， // 当sqlSessionFactory创建了sqlSession， // 就会在事务管理器中添加一对映射：key为sqlSessionFactory，value为SqlSessionHolder，该类保存sqlSession及执行方式 SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory); //从SqlSessionHolder中提取SqlSession对象 SqlSession session = sessionHolder(executorType, holder); if (session != null) &#123; return session; &#125; LOGGER.debug(() -&gt; &quot;Creating a new SqlSession&quot;); // 如果当前事物管理器中获取不到SqlSessionHolder对象就重新创建一个 session = sessionFactory.openSession(executorType); registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session); return session; &#125; 进入 TransactionSynchronizationManager.getResource(…) 方法 SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory); 123456789101112@Nullable public static Object getResource(Object key) &#123; Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key); // 这里 value 为返回结果, 可以进去看这个 value 是什么对象, 进入 doGetResource() 方法 Object value = doGetResource(actualKey); if (value != null &amp;&amp; logger.isTraceEnabled()) &#123; logger.trace(&quot;Retrieved value [&quot; + value + &quot;] for key [&quot; + actualKey + &quot;] bound to thread [&quot; + Thread.currentThread().getName() + &quot;]&quot;); &#125; return value; &#125; 这里 value 为返回结果, 可以进去看这个 value 是什么对象, 进入 doGetResource() 方法 Object value = doGetResource(actualKey); 1234567891011121314151617181920@Nullable private static Object doGetResource(Object actualKey) &#123; // 最后从 resources 这个集合中获取的对象, 然而这个 resources 就是一个 ThreadLocal 对象, 保证了线程安全 Map&lt;Object, Object&gt; map = (Map)resources.get(); if (map == null) &#123; return null; &#125; else &#123; Object value = map.get(actualKey); if (value instanceof ResourceHolder &amp;&amp; ((ResourceHolder)value).isVoid()) &#123; map.remove(actualKey); if (map.isEmpty()) &#123; resources.remove(); &#125; value = null; &#125; return value; &#125; &#125; 最后从 resources 这个集合中获取的对象, 然而这个 resources 就是一个 ThreadLocal 对象, 保证了线程安全 Map&lt;Object, Object&gt; map = (Map)resources.get(); 1234567public abstract class TransactionSynchronizationManager &#123; ...... private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = new NamedThreadLocal(&quot;Transactional resources&quot;); ......&#125; 5. Mybatis 不是有 SqlSessionManager 了吗？为什么又提供了 SqlSessionTemplate？ SqlSessionManager: SqlSessionManager 是由开发者自身决定如何使用 SqlSession 的, 是适合在不整合 Spring 框架的时候使用。 SqlSessionTemplate: SqlSessionTemplate 是 MyBatis 专门为 Spring 提供的，支持 Spring 框架的一个 SqlSession 获取接口。主要是为了继承 Spring，并同时将是否共用 SqlSession 的权限交给 Spring 去管理。","categories":[{"name":"摘抄笔记","slug":"摘抄笔记","permalink":"http://pdyun.cc/categories/%E6%91%98%E6%8A%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://pdyun.cc/tags/MyBatis/"}],"author":"Peilin Deng"},{"title":"Hello World","slug":"newpapername","date":"2021-08-06T05:06:24.000Z","updated":"2021-08-10T11:21:31.361Z","comments":true,"path":"2021/08/06/newpapername/","link":"","permalink":"http://pdyun.cc/2021/08/06/newpapername/","excerpt":"","text":"念两句诗 挑选中... jinrishici.load(function(result) { poem.innerHTML = result.data.content info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》' document.getElementById(\"poem\").value(poem); document.getElementById(\"info\").value(info); });","categories":[],"tags":[]}],"categories":[{"name":"摘抄笔记","slug":"摘抄笔记","permalink":"http://pdyun.cc/categories/%E6%91%98%E6%8A%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"访问家庭内网","slug":"访问家庭内网","permalink":"http://pdyun.cc/tags/%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E5%86%85%E7%BD%91/"},{"name":"动态DDNS","slug":"动态DDNS","permalink":"http://pdyun.cc/tags/%E5%8A%A8%E6%80%81DDNS/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://pdyun.cc/tags/MyBatis/"}]}