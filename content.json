{"meta":{"title":"牧场小站","subtitle":"","description":"IT 小站， 记录美好码园生活","author":"Peilin Deng","url":"http://pdyun.cc","root":"/"},"pages":[{"title":"所有分类","date":"2021-08-06T12:55:40.000Z","updated":"2021-08-07T05:19:51.774Z","comments":false,"path":"categories/index.html","permalink":"http://pdyun.cc/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2021-08-06T12:56:57.000Z","updated":"2021-08-07T08:23:50.870Z","comments":false,"path":"about/index.html","permalink":"http://pdyun.cc/about/index.html","excerpt":"","text":"正在播放《每天一遍，可莉完蛋》 ●━───────00:04 ⇆ ᐊ Ⅱ ᐅ ↻ 念两句诗 挑选中... jinrishici.load(function(result) { poem.innerHTML = result.data.content info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》' document.getElementById(\"poem\").value(poem); document.getElementById(\"info\").value(info); });"},{"title":"标签页","date":"2021-08-06T12:56:28.000Z","updated":"2021-08-07T05:20:48.804Z","comments":false,"path":"tags/index.html","permalink":"http://pdyun.cc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-08-07T08:24:38.000Z","updated":"2021-08-07T08:24:44.500Z","comments":true,"path":"2021/08/07/hello-world/","link":"","permalink":"http://pdyun.cc/2021/08/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server1e hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hello","slug":"hello","permalink":"http://pdyun.cc/tags/hello/"},{"name":"hexo","slug":"hexo","permalink":"http://pdyun.cc/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"http://pdyun.cc/tags/markdown/"}]},{"title":"MyBatis 整合到 Spring 原理","slug":"A","date":"2021-08-07T07:41:00.000Z","updated":"2021-08-07T08:20:18.081Z","comments":true,"path":"2021/08/07/A/","link":"","permalink":"http://pdyun.cc/2021/08/07/A/","excerpt":"1. xml 配置 通过在Spring的 applicationContext.xml文件中做以下配置, 指定MyBatis 的mapper.xml 文件扫描路径, MapperScannerConfigurer 是 Mybatis 用于整合 Spring 的核心对象.","text":"1. xml 配置 通过在Spring的 applicationContext.xml文件中做以下配置, 指定MyBatis 的mapper.xml 文件扫描路径, MapperScannerConfigurer 是 Mybatis 用于整合 Spring 的核心对象. 1234567&lt;!--配置扫描器，将mybatis的接口实现加入到 IOC容器中 --&gt;&lt;!-- &lt;mybatis-spring:scan #base-package=&quot;com.dpl.crud.dao&quot;/&gt;--&gt; &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.gupaoedu.crud.dao&quot;/&gt; &lt;/bean&gt; 2. MapperScannerConfigurer 对象12345public class MapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware &#123; ...... ......&#125; 该对象实现了几个接口: BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware 1). BeanDefinitionRegistryPostProcessor: 如下, 重写了 ++postProcessBeanDefinitionRegistry++(…) 方法, 在该方法中进行扫描对应的 Mapper 文件 12345678910111213141516171819202122232425@Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123; if (this.processPropertyPlaceHolders) &#123; processPropertyPlaceHolders(); &#125; ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); scanner.setAddToConfig(this.addToConfig); scanner.setAnnotationClass(this.annotationClass); scanner.setMarkerInterface(this.markerInterface); scanner.setSqlSessionFactory(this.sqlSessionFactory); scanner.setSqlSessionTemplate(this.sqlSessionTemplate); scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName); scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName); scanner.setResourceLoader(this.applicationContext); scanner.setBeanNameGenerator(this.nameGenerator); scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass); if (StringUtils.hasText(lazyInitialization)) &#123; scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization)); &#125; scanner.registerFilters(); // *重点在这里 scanner.scan( StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS)); &#125; 重点在 scanner.scan(…)方法 123456789101112public int scan(String... basePackages) &#123; int beanCountAtScanStart = this.registry.getBeanDefinitionCount(); // 继续进入该方法 this.doScan(basePackages); if (this.includeAnnotationConfig) &#123; AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); &#125; return this.registry.getBeanDefinitionCount() - beanCountAtScanStart; &#125; 该方法有两个实现, 首先进入 ClassPathMapperScanner 实现 12345678910111213@Override public Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; // *这里调了父类 ClassPathBeanDefinitionScanner 的doScan 方法, 进入该方法实现 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages); if (beanDefinitions.isEmpty()) &#123; LOGGER.warn(() -&gt; &quot;No MyBatis mapper was found in &#x27;&quot; + Arrays.toString(basePackages) + &quot;&#x27; package. Please check your configuration.&quot;); &#125; else &#123; processBeanDefinitions(beanDefinitions); &#125; return beanDefinitions; &#125; 这里调了父类 ClassPathBeanDefinitionScanner 的 doScan() 方法, 进入该方法实现 123456789101112131415161718192021222324252627282930313233343536373839404142protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;); // *创建 BeanDefinitionHolder 集合, 里面封装的是 BeanDefinition 和 beanName Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet(); String[] var3 = basePackages; int var4 = basePackages.length; for(int var5 = 0; var5 &lt; var4; ++var5) &#123; String basePackage = var3[var5]; Set&lt;BeanDefinition&gt; candidates = this.findCandidateComponents(basePackage); Iterator var8 = candidates.iterator(); while(var8.hasNext()) &#123; BeanDefinition candidate = (BeanDefinition)var8.next(); ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) &#123; this.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName); &#125; if (candidate instanceof AnnotatedBeanDefinition) &#123; AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate); &#125; // 检查每个 BeanDefinition 是否在容器中存在, 不存在则返回true if (this.checkCandidate(beanName, candidate)) &#123; // 创建 BeanDefinitionHolder 对象封装 BeanDefinition BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); // *将创建好的对象注册到 BeanDefinitionRegistry 容器中交由Spring管理 this.registerBeanDefinition(definitionHolder, this.registry); &#125; &#125; &#125; return beanDefinitions; &#125; 上面将mapper对象封装好了注册到 BeanDefinitionRegistry 容器中交由Spring管理, 接着返回 BeanDefinitionHolder 集合继续处理 123456789101112131415@Override public Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages); if (beanDefinitions.isEmpty()) &#123; LOGGER.warn(() -&gt; &quot;No MyBatis mapper was found in &#x27;&quot; + Arrays.toString(basePackages) + &quot;&#x27; package. Please check your configuration.&quot;); &#125; else &#123; // *接下来处理BeanDefinition processBeanDefinitions(beanDefinitions); &#125; return beanDefinitions; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123; GenericBeanDefinition definition; for (BeanDefinitionHolder holder : beanDefinitions) &#123; definition = (GenericBeanDefinition) holder.getBeanDefinition(); String beanClassName = definition.getBeanClassName(); LOGGER.debug(() -&gt; &quot;Creating MapperFactoryBean with name &#x27;&quot; + holder.getBeanName() + &quot;&#x27; and &#x27;&quot; + beanClassName + &quot;&#x27; mapperInterface&quot;); definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); // issue #59 // mapper接口是Bean的原始类，但是Bean的实际类被替换成了 MapperFactoryBean // 这里的 this.mapperFactoryBeanClass 是 MapperFactoryBean.class 对象 // private Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = MapperFactoryBean.class; definition.setBeanClass(this.mapperFactoryBeanClass); definition.getPropertyValues().add(&quot;addToConfig&quot;, this.addToConfig); boolean explicitFactoryUsed = false; if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) &#123; definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, new RuntimeBeanReference(this.sqlSessionFactoryBeanName)); explicitFactoryUsed = true; &#125; else if (this.sqlSessionFactory != null) &#123; definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, this.sqlSessionFactory); explicitFactoryUsed = true; &#125; if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) &#123; if (explicitFactoryUsed) &#123; LOGGER.warn( () -&gt; &quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;); &#125; definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, new RuntimeBeanReference(this.sqlSessionTemplateBeanName)); explicitFactoryUsed = true; &#125; else if (this.sqlSessionTemplate != null) &#123; if (explicitFactoryUsed) &#123; LOGGER.warn( () -&gt; &quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;); &#125; definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, this.sqlSessionTemplate); explicitFactoryUsed = true; &#125; if (!explicitFactoryUsed) &#123; LOGGER.debug(() -&gt; &quot;Enabling autowire by type for MapperFactoryBean with name &#x27;&quot; + holder.getBeanName() + &quot;&#x27;.&quot;); definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE); &#125; definition.setLazyInit(lazyInitialization); &#125; &#125; 这里 mapper接口是Bean的原始类，但是Bean的实际类被替换成了 MapperFactoryBean, MapperFactoryBean 对象又是什么东西? 3. MapperFactoryBean 对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// *要点一: 该类继承了 SqlSessionDaoSupport, SqlSessionDaoSupport 对象里面可以获取 SqlSessionTemplate 对象// SqlSessionTemplate 对象是 DefaultSqlSession 的替代品, 实现同一事务的情况下保证线程安全的, 每次请求的时候都会创建一个新的 SqlSessionpublic class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; &#123; private Class&lt;T&gt; mapperInterface; private boolean addToConfig = true; public MapperFactoryBean() &#123; // intentionally empty &#125; public MapperFactoryBean(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; @Override protected void checkDaoConfig() &#123; super.checkDaoConfig(); notNull(this.mapperInterface, &quot;Property &#x27;mapperInterface&#x27; is required&quot;); Configuration configuration = getSqlSession().getConfiguration(); if (this.addToConfig &amp;&amp; !configuration.hasMapper(this.mapperInterface)) &#123; try &#123; configuration.addMapper(this.mapperInterface); &#125; catch (Exception e) &#123; logger.error(&quot;Error while adding the mapper &#x27;&quot; + this.mapperInterface + &quot;&#x27; to configuration.&quot;, e); throw new IllegalArgumentException(e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; &#125; // *要点二: 该类实现了 FactoryBean&lt;T&gt; 接口, 重写 getObject() 方法, // 从 SqlSessionTemplate 对象中获取 Mapper 接口的代理对象 // 后面的逻辑与之前未整合 Spring 的逻辑一致了..... @Override public T getObject() throws Exception &#123; return getSqlSession().getMapper(this.mapperInterface); &#125; @Override public Class&lt;T&gt; getObjectType() &#123; return this.mapperInterface; &#125; @Override public boolean isSingleton() &#123; return true; &#125; public void setMapperInterface(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; public Class&lt;T&gt; getMapperInterface() &#123; return mapperInterface; &#125; public void setAddToConfig(boolean addToConfig) &#123; this.addToConfig = addToConfig; &#125; public boolean isAddToConfig() &#123; return addToConfig; &#125;&#125; 允许注入MyBatis映射器接口的BeanFactory。 可以使用SqlSessionFactory或预配置的SqlSessionTemplate进行设置。*要点一: 该类继承了 SqlSessionDaoSupport, SqlSessionDaoSupport 对象里面可以获取 SqlSessionTemplate 对象 SqlSessionTemplate 对象是 DefaultSqlSession 的替代品, 实现同一事务的情况下还保证线程安全的, 每次请求的时候都会创建一个新的 DefualtSqlSession *要点二: 该类实现了 FactoryBean 接口, 重写 getObject() 方法, 从 SqlSessionTemplate 对象中获取 Mapper 接口的代理对象 后面的逻辑与之前未整合 Spring 的逻辑一致了….. 4. SqlSessionTemplate 对象为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的?12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class SqlSessionTemplate implements SqlSession, DisposableBean &#123; private final SqlSessionFactory sqlSessionFactory; private final ExecutorType executorType; private final SqlSession sqlSessionProxy; private final PersistenceExceptionTranslator exceptionTranslator; ...... public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) &#123; notNull(sqlSessionFactory, &quot;Property &#x27;sqlSessionFactory&#x27; is required&quot;); notNull(executorType, &quot;Property &#x27;executorType&#x27; is required&quot;); this.sqlSessionFactory = sqlSessionFactory; this.executorType = executorType; this.exceptionTranslator = exceptionTranslator; // 1. 在初始化的时候通过这里创建 SqlSessionFactory 代理类, // 该代理类实现SqlSession接口，定义了方法拦截器，如果调用代理类实例中实现SqlSession接口定义的方法， // 该调用则被导向 SqlSessionInterceptor 的invoke方法 this.sqlSessionProxy = (SqlSession) newProxyInstance( SqlSessionFactory.class.getClassLoader(), new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor() ); &#125; ...... private class SqlSessionInterceptor implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 2. 为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的? // 此处则是关键, 进入该方法 getSqlSession(...) SqlSession sqlSession = getSqlSession(SqlSessionTemplate.this.sqlSessionFactory, SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator); try &#123; // 调用从Spring的事物上下文获取事物范围内的sqlSession对象 Object result = method.invoke(sqlSession, args); //然后判断一下当前的sqlSession是否被Spring托管 如果未被Spring托管则自动commit if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) &#123; // force commit even on non-dirty sessions because some databases require // a commit/rollback before calling close() sqlSession.commit(true); &#125; return result; &#125; catch (Throwable t) &#123; Throwable unwrapped = unwrapThrowable(t); if (SqlSessionTemplate.this.exceptionTranslator != null &amp;&amp; unwrapped instanceof PersistenceException) &#123; // release the connection to avoid a deadlock if the translator is no loaded. See issue #22 closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); sqlSession = null; Throwable translated = SqlSessionTemplate.this.exceptionTranslator .translateExceptionIfPossible((PersistenceException) unwrapped); if (translated != null) &#123; unwrapped = translated; &#125; &#125; throw unwrapped; &#125; finally &#123; if (sqlSession != null) &#123; closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); &#125; &#125; &#125; &#125;&#125; 在初始化的时候在构造方法中创建 SqlSessionFactory 代理类, 该代理类实现SqlSession接口，定义了方法拦截器，如果调用代理类实例中实现SqlSession接口定义的方法，该调用则被导向 SqlSessionInterceptor 的invoke方法 (代理对象的 InvocationHandler 就是 SqlSessionInterceptor，如果把它命名为SqlSessionInvocationHandler则更好理解！） 为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的? 此处则是关键, 进入该方法 SqlSession sqlSession = getSqlSession(SqlSessionTemplate.this.sqlSessionFactory, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator); 123456789101112131415161718192021222324252627public static SqlSession getSqlSession(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) &#123; notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED); notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED); // 进入 TransactionSynchronizationManager.getResource(...) 方法 // 根据sqlSessionFactory从当前线程对应的资源map中获取SqlSessionHolder， // 当sqlSessionFactory创建了sqlSession， // 就会在事务管理器中添加一对映射：key为sqlSessionFactory，value为SqlSessionHolder，该类保存sqlSession及执行方式 SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory); //从SqlSessionHolder中提取SqlSession对象 SqlSession session = sessionHolder(executorType, holder); if (session != null) &#123; return session; &#125; LOGGER.debug(() -&gt; &quot;Creating a new SqlSession&quot;); // 如果当前事物管理器中获取不到SqlSessionHolder对象就重新创建一个 session = sessionFactory.openSession(executorType); registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session); return session; &#125; 进入 TransactionSynchronizationManager.getResource(…) 方法 SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory); 123456789101112@Nullable public static Object getResource(Object key) &#123; Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key); // 这里 value 为返回结果, 可以进去看这个 value 是什么对象, 进入 doGetResource() 方法 Object value = doGetResource(actualKey); if (value != null &amp;&amp; logger.isTraceEnabled()) &#123; logger.trace(&quot;Retrieved value [&quot; + value + &quot;] for key [&quot; + actualKey + &quot;] bound to thread [&quot; + Thread.currentThread().getName() + &quot;]&quot;); &#125; return value; &#125; 这里 value 为返回结果, 可以进去看这个 value 是什么对象, 进入 doGetResource() 方法 Object value = doGetResource(actualKey); 1234567891011121314151617181920@Nullable private static Object doGetResource(Object actualKey) &#123; // 最后从 resources 这个集合中获取的对象, 然而这个 resources 就是一个 ThreadLocal 对象, 保证了线程安全 Map&lt;Object, Object&gt; map = (Map)resources.get(); if (map == null) &#123; return null; &#125; else &#123; Object value = map.get(actualKey); if (value instanceof ResourceHolder &amp;&amp; ((ResourceHolder)value).isVoid()) &#123; map.remove(actualKey); if (map.isEmpty()) &#123; resources.remove(); &#125; value = null; &#125; return value; &#125; &#125; 最后从 resources 这个集合中获取的对象, 然而这个 resources 就是一个 ThreadLocal 对象, 保证了线程安全 Map&lt;Object, Object&gt; map = (Map)resources.get(); 1234567public abstract class TransactionSynchronizationManager &#123; ...... private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = new NamedThreadLocal(&quot;Transactional resources&quot;); ......&#125; 5. Mybatis 不是有 SqlSessionManager 了吗？为什么又提供了 SqlSessionTemplate？ SqlSessionManager: SqlSessionManager 是由开发者自身决定如何使用 SqlSession 的, 是适合在不整合 Spring 框架的时候使用。 SqlSessionTemplate: SqlSessionTemplate 是 MyBatis 专门为 Spring 提供的，支持 Spring 框架的一个 SqlSession 获取接口。主要是为了继承 Spring，并同时将是否共用 SqlSession 的权限交给 Spring 去管理。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://pdyun.cc/categories/MyBatis/"}],"tags":[],"author":"Peilin Deng"},{"title":"HHHHA","slug":"newpapername","date":"2021-08-06T05:06:24.000Z","updated":"2021-08-07T08:22:25.067Z","comments":true,"path":"2021/08/06/newpapername/","link":"","permalink":"http://pdyun.cc/2021/08/06/newpapername/","excerpt":"","text":"念两句诗 挑选中... jinrishici.load(function(result) { poem.innerHTML = result.data.content info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》' document.getElementById(\"poem\").value(poem); document.getElementById(\"info\").value(info); });","categories":[],"tags":[]}],"categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://pdyun.cc/categories/MyBatis/"}],"tags":[{"name":"hello","slug":"hello","permalink":"http://pdyun.cc/tags/hello/"},{"name":"hexo","slug":"hexo","permalink":"http://pdyun.cc/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"http://pdyun.cc/tags/markdown/"}]}