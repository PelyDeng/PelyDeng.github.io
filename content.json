{"meta":{"title":"牧场小站","subtitle":"","description":"IT 小站， 记录美好码园生活","author":"Peilin Deng","url":"http://pdyun.cc","root":"/"},"pages":[{"title":"关于我","date":"2021-08-06T12:56:57.000Z","updated":"2021-08-07T08:23:50.870Z","comments":false,"path":"about/index.html","permalink":"http://pdyun.cc/about/index.html","excerpt":"","text":"正在播放《每天一遍，可莉完蛋》 ●━───────00:04 ⇆ ᐊ Ⅱ ᐅ ↻ 念两句诗 挑选中... jinrishici.load(function(result) { poem.innerHTML = result.data.content info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》' document.getElementById(\"poem\").value(poem); document.getElementById(\"info\").value(info); });"},{"title":"所有分类","date":"2021-08-06T12:55:40.000Z","updated":"2021-08-07T05:19:51.774Z","comments":false,"path":"categories/index.html","permalink":"http://pdyun.cc/categories/index.html","excerpt":"","text":""},{"title":"标签页","date":"2021-08-06T12:56:28.000Z","updated":"2021-08-07T05:20:48.804Z","comments":false,"path":"tags/index.html","permalink":"http://pdyun.cc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring 启动流程简述","slug":"Spring-启动流程","date":"2021-08-20T05:47:00.000Z","updated":"2021-08-20T07:10:45.327Z","comments":true,"path":"2021/08/20/Spring-启动流程/","link":"","permalink":"http://pdyun.cc/2021/08/20/Spring-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","excerpt":"beanDefinitionMap -&gt; 用来存储 BeanDefinition(Bean 的配置信息)factoryBeanObjectCache -&gt; 用来存储原生 Bean 对象的Map, 指反射创建出的实际对象factoryBeanInstanceCache -&gt; 用来存储 BeanWrapper 的Map, 指原生 Bean 的包装类 Spring 启动流程简述一. 配置阶段 web.xml1234DispatcherServlet 路径设定 init-param ( contextConfigLocation = classPath:application.xml )设定 url-pattern ( /* )配置 Annotation 等","text":"beanDefinitionMap -&gt; 用来存储 BeanDefinition(Bean 的配置信息)factoryBeanObjectCache -&gt; 用来存储原生 Bean 对象的Map, 指反射创建出的实际对象factoryBeanInstanceCache -&gt; 用来存储 BeanWrapper 的Map, 指原生 Bean 的包装类 Spring 启动流程简述一. 配置阶段 web.xml1234DispatcherServlet 路径设定 init-param ( contextConfigLocation = classPath:application.xml )设定 url-pattern ( /* )配置 Annotation 等 appication.xml1配置 包扫描路径、Bean定义、视图解析配置等...... …… 二. 初始化阶段 Servlet.init() 12Spring 是 servlet 编程模型, 容器启动时会调用 servlet 的 init() 方法, 在该方法中会读取配置进行 IoC 容器及 MVC 组件的初始化. IoC 部分 (定位、加载、注册) 1234初始化 IoC 容器 1. 通过 web.xml 的配置定位 application .xml配置文件. 2. 使用 BeanDefinitionReader 读取配置文件, 扫描类并封装成 BeanDefinition 3. 创建 BeanFatory, 将 *beanDefinition 注册到 DefalutListableBeanFactory 的 beanDefinitionMap 中 DI 、 AOP 部分 123456784. 初始化非延迟加载的 bean0). 标记 bean 为创建中 1). 通过反射 new 出 bean 对象, 封装成 BeanWrapper 对象 2). 如果 bean 为单例且支持循环依赖则生成三级缓存 singletonFactories, 可提前暴露 bean 3). 填充bean属性，解决属性依赖 4). 初始化bean的各个Aware接口(各个Aware接口能让bean获取到部分属性: ApplicationContextAware-能获取到ApplicationContex; BeanFactoryAware 能获取到 BeanFactory) 并执行各类 bean 的后处理器, 执行初始化方法, 如果有 AOP 配置需要生成 AOP 代理对象 5). 如果存在循环依赖，解决之 – 这里有点问题，这一步是如果之前解决了aop循环依赖，则缓存中放置了提前生成的代理对象，然后使用原始bean继续执行初始化，所以需要再返回最终bean前，把原始bean置换为代理对象返回。 6). 此时 bean 已经可以使用, 将 bean 放入一级缓存 singletonObjects , 移除创建中标记以及二三级缓存 MVC 部分 12345678910111213141516171819205. 初始化 MVC 九大组件// 1). 初始化文件上传解析器initMultipartResolver(context);// 2). 初始化本地语言环境initLocaleResolver(context);// 3). 初始化模板处理器initThemeResolver(context);// 4). 初始化 HandlerMapping 组件initHandlerMappings(context);// 5). 初始化参数适配器initHandlerAdapters(context);// 6). 初始化异常拦截器initHandlerExceptionResolvers(context);// 7). 初始化视图预处理器initRequestToViewNameTranslator(context);// 8). 初始化视图解析器initViewResolvers(context);// 9). 初始化 FlashMap 管理器( 为了解决请求转发和重定向过程中参数的丢失问题: redirect-&gt;重定向, request 参数会丢失 ; forward-&gt;转发, 自动将 request 参数系诶带到下一个请求 )initFlashMapManager(context); 三. 运行阶段 从页面点击按钮或者 url 访问资源请求会先到 DispatcherServlet 的 doDispatch() 方法, 该方法会从 HandlerMapping 中通过 url 去匹配对应的控制器及方法 通过参数解析器解析参数并反射执行方法, 返回一个 ModelAndView 通过视图解析器解析 ModelAndView, 决定返回页面或者输出数据 前端根据对应结果来展示","categories":[{"name":"摘抄笔记","slug":"摘抄笔记","permalink":"http://pdyun.cc/categories/%E6%91%98%E6%8A%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://pdyun.cc/tags/Spring/"}],"author":"Peilin Deng"},{"title":"Spring 基础认知与技术架构","slug":"Spring-基础认知与技术架构","date":"2021-08-19T15:10:00.000Z","updated":"2021-08-19T15:25:13.981Z","comments":true,"path":"2021/08/19/Spring-基础认知与技术架构/","link":"","permalink":"http://pdyun.cc/2021/08/19/Spring-%E5%9F%BA%E7%A1%80%E8%AE%A4%E7%9F%A5%E4%B8%8E%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/","excerpt":"Spring Spring 是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。 Spring最根本的使命是解决企业级应用开发的复杂性，即简化Java开发。 1. Spring 简化开发的四个基本策略 基于POJO 的轻量级和最小侵入性编程. 通过依赖注入和面向接口松耦合. 基于切面和惯性进行声明式编程. 通过切面和模板减少样版式代码.","text":"Spring Spring 是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。 Spring最根本的使命是解决企业级应用开发的复杂性，即简化Java开发。 1. Spring 简化开发的四个基本策略 基于POJO 的轻量级和最小侵入性编程. 通过依赖注入和面向接口松耦合. 基于切面和惯性进行声明式编程. 通过切面和模板减少样版式代码. 2. Spring 中的编程思想 Spring思想 应用场景 (特点) 一句话归纳 OOP Object Oriented Programming (面向对象编程) 用程序归纳总结生活中一切事物 封装、继承、多态. BOP Bean Oriented Programming (面向Bean编程) 面向Bean (普通Java类) 设计程序, 解放程序员. 一切从Bean开始. AOP Aspect Oriented Programming (面向切面编程) 找出多个类中有一定规律的代码, 开发时拆开, 应运行时再合并. 面向切面编程, 及面向规则编程. 解耦, 专人做专事. IoC Inversion of Control (控制反转) 将new对象的动作交给Spring管理, 并由Spring保存已创建的对象 (IOC容器). 转交控制权(即控制权反转). DI/DL Dependency Injection (依赖注入) 或者Dependency Lookup (依赖查找) , Spring不仅保存自己创建的对象, 而且保存对象与对象之间的关系. 注入即赋值, 主要三种方式 — 构造方法、set方法、直接赋值. 自动赋值. 3. Spring 注解编程演化 V1.X | V2.0 | V2.5 | V3.X | V4.X | V5.X—|—|—|—|—|—|— 注解驱动启蒙时代 | 注解驱动过渡时代 | 引入新的骨架式Annotation | 注解驱动黄金时代 | 注解驱动完善时代 | 注解驱动成熟时代 4. Spring 模块结构 Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access/Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中。 5. Spring 系统架构模块功能介绍Spring 核心模块 模块名称 主要功能 spring-core IoC控制反转与DI依赖注入的最基本实现 spring-beans Bean工厂与Bean的装配 spring-context 定义基础的Spring的Context上下文即IoC容器 spring-context-support 对Spring IoC的扩展支持, 以及IoC子容器 spring-context-indexer Spring的类管理组件和Classpath扫描 spring-expression Spring表达式语言 Spring 面向切面编程模块 模块名称 主要功能 spring-aop 面向切面编程的引用模块, 整合Asm, CGLib、JDKProxy spring-aspects 继承AspectJ, AOP应用框架 spring-instrument 动态Class Loading模块 Spring 数据访问与继承模块 模块名称 主要功能 spring-jdbc Spring 提供的JDBC抽象框架的组要实现模块, 用于简化 Spring JDBC 操作 spring-tx Spring JDBC 事务控制实现模块 spring-orm 主要继承 Hibernate, Java Persitence API (JPA) 和 Java Data Object (JDO) spring-oxm 将Java对象映射成XML数据, 或者将XML数据映射成Java对象 spring-jms Java Messaging Service 能够发送和接收信息 Spring Web 模块 模块名称 主要功能 spring-web 提供了最基础Web支持, 主要建立于核心容器之上, 通过 Servlet 或者 Listeners 来初始化 IoC 容器 spring-webmvc 实现了 Spring-MVC (model-view-controller) 的 Web 应用 spring-websokect 主要是与 Web 前端的全双工通讯的协议 spring-webflux 一个新的非阻塞函数式 Reactive Web 框架, 可以用来建立异步的. 非阻塞, 事件驱动的服务 Spring 通信报文 模块 模块名称 主要功能 spring-messaging 从 Spring4 开始新加入的一个模块, 主要职责是为 Spring 框架继承一些基础的报文传输应用 Spring 集成测试 模块 模块名称 主要功能 spring-test 主要为测试提供支持的 Spring 集成兼容 模块 模块名称 主要功能 spring-framwork-bom Bill of Materials. 解除 Spring 的不同模块依赖版本不同问题 6. Spring 模块之依赖关系图 7. 版本命名规则Spring 版本命名规则 其他常见软件版本命名规则 语义化版本命名通用规则 商业软件中常见的修饰词","categories":[{"name":"摘抄笔记","slug":"摘抄笔记","permalink":"http://pdyun.cc/categories/%E6%91%98%E6%8A%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://pdyun.cc/tags/Spring/"}],"author":"Peilin Deng"},{"title":"外网访问家庭网络小记","slug":"外网访问家庭网络小记","date":"2021-08-13T16:16:00.000Z","updated":"2021-08-13T16:44:04.286Z","comments":true,"path":"2021/08/14/外网访问家庭网络小记/","link":"","permalink":"http://pdyun.cc/2021/08/14/%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E7%BD%91%E7%BB%9C%E5%B0%8F%E8%AE%B0/","excerpt":"记录一次家庭内网使用DDNS让外网访问, 同时动态更新域名123此篇文章献给&#x27;懒人&#x27;同学~ 相信很多同学在自己家里学习啥的搞些小网站小程序, 比如部署一些在线看视频丶个人网盘丶个人博客等的网站, 但是在公司时想访问记录或查询一些资料, 但是又因为访问不了家庭网络而烦躁... 在此分享能使用任意外网访问家庭内网, 同时动态更新域名的方法.当然在此之前我使用过花生壳、公云等一些软件, 他也可以让你从外网访问家庭内网, 但是别的不说, 他限速而且收费呀… 自己搭建可以全速使用家里的带宽步骤如下: 一. 外网访问","text":"记录一次家庭内网使用DDNS让外网访问, 同时动态更新域名123此篇文章献给&#x27;懒人&#x27;同学~ 相信很多同学在自己家里学习啥的搞些小网站小程序, 比如部署一些在线看视频丶个人网盘丶个人博客等的网站, 但是在公司时想访问记录或查询一些资料, 但是又因为访问不了家庭网络而烦躁... 在此分享能使用任意外网访问家庭内网, 同时动态更新域名的方法.当然在此之前我使用过花生壳、公云等一些软件, 他也可以让你从外网访问家庭内网, 但是别的不说, 他限速而且收费呀… 自己搭建可以全速使用家里的带宽步骤如下: 一. 外网访问 1. 申请公网IP 想访问家庭网络必定需要找家里开网络的运营商, 让他们给开公网IP, 我家里使用的是电信宽带, 电话直接打 10000 号人工服务让他们帮忙开通, 理由嘛很简单( 找个借口说家里安装监控就给你开了 ) , 电信现在默认都是给的私网IP. 2. 光猫改为桥接模式 申请完公网IP先别急着挂, 还需要让他们把宽带网络改成桥接模式, 后面我们路由器使用拨号上网 3. 查询宽带账号和密码 由于路由器现在是使用拨号上网, 所以还需要找他运营商拿到宽带的账户和密码, 这些都是必要条件 4. 设备网线连接 我们使用网线连接 光猫的网口 和 路由器WAN口, 主机的网线则联通路由器的LAN口, ( WAN口是连接外部网络, LAN口是连接内部网络, 家里的电脑网线都可以用LAN接口连接, 并且此时我们电脑是没有网络的 ) 12graph LR光猫网口 --&gt; 路由器WAN口 12graph LR路由器LAN口 --&gt; 电脑网口 5. 设置路由器 此时已经具备的条件:公网ip, 宽带改为桥接模式, 宽带账号和密码, 设备网线正确连接 开始设置路由器: 我的路由器设备使用的小米路由器, 暂以小米路由器为例, 路由器网关是 192.168.31.1 , 自己的路由器网关自己搜一下, 然后输入路由器用户名密码 上网设置如图, 上网方式选择PPPOE手动拨号, 然后输入宽带的账号和密码即可 拨号成功应该就可以上网了~~~ 6. 检查IP地址 百度查询自己本机的IP是否与路由器拨号成功获得的IP地址相同.++如果不同, 那一般都是私网ip 没有申请公网ip的.++ 7. 路由转发 一般路由器都拥有路由转发功能, 可以自己配置转发规则. 端口转发: 映射端口, 访问外网 ip:端口, 会直接映射到内网的ip:端口如: **访问外网地址 22.135.173.55:8848, 会被转发到内网 192.168.31.26:8000 ** 8. 测试 我本地电脑随便开启一个服务部署成功, 内网ip:port 192.168.31.26:8401 接着使用外网ip访问, 注意自己映射的端口哦访问成功~~ 二. 设置动态更新域名12由于电信给的公网IP是动态IP, 每次关闭重启光猫都会更换公网IP地址, 所以这也是个很头疼的事情... 个人方案解决了该情况 1. 准备域名 ( 本方案只支持腾讯云域名, 对接腾讯云API ) 我使用的方法, 使用Python写了一个脚本, 动态去更新域名, 需要准备一个腾讯云的域名。提供购买链接 https://buy.cloud.tencent.com/domain?from=console 2. 开通腾讯云 API 密钥 API 密钥代表你的账号身份和所拥有的权限，使用腾讯云 API 可以操作您名下的所有腾讯云资源。给上链接 https://console.cloud.tencent.com/cam/capi 开通完后新建密钥( 单机即可, 自动创建 ): 3. 安装Python3 由于使用的 Python 写的脚本, 需要环境拥有Python, 版本 3 及以上.安装方法参考 https://www.cnblogs.com/weven/p/7252917.html安装完成后查看Python版本: 4. 献上脚本 复制以下代码 保存为 xxx.py 格式就行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197VERSION = 1from hashlib import sha1import jsonimport timeimport base64import hmacclass DDnsHelper(): def __init__(self, mid=0, params=&#123;&#125;): pass def excute(self): import requests SecretId = &#x27;*需要填写*&#x27; SecretKey = &#x27;*需要填写*&#x27; runningPause = 20 domainName = &#x27;pelyhome.cc&#x27; # *需要填写你自己的域名* ddnsDomains = [ &#123; # *需要填写你自己的域名* &#x27;name&#x27;: &#x27;@.pelyhome.cc&#x27;, &#x27;value&#x27;: &#x27;&#x27;, # &#x27;always&#x27;: False, # DNS生存时间 &#x27;ttl&#x27;: 600, # 主机记录, 即域名前缀 &#x27;subDomain&#x27;: &#x27;@&#x27;, &#x27;recordId&#x27;: &#x27;&#x27;, # 记录类型 &#x27;recordType&#x27;: &#x27;A&#x27;, # 线路类型, 指定细分解析线路 &#x27;recordLine&#x27;: &#x27;默认&#x27;, &#x27;description&#x27;: &#x27;本地提供api服务的地址&#x27;, # 查看本地域名的接口, 这是自己写的接口, 仅仅返回一个纯粹的本地外网IP地址 &#x27;localDomain&#x27;: &#x27;https://www.hosix.cn/ip&#x27;, &#x27;localValue&#x27;: &#x27;&#x27; &#125; ] class tenXunDDNS_Helper(): def __init__(self): self.running = True self.action = &quot;&quot; self.secretId = SecretId self.nonce = 38651 self.region = &#x27;ap-guangzhou&#x27; self.secretKey = SecretKey self.version = &#x27;2017-03-12&#x27; self.domain = domainName self.url = &#x27;cns.api.qcloud.com/v2/index.php&#x27; self.httpType = &#x27;https://&#x27; self.endpoint = self.httpType + self.url self.ddnsDomain = ddnsDomains self.runningPause = runningPause self.remoteRecords = [] def getServerIp(self): timeStamp = int(time.time()) params = &#123;&#125; params[&#x27;Action&#x27;] = &#x27;RecordList&#x27; params[&#x27;domain&#x27;] = self.domain params[&#x27;Nonce&#x27;] = self.nonce params[&#x27;SecretId&#x27;] = self.secretId params[&#x27;Timestamp&#x27;] = timeStamp s = self.get_string_to_sign(&quot;GET&quot;, self.url, params) Signature = self.sign_str(self.secretKey, s, sha1) params[&#x27;Signature&#x27;] = Signature response = requests.get(self.endpoint, params=params) result = json.loads(response.text) if int(result[&#x27;code&#x27;]) != 0: raise Exception(&#x27;获取域名失败&#x27; + &#x27;:&#x27; + str(result[&#x27;code&#x27;]) + &#x27;:&#x27; + result[&#x27;message&#x27;]) data = result[&#x27;data&#x27;] self.remoteRecords = data[&#x27;records&#x27;] # print(self.remoteRecords) def postServerIp(self, domain): timeStamp = int(time.time()) params = &#123;&#125; params[&#x27;Action&#x27;] = &#x27;RecordCreate&#x27; params[&#x27;domain&#x27;] = self.domain params[&#x27;Nonce&#x27;] = self.nonce params[&#x27;SecretId&#x27;] = self.secretId params[&#x27;Timestamp&#x27;] = timeStamp params[&#x27;subDomain&#x27;] = domain[&#x27;subDomain&#x27;] params[&#x27;recordType&#x27;] = domain[&#x27;recordType&#x27;] params[&#x27;recordLine&#x27;] = domain[&#x27;recordLine&#x27;] params[&#x27;value&#x27;] = domain[&#x27;value&#x27;] params[&#x27;ttl&#x27;] = domain[&#x27;ttl&#x27;] s = self.get_string_to_sign(&quot;GET&quot;, self.url, params) Signature = self.sign_str(self.secretKey, s, sha1) params[&#x27;Signature&#x27;] = Signature response = requests.get(self.endpoint, params=params) result = json.loads(response.text) if int(result[&#x27;code&#x27;]) != 0: raise Exception(&#x27;添加域名失败&#x27; + &#x27;:&#x27; + str(result[&#x27;code&#x27;]) + &#x27;:&#x27; + result[&#x27;message&#x27;]) data = result[&#x27;data&#x27;] print(&#x27;添加域名成功ip:%s,本地ip:%s,域名:%s&#x27; % (domain[&#x27;value&#x27;], domain[&#x27;localValue&#x27;], domain[&#x27;name&#x27;])) def updateServerIp(self, domain): timeStamp = int(time.time()) params = &#123;&#125; params[&#x27;Action&#x27;] = &#x27;RecordModify&#x27; params[&#x27;domain&#x27;] = self.domain params[&#x27;Nonce&#x27;] = self.nonce params[&#x27;SecretId&#x27;] = self.secretId params[&#x27;Timestamp&#x27;] = timeStamp params[&#x27;subDomain&#x27;] = domain[&#x27;subDomain&#x27;] params[&#x27;recordId&#x27;] = domain[&#x27;recordId&#x27;] params[&#x27;recordType&#x27;] = domain[&#x27;recordType&#x27;] params[&#x27;recordLine&#x27;] = domain[&#x27;recordLine&#x27;] params[&#x27;value&#x27;] = domain[&#x27;localValue&#x27;] params[&#x27;ttl&#x27;] = domain[&#x27;ttl&#x27;] s = self.get_string_to_sign(&quot;GET&quot;, self.url, params) Signature = self.sign_str(self.secretKey, s, sha1) params[&#x27;Signature&#x27;] = Signature response = requests.get(self.endpoint, params=params) result = json.loads(response.text) if int(result[&#x27;code&#x27;]) != 0: raise Exception(&#x27;更新域名失败&#x27; + &#x27;:&#x27; + str(result[&#x27;code&#x27;]) + &#x27;:&#x27; + result[&#x27;message&#x27;]) data = result[&#x27;data&#x27;] print(&#x27;更新域名成功源ip:%s,本地ip:%s,域名:%s&#x27; % (domain[&#x27;value&#x27;], domain[&#x27;localValue&#x27;], domain[&#x27;name&#x27;])) def deleteServerIp(self): pass def getLocalDomain(self, domain): res = requests.get(domain[&#x27;localDomain&#x27;]) ip = res.content.decode(&quot;utf-8&quot;).strip() return ip def clearDnsRecord(self): for domain in self.ddnsDomain: if not domain[&#x27;always&#x27;]: domain[&#x27;value&#x27;] = &#x27;&#x27; domain[&#x27;localValue&#x27;] = &#x27;&#x27; def run(self): self.getServerIp() for domain in self.ddnsDomain: if (not domain[&#x27;always&#x27;]): # 获取本地ip try: domain[&#x27;localValue&#x27;] = self.getLocalDomain(domain) except Exception as e: print(&quot;获取本地ip失败 不更新:%s,本地ip:%s,域名:%s&quot; % ( domain[&#x27;value&#x27;], domain[&#x27;localValue&#x27;], domain[&#x27;name&#x27;])) else: continue flag = False for remoteDomain in self.remoteRecords: if (domain[&#x27;subDomain&#x27;] == remoteDomain[&#x27;name&#x27;]): domain[&#x27;recordId&#x27;] = remoteDomain[&#x27;id&#x27;] domain[&#x27;value&#x27;] = remoteDomain[&#x27;value&#x27;] flag = True break if flag: if (domain[&#x27;value&#x27;] == domain[&#x27;localValue&#x27;]): pass # print(&quot;无需更新ip:%s,本地ip:%s,域名:%s&quot; % (domain[&#x27;value&#x27;],domain[&#x27;localValue&#x27;],domain[&#x27;name&#x27;])) else: self.updateServerIp(domain) continue else: domain[&#x27;value&#x27;] = domain[&#x27;localValue&#x27;] self.postServerIp(domain) self.clearDnsRecord() def start(self): start_time = int(time.time()) while self.running: next_time = int(time.time()) + self.runningPause if (next_time - start_time) &gt; self.runningPause: try: self.run() except Exception as e: print(e.__str__()) start_time = start_time + self.runningPause else: time.sleep(self.runningPause / 10) def get_string_to_sign(self, method, endpoint, params): s = method + endpoint + &quot;?&quot; query_str = &quot;&amp;&quot;.join(&quot;%s=%s&quot; % (k, params[k]) for k in sorted(params)) # print(s + query_str) return s + query_str def sign_str(self, key, s, method): hmac_str = hmac.new(key.encode(&quot;utf8&quot;), s.encode(&quot;utf8&quot;), method).digest() return base64.b64encode(hmac_str) t1 = tenXunDDNS_Helper() t1.start()d = DDnsHelper()d.excute() 最后双击运行~ OK 5. 运行原理和注意事项 原理:该脚本是通过查询公网IP接口:https://www.hosix.cn/ip 来判断公网ip是否发生了改变, 如果发生了改变, 就会调用腾讯云API去动态更新域名. 非常简单….. 注意事项: 1.该脚本需要持续运行, 如果是Linux系统, 直接挂后台运行即可, 该脚本资源消耗不高2.如果提示没requests 运行下, 打开cmd窗口输入: pip install requests3.如运行闪退, 请检查域名等是否正确填写 如有问题请评论或留言: &#x35;&#x34;&#52;&#x30;&#49;&#x30;&#49;&#54;&#53;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#109;","categories":[{"name":"摘抄笔记","slug":"摘抄笔记","permalink":"http://pdyun.cc/categories/%E6%91%98%E6%8A%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"访问家庭内网","slug":"访问家庭内网","permalink":"http://pdyun.cc/tags/%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E5%86%85%E7%BD%91/"},{"name":"动态DDNS","slug":"动态DDNS","permalink":"http://pdyun.cc/tags/%E5%8A%A8%E6%80%81DDNS/"}],"author":"Peilin Deng"},{"title":"MyBatis 运行时序图","slug":"MyBatis-运行时序图","date":"2021-08-10T11:22:00.000Z","updated":"2021-08-10T12:13:29.943Z","comments":true,"path":"2021/08/10/MyBatis-运行时序图/","link":"","permalink":"http://pdyun.cc/2021/08/10/MyBatis-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%8F%E5%9B%BE/","excerpt":"架构分层","text":"架构分层 1. 创建会话工厂类 2. 创建会话 3. 获取代理对象 4. 调用代理对象方法, 执行SQL","categories":[{"name":"摘抄笔记","slug":"摘抄笔记","permalink":"http://pdyun.cc/categories/%E6%91%98%E6%8A%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://pdyun.cc/tags/MyBatis/"}],"author":"Peilin Deng"},{"title":"MyBatis 整合到 Spring 原理","slug":"A","date":"2021-08-07T07:41:00.000Z","updated":"2021-08-10T12:10:57.727Z","comments":true,"path":"2021/08/07/A/","link":"","permalink":"http://pdyun.cc/2021/08/07/A/","excerpt":"1. xml 配置 通过在Spring的 applicationContext.xml文件中做以下配置, 指定MyBatis 的mapper.xml 文件扫描路径, MapperScannerConfigurer 是 Mybatis 用于整合 Spring 的核心对象.","text":"1. xml 配置 通过在Spring的 applicationContext.xml文件中做以下配置, 指定MyBatis 的mapper.xml 文件扫描路径, MapperScannerConfigurer 是 Mybatis 用于整合 Spring 的核心对象. 1234567&lt;!--配置扫描器，将mybatis的接口实现加入到 IOC容器中 --&gt;&lt;!-- &lt;mybatis-spring:scan #base-package=&quot;com.dpl.crud.dao&quot;/&gt;--&gt; &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.gupaoedu.crud.dao&quot;/&gt; &lt;/bean&gt; 2. MapperScannerConfigurer 对象12345public class MapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware &#123; ...... ......&#125; 该对象实现了几个接口: BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware 1). BeanDefinitionRegistryPostProcessor: 如下, 重写了 ++postProcessBeanDefinitionRegistry++(…) 方法, 在该方法中进行扫描对应的 Mapper 文件 12345678910111213141516171819202122232425@Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123; if (this.processPropertyPlaceHolders) &#123; processPropertyPlaceHolders(); &#125; ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); scanner.setAddToConfig(this.addToConfig); scanner.setAnnotationClass(this.annotationClass); scanner.setMarkerInterface(this.markerInterface); scanner.setSqlSessionFactory(this.sqlSessionFactory); scanner.setSqlSessionTemplate(this.sqlSessionTemplate); scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName); scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName); scanner.setResourceLoader(this.applicationContext); scanner.setBeanNameGenerator(this.nameGenerator); scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass); if (StringUtils.hasText(lazyInitialization)) &#123; scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization)); &#125; scanner.registerFilters(); // *重点在这里 scanner.scan( StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS)); &#125; 重点在 scanner.scan(…)方法 123456789101112public int scan(String... basePackages) &#123; int beanCountAtScanStart = this.registry.getBeanDefinitionCount(); // 继续进入该方法 this.doScan(basePackages); if (this.includeAnnotationConfig) &#123; AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); &#125; return this.registry.getBeanDefinitionCount() - beanCountAtScanStart; &#125; 该方法有两个实现, 首先进入 ClassPathMapperScanner 实现 12345678910111213@Override public Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; // *这里调了父类 ClassPathBeanDefinitionScanner 的doScan 方法, 进入该方法实现 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages); if (beanDefinitions.isEmpty()) &#123; LOGGER.warn(() -&gt; &quot;No MyBatis mapper was found in &#x27;&quot; + Arrays.toString(basePackages) + &quot;&#x27; package. Please check your configuration.&quot;); &#125; else &#123; processBeanDefinitions(beanDefinitions); &#125; return beanDefinitions; &#125; 这里调了父类 ClassPathBeanDefinitionScanner 的 doScan() 方法, 进入该方法实现 123456789101112131415161718192021222324252627282930313233343536373839404142protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;); // *创建 BeanDefinitionHolder 集合, 里面封装的是 BeanDefinition 和 beanName Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet(); String[] var3 = basePackages; int var4 = basePackages.length; for(int var5 = 0; var5 &lt; var4; ++var5) &#123; String basePackage = var3[var5]; Set&lt;BeanDefinition&gt; candidates = this.findCandidateComponents(basePackage); Iterator var8 = candidates.iterator(); while(var8.hasNext()) &#123; BeanDefinition candidate = (BeanDefinition)var8.next(); ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) &#123; this.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName); &#125; if (candidate instanceof AnnotatedBeanDefinition) &#123; AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate); &#125; // 检查每个 BeanDefinition 是否在容器中存在, 不存在则返回true if (this.checkCandidate(beanName, candidate)) &#123; // 创建 BeanDefinitionHolder 对象封装 BeanDefinition BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); // *将创建好的对象注册到 BeanDefinitionRegistry 容器中交由Spring管理 this.registerBeanDefinition(definitionHolder, this.registry); &#125; &#125; &#125; return beanDefinitions; &#125; 上面将mapper对象封装好了注册到 BeanDefinitionRegistry 容器中交由Spring管理, 接着返回 BeanDefinitionHolder 集合继续处理 123456789101112131415@Override public Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages); if (beanDefinitions.isEmpty()) &#123; LOGGER.warn(() -&gt; &quot;No MyBatis mapper was found in &#x27;&quot; + Arrays.toString(basePackages) + &quot;&#x27; package. Please check your configuration.&quot;); &#125; else &#123; // *接下来处理BeanDefinition processBeanDefinitions(beanDefinitions); &#125; return beanDefinitions; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123; GenericBeanDefinition definition; for (BeanDefinitionHolder holder : beanDefinitions) &#123; definition = (GenericBeanDefinition) holder.getBeanDefinition(); String beanClassName = definition.getBeanClassName(); LOGGER.debug(() -&gt; &quot;Creating MapperFactoryBean with name &#x27;&quot; + holder.getBeanName() + &quot;&#x27; and &#x27;&quot; + beanClassName + &quot;&#x27; mapperInterface&quot;); definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); // issue #59 // mapper接口是Bean的原始类，但是Bean的实际类被替换成了 MapperFactoryBean // 这里的 this.mapperFactoryBeanClass 是 MapperFactoryBean.class 对象 // private Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = MapperFactoryBean.class; definition.setBeanClass(this.mapperFactoryBeanClass); definition.getPropertyValues().add(&quot;addToConfig&quot;, this.addToConfig); boolean explicitFactoryUsed = false; if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) &#123; definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, new RuntimeBeanReference(this.sqlSessionFactoryBeanName)); explicitFactoryUsed = true; &#125; else if (this.sqlSessionFactory != null) &#123; definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, this.sqlSessionFactory); explicitFactoryUsed = true; &#125; if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) &#123; if (explicitFactoryUsed) &#123; LOGGER.warn( () -&gt; &quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;); &#125; definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, new RuntimeBeanReference(this.sqlSessionTemplateBeanName)); explicitFactoryUsed = true; &#125; else if (this.sqlSessionTemplate != null) &#123; if (explicitFactoryUsed) &#123; LOGGER.warn( () -&gt; &quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;); &#125; definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, this.sqlSessionTemplate); explicitFactoryUsed = true; &#125; if (!explicitFactoryUsed) &#123; LOGGER.debug(() -&gt; &quot;Enabling autowire by type for MapperFactoryBean with name &#x27;&quot; + holder.getBeanName() + &quot;&#x27;.&quot;); definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE); &#125; definition.setLazyInit(lazyInitialization); &#125; &#125; 这里 mapper接口是Bean的原始类，但是Bean的实际类被替换成了 MapperFactoryBean, MapperFactoryBean 对象又是什么东西? 3. MapperFactoryBean 对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// *要点一: 该类继承了 SqlSessionDaoSupport, SqlSessionDaoSupport 对象里面可以获取 SqlSessionTemplate 对象// SqlSessionTemplate 对象是 DefaultSqlSession 的替代品, 实现同一事务的情况下保证线程安全的, 每次请求的时候都会创建一个新的 SqlSessionpublic class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; &#123; private Class&lt;T&gt; mapperInterface; private boolean addToConfig = true; public MapperFactoryBean() &#123; // intentionally empty &#125; public MapperFactoryBean(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; @Override protected void checkDaoConfig() &#123; super.checkDaoConfig(); notNull(this.mapperInterface, &quot;Property &#x27;mapperInterface&#x27; is required&quot;); Configuration configuration = getSqlSession().getConfiguration(); if (this.addToConfig &amp;&amp; !configuration.hasMapper(this.mapperInterface)) &#123; try &#123; configuration.addMapper(this.mapperInterface); &#125; catch (Exception e) &#123; logger.error(&quot;Error while adding the mapper &#x27;&quot; + this.mapperInterface + &quot;&#x27; to configuration.&quot;, e); throw new IllegalArgumentException(e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; &#125; // *要点二: 该类实现了 FactoryBean&lt;T&gt; 接口, 重写 getObject() 方法, // 从 SqlSessionTemplate 对象中获取 Mapper 接口的代理对象 // 后面的逻辑与之前未整合 Spring 的逻辑一致了..... @Override public T getObject() throws Exception &#123; return getSqlSession().getMapper(this.mapperInterface); &#125; @Override public Class&lt;T&gt; getObjectType() &#123; return this.mapperInterface; &#125; @Override public boolean isSingleton() &#123; return true; &#125; public void setMapperInterface(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; public Class&lt;T&gt; getMapperInterface() &#123; return mapperInterface; &#125; public void setAddToConfig(boolean addToConfig) &#123; this.addToConfig = addToConfig; &#125; public boolean isAddToConfig() &#123; return addToConfig; &#125;&#125; 允许注入MyBatis映射器接口的BeanFactory。 可以使用SqlSessionFactory或预配置的SqlSessionTemplate进行设置。*要点一: 该类继承了 SqlSessionDaoSupport, SqlSessionDaoSupport 对象里面可以获取 SqlSessionTemplate 对象 SqlSessionTemplate 对象是 DefaultSqlSession 的替代品, 实现同一事务的情况下还保证线程安全的, 每次请求的时候都会创建一个新的 DefualtSqlSession *要点二: 该类实现了 FactoryBean 接口, 重写 getObject() 方法, 从 SqlSessionTemplate 对象中获取 Mapper 接口的代理对象 后面的逻辑与之前未整合 Spring 的逻辑一致了….. 4. SqlSessionTemplate 对象为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的?12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class SqlSessionTemplate implements SqlSession, DisposableBean &#123; private final SqlSessionFactory sqlSessionFactory; private final ExecutorType executorType; private final SqlSession sqlSessionProxy; private final PersistenceExceptionTranslator exceptionTranslator; ...... public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) &#123; notNull(sqlSessionFactory, &quot;Property &#x27;sqlSessionFactory&#x27; is required&quot;); notNull(executorType, &quot;Property &#x27;executorType&#x27; is required&quot;); this.sqlSessionFactory = sqlSessionFactory; this.executorType = executorType; this.exceptionTranslator = exceptionTranslator; // 1. 在初始化的时候通过这里创建 SqlSessionFactory 代理类, // 该代理类实现SqlSession接口，定义了方法拦截器，如果调用代理类实例中实现SqlSession接口定义的方法， // 该调用则被导向 SqlSessionInterceptor 的invoke方法 this.sqlSessionProxy = (SqlSession) newProxyInstance( SqlSessionFactory.class.getClassLoader(), new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor() ); &#125; ...... private class SqlSessionInterceptor implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 2. 为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的? // 此处则是关键, 进入该方法 getSqlSession(...) SqlSession sqlSession = getSqlSession(SqlSessionTemplate.this.sqlSessionFactory, SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator); try &#123; // 调用从Spring的事物上下文获取事物范围内的sqlSession对象 Object result = method.invoke(sqlSession, args); //然后判断一下当前的sqlSession是否被Spring托管 如果未被Spring托管则自动commit if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) &#123; // force commit even on non-dirty sessions because some databases require // a commit/rollback before calling close() sqlSession.commit(true); &#125; return result; &#125; catch (Throwable t) &#123; Throwable unwrapped = unwrapThrowable(t); if (SqlSessionTemplate.this.exceptionTranslator != null &amp;&amp; unwrapped instanceof PersistenceException) &#123; // release the connection to avoid a deadlock if the translator is no loaded. See issue #22 closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); sqlSession = null; Throwable translated = SqlSessionTemplate.this.exceptionTranslator .translateExceptionIfPossible((PersistenceException) unwrapped); if (translated != null) &#123; unwrapped = translated; &#125; &#125; throw unwrapped; &#125; finally &#123; if (sqlSession != null) &#123; closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); &#125; &#125; &#125; &#125;&#125; 在初始化的时候在构造方法中创建 SqlSessionFactory 代理类, 该代理类实现SqlSession接口，定义了方法拦截器，如果调用代理类实例中实现SqlSession接口定义的方法，该调用则被导向 SqlSessionInterceptor 的invoke方法 (代理对象的 InvocationHandler 就是 SqlSessionInterceptor，如果把它命名为SqlSessionInvocationHandler则更好理解！） 为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的? 此处则是关键, 进入该方法 SqlSession sqlSession = getSqlSession(SqlSessionTemplate.this.sqlSessionFactory, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator); 123456789101112131415161718192021222324252627public static SqlSession getSqlSession(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) &#123; notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED); notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED); // 进入 TransactionSynchronizationManager.getResource(...) 方法 // 根据sqlSessionFactory从当前线程对应的资源map中获取SqlSessionHolder， // 当sqlSessionFactory创建了sqlSession， // 就会在事务管理器中添加一对映射：key为sqlSessionFactory，value为SqlSessionHolder，该类保存sqlSession及执行方式 SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory); //从SqlSessionHolder中提取SqlSession对象 SqlSession session = sessionHolder(executorType, holder); if (session != null) &#123; return session; &#125; LOGGER.debug(() -&gt; &quot;Creating a new SqlSession&quot;); // 如果当前事物管理器中获取不到SqlSessionHolder对象就重新创建一个 session = sessionFactory.openSession(executorType); registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session); return session; &#125; 进入 TransactionSynchronizationManager.getResource(…) 方法 SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory); 123456789101112@Nullable public static Object getResource(Object key) &#123; Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key); // 这里 value 为返回结果, 可以进去看这个 value 是什么对象, 进入 doGetResource() 方法 Object value = doGetResource(actualKey); if (value != null &amp;&amp; logger.isTraceEnabled()) &#123; logger.trace(&quot;Retrieved value [&quot; + value + &quot;] for key [&quot; + actualKey + &quot;] bound to thread [&quot; + Thread.currentThread().getName() + &quot;]&quot;); &#125; return value; &#125; 这里 value 为返回结果, 可以进去看这个 value 是什么对象, 进入 doGetResource() 方法 Object value = doGetResource(actualKey); 1234567891011121314151617181920@Nullable private static Object doGetResource(Object actualKey) &#123; // 最后从 resources 这个集合中获取的对象, 然而这个 resources 就是一个 ThreadLocal 对象, 保证了线程安全 Map&lt;Object, Object&gt; map = (Map)resources.get(); if (map == null) &#123; return null; &#125; else &#123; Object value = map.get(actualKey); if (value instanceof ResourceHolder &amp;&amp; ((ResourceHolder)value).isVoid()) &#123; map.remove(actualKey); if (map.isEmpty()) &#123; resources.remove(); &#125; value = null; &#125; return value; &#125; &#125; 最后从 resources 这个集合中获取的对象, 然而这个 resources 就是一个 ThreadLocal 对象, 保证了线程安全 Map&lt;Object, Object&gt; map = (Map)resources.get(); 1234567public abstract class TransactionSynchronizationManager &#123; ...... private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = new NamedThreadLocal(&quot;Transactional resources&quot;); ......&#125; 5. Mybatis 不是有 SqlSessionManager 了吗？为什么又提供了 SqlSessionTemplate？ SqlSessionManager: SqlSessionManager 是由开发者自身决定如何使用 SqlSession 的, 是适合在不整合 Spring 框架的时候使用。 SqlSessionTemplate: SqlSessionTemplate 是 MyBatis 专门为 Spring 提供的，支持 Spring 框架的一个 SqlSession 获取接口。主要是为了继承 Spring，并同时将是否共用 SqlSession 的权限交给 Spring 去管理。","categories":[{"name":"摘抄笔记","slug":"摘抄笔记","permalink":"http://pdyun.cc/categories/%E6%91%98%E6%8A%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://pdyun.cc/tags/MyBatis/"}],"author":"Peilin Deng"},{"title":"Hello World","slug":"newpapername","date":"2021-08-06T05:06:24.000Z","updated":"2021-08-10T11:21:31.361Z","comments":true,"path":"2021/08/06/newpapername/","link":"","permalink":"http://pdyun.cc/2021/08/06/newpapername/","excerpt":"","text":"念两句诗 挑选中... jinrishici.load(function(result) { poem.innerHTML = result.data.content info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》' document.getElementById(\"poem\").value(poem); document.getElementById(\"info\").value(info); });","categories":[],"tags":[]}],"categories":[{"name":"摘抄笔记","slug":"摘抄笔记","permalink":"http://pdyun.cc/categories/%E6%91%98%E6%8A%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://pdyun.cc/tags/Spring/"},{"name":"访问家庭内网","slug":"访问家庭内网","permalink":"http://pdyun.cc/tags/%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E5%86%85%E7%BD%91/"},{"name":"动态DDNS","slug":"动态DDNS","permalink":"http://pdyun.cc/tags/%E5%8A%A8%E6%80%81DDNS/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://pdyun.cc/tags/MyBatis/"}]}