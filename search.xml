<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JMM 和 Happens-Before模型规则</title>
    <url>/2022/03/04/Lock-%E9%94%81%E5%8F%8A%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>下图所示，在不同的CPU架构中，为了避免因为指令重排序、或者缓存一致性问题，都提供了不同的内存屏障指令。同时，在不同的操作系统中，也都会实现封装一个内存屏障的实现。</p>
<p>那么，我们写的Java线程，如何能够在不同的硬件、不同操作系统下，仍然能够保证线程安全性呢？这就要引出JMM（Java 内存模型），它就是为了屏蔽操作系统和硬件的差异，让一套代码在不同平台下都能达到线程安全的访问目的。</p>
<p><img src="/images/img-150.png"></p>
<h1 id="一、什么是JMM"><a href="#一、什么是JMM" class="headerlink" title="一、什么是JMM"></a>一、什么是JMM</h1><p>那什么是JMM呢？</p>
<p>首先，我们都知道Java程序是运行在Java虚拟机上的，同时我们也知道，  JVM是一个跨语言跨平台的实 现，也就是Write Once、 Run Anywhere。</p>
<p>那么JVM如何实现在不同平台上都能达到线程安全的目的呢？所以这个时候JMM出来了， <strong>Java内存模型 （Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范</strong></p>
<p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中 保存了这个线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而 不能直接读写主内存。</p>
<p>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行，流程图如下：</p>
<p><img src="/images/img-151.png"></p>
<p>再总结一下： JMM定义了共享内存中多线程程序读写操作的行为规范：在虚拟机中把共享变量存储到内存以及从内存中取出共享变量的底层实现细节。</p>
<p>目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题</p>
<blockquote>
<p>本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p>
</blockquote>
<p>实际上，如果大家认真听了前面的内容，不难发现JMM的整个模型实际上和CPU高速缓存和内存交互的模型是一致的，因为不管软件怎么设计，最终还是由硬件来执行。而这个抽象模型的意义就在于，它可以针对不同平台来保证并发场景下的可见性问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::loadload</span><span class="params">()</span>   </span>&#123; <span class="built_in">acquire</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::storestore</span><span class="params">()</span> </span>&#123; <span class="built_in">release</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::loadstore</span><span class="params">()</span>  </span>&#123; <span class="built_in">acquire</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::storeload</span><span class="params">()</span>  </span>&#123; <span class="built_in">fence</span>(); &#125;</span><br></pre></td></tr></table></figure>
<p><strong>orderAccess_linux_x86.inline</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::fence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (os::<span class="built_in">is_MP</span>()) &#123;</span><br><span class="line">		<span class="comment">// always use locked addl since mfence is sometimes expensive</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">		<span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock; addl $0,0(%%rsp)&quot;</span> : : : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">		<span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock; addl $0,0(%%esp)&quot;</span> : : : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>orderAccess_linux_sparc.inline</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::fence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;membar  #StoreLoad&quot;</span> : : :)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>OrderAccess::storeload();</strong></p>
<p><strong>ACC_VOLATILE</strong></p>
<p><strong>bool is_volatile () const { return (_flags &amp; JVM_ACC_VOLATILE ) != 0; }</strong></p>
<h1 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h1><h2 id="可见性导致的原因"><a href="#可见性导致的原因" class="headerlink" title="可见性导致的原因"></a>可见性导致的原因</h2><ol>
<li><p>CPU的高速缓存</p>
</li>
<li><p>指令重排序</p>
</li>
</ol>
<blockquote>
<p>并不是所有的程序指令都会存在可见性或者指令重排序问题。</p>
</blockquote>
<h1 id="三、Happens-Before模型"><a href="#三、Happens-Before模型" class="headerlink" title="三、Happens-Before模型"></a>三、Happens-Before模型</h1><p>前面说了这么多，都是为了讲解清楚，到底是什么原因导致了在多线程环境下的可见性和有序性问题。</p>
<p>并且也了解了volatile解决可见性问题的本质。</p>
<p>那么有没有哪些情况是，不需要通过增加volatile关键字，也能保证在多线程环境下的可见性和有序性的呢？</p>
<p>从JDK1.5开始，引入了一个happens-before的概念来阐述多个线程操作共享变量的可见性问题。所以我们可以认为在JMM中，如果一个操作执行的结果需要对另一个操作课件，那么这两个操作必须要存在happens-before关系。这两个操作可以是同一个线程，也可以是不同的线程。</p>
<h2 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h2><p>一个线程中的每个操作，happens-before这个线程中的任意后续操作，可以简单认为是as-if-serial。</p>
<p>as-if-serial的意思是，不管怎么重排序，单线程的程序的执行结果不能改变。</p>
<ul>
<li>处理器不能对存在依赖关系的操作进行重排序，因为重排序会改变程序的执行结果。</li>
<li>对于没有依赖关系的指令，即便是重排序，也不会改变在单线程环境下的执行结果。</li>
</ul>
<p>具体来看下面这段代码，A和B允许重排序，但是C是不允许重排，因为存在依赖关系。根据as-if-serial语义，在单线程环境下， 不管怎么重排序，最终执行的结果都不会发生变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">2</span>; <span class="comment">//A </span></span><br><span class="line"><span class="keyword">int</span> b=<span class="number">2</span>; <span class="comment">//B </span></span><br><span class="line"><span class="keyword">int</span> c=a*b; <span class="comment">//C</span></span><br></pre></td></tr></table></figure>

<h2 id="传递性规则"><a href="#传递性规则" class="headerlink" title="传递性规则"></a>传递性规则</h2><p>仍然看下面这段代码，根据程序顺序规则可以知道，这三者之间存在一个happens-before关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">2</span>; <span class="comment">//A </span></span><br><span class="line"><span class="keyword">int</span> b=<span class="number">2</span>; <span class="comment">//B </span></span><br><span class="line"><span class="keyword">int</span> c=a*b; <span class="comment">//C</span></span><br></pre></td></tr></table></figure>

<ul>
<li>A happens-before B。</li>
<li>B happens-before C。</li>
<li>A happens-before C。</li>
</ul>
<p>这三个happens-before关系，就是根据happens-before的传递性推导出来的。很多同学这个时候又有疑惑了，不是说，A和B之间允许重排序吗？那是不是A happens-before B不一定存在，也可能是B可以重排序在A之前执行呢？</p>
<p>没错，确实是这样，JMM不要求A一定要在B之前执行，但是他要求的是前一个操作的执行结果对后一个操作可见。这里操作A的执行结果不需要对操作B可见，并且重排序操作A和操作B后的执行结果与A happens-before B顺序执行的结果一直，这种情况下，是允许重排序的。</p>
<h2 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h2><p>对于volatile修饰的变量的写操作，一定happens-before后续对于volatile变量的读操作，这个是因为volatile底层通过内存屏障机制防止了指令重排，这个规则前面已经分析得很透彻了，所以没什么问题，我们再来观察如下代码，基于前面两种规则再结合volatile规则来分析下面这个代码的执行顺序，</p>
<p>假设两个线程A和B，分别访问writer方法和reader方法，那么它将会出现以下可见性规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> Boolean flag=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a=<span class="number">1</span>;		<span class="comment">//1</span></span><br><span class="line">        flag=<span class="keyword">true</span>;	<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123; 		<span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i=a;	<span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>1 happens before 2、 3 happens before 4， 这个是程序顺序规则</li>
<li>2 happens before 3、 是由volatile规则产生的，对一个volatile变量的读，总能看到任意线程对这个volatile变量的写入。</li>
<li>1 happens before 4， 基于传递性规则以及volatile的内存屏障策略共同保证</li>
</ul>
<p>那么最终结论是，如果在线程B执行reader方法时，如果flag为true，那么意味着 i=1成立。</p>
<p><img src="/images/img-152.png"></p>
<blockquote>
<p>这里有同学可能会有疑问说，你前面讲的程序顺序规则中，在单线程中，如果两个指令之间不存在依赖关系，是允许重排序的，也就是1 和 2的顺序可以重排，那么是不是意味着最终4输出的结果是0呢?</p>
</blockquote>
<p>这里也是因为volatile修饰的重排序规则的存在，导致1和2是不允许重排序的，在volatile重排序规则表中，如果第一操作是普通变量的读/写，第二个操作是volatile的写，那么这两个操作之间不允许重排序</p>
<h3 id="volatile-重排序规则表"><a href="#volatile-重排序规则表" class="headerlink" title="volatile 重排序规则表"></a>volatile 重排序规则表</h3><p><img src="/images/img-153.png"></p>
<h2 id="监视器锁规则"><a href="#监视器锁规则" class="headerlink" title="监视器锁规则"></a>监视器锁规则</h2><p>一个线程对于一个锁的释放锁操作，一定happens-before与后续线程对这个锁的加锁操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 此处自动加锁</span></span><br><span class="line">    <span class="comment">// x 是共享变量 , 初始值 =10</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.x &lt; <span class="number">12</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处自动解锁</span></span><br></pre></td></tr></table></figure>

<p>假设x的初始值是10，线程A执行完代码块后，x的值会变成12，执行完成之后会释放锁。线程B进入代 码块时，能够看到线程A对x的写操作，也就是B线程能够看到x=12。</p>
<h2 id="start规则"><a href="#start规则" class="headerlink" title="start规则"></a>start规则</h2><p>如果线程A执行操作ThreadB.start(),那么线程A的ThreadB.start()之前的操作happens-before线程B中的任意操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> StartDemo&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="comment">// 主线程调用 t1.start() 之前</span></span><br><span class="line">        <span class="comment">// 所有对共享变量的修改，此处皆可见</span></span><br><span class="line">        <span class="comment">// 此例中，x==10</span></span><br><span class="line">    &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 此处对共享变量 x修改</span></span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 主线程启动子线程</span></span><br><span class="line">    t1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="join规则"><a href="#join规则" class="headerlink" title="join规则"></a>join规则</h2><p>join规则，如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于 线程A从ThreadB.join()操作成功的返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="comment">// 此处对共享变量 x 修改</span></span><br><span class="line">    x= <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 例如此处对共享变量修改，</span></span><br><span class="line"><span class="comment">// 则这个修改结果对线程 t1 可见</span></span><br><span class="line"><span class="comment">// 主线程启动子线程</span></span><br><span class="line">t1.start();</span><br><span class="line">t1.join()</span><br><span class="line"><span class="comment">// 子线程所有对共享变量的修改</span></span><br><span class="line"><span class="comment">// 在主线程调用 t1.join() 之后皆可见</span></span><br><span class="line"><span class="comment">// 此例中，x==100</span></span><br></pre></td></tr></table></figure>

<h1 id="四、DCL问题"><a href="#四、DCL问题" class="headerlink" title="四、DCL问题"></a>四、DCL问题</h1><p>//instance=new DCLExample();</p>
<ul>
<li>为对象分配内存</li>
<li>初始化对象</li>
<li>把内存空间的地址复制给对象的引用</li>
</ul>
<p>指令重排序后</p>
<ul>
<li>为对象分配内存</li>
<li>把内存空间的地址复制给对象的引用</li>
<li>初始化对象(还没有执行的时候。</li>
</ul>
<p>造成不完整对象</p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 插件的执行顺序</title>
    <url>/2021/08/20/MyBatis-%E6%8F%92%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="多个插件执行顺序"><a href="#多个插件执行顺序" class="headerlink" title="多个插件执行顺序 "></a>多个插件执行顺序 </h2><h6 id="本文转载自-https-zhuanlan-zhihu-com-p-266735787"><a href="#本文转载自-https-zhuanlan-zhihu-com-p-266735787" class="headerlink" title="本文转载自 https://zhuanlan.zhihu.com/p/266735787"></a>本文转载自 <a href="https://zhuanlan.zhihu.com/p/266735787">https://zhuanlan.zhihu.com/p/266735787</a></h6><h6 id="在-mybatis-中允许针对-SQL-在执行前后进行扩展操作，而这些扩展操作也叫做插件。允许用插件来拦截的方法包括："><a href="#在-mybatis-中允许针对-SQL-在执行前后进行扩展操作，而这些扩展操作也叫做插件。允许用插件来拦截的方法包括：" class="headerlink" title="在 mybatis 中允许针对 SQL 在执行前后进行扩展操作，而这些扩展操作也叫做插件。允许用插件来拦截的方法包括："></a>在 mybatis 中允许针对 SQL 在执行前后进行扩展操作，而这些扩展操作也叫做插件。<br>允许用插件来拦截的方法包括：</h6><blockquote>
<p>MyBatis 默认支持对<strong>4大对象</strong>（<strong>Executor，StatementHandler，ParameterHandler，ResultSetHandler</strong>）上的方法执行拦截，具体支持的方法为：</p>
<ul>
<li><strong>Executor</strong> (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)，主要用于sql重写。</li>
<li><strong>ParameterHandler</strong> (getParameterObject, setParameters)，用于参数处理。</li>
<li><strong>ResultSetHandler</strong> (handleResultSets, handleOutputParameters)，用于结果集二次处理。</li>
<li><strong>StatementHandler</strong> (prepare, parameterize, batch, update, query)，用于jdbc层的控制。</li>
</ul>
<p>通过插件可以实现 SQL 打印，分页插件等功能。<br><br>这时候就会延伸出一个问题：如果存在多个插件，这些插件的执行顺序是怎样的？</p>
</blockquote>
<h3 id="一、插件的执行顺序"><a href="#一、插件的执行顺序" class="headerlink" title="一、插件的执行顺序"></a>一、插件的执行顺序</h3><h6 id="插件执行顺序一共有两种"><a href="#插件执行顺序一共有两种" class="headerlink" title="插件执行顺序一共有两种"></a>插件执行顺序一共有两种</h6><h4 id="1、不同拦截对象的执行顺序"><a href="#1、不同拦截对象的执行顺序" class="headerlink" title="1、不同拦截对象的执行顺序"></a>1、不同拦截对象的执行顺序</h4><blockquote>
<p>Mybatis 针对以上这四种对象的拦截的执行顺序是固定的，因为 Mybatis代码的执行流程是固定的。<br><br>以 <strong>SimpleExecutor</strong>#query 来说，这四种对象的执行代码如下：<br><br><img src="/images/img-71.png"></p>
</blockquote>
<blockquote>
<p>通过源码知道，执行顺序为：<br><br><strong>Executor<code>-&gt;</code>StatementHandler<code>-&gt;</code>ParameterHandler<code>-&gt;</code>StatementHandler<code>-&gt;</code>ResultSetHandler</strong></p>
<p>虽然中间 StatementHandler 执行了多次，但是总的来说，执行顺序优先级从高到低为：<br><br><strong>Executor<code>-&gt;</code>StatementHandler<code>-&gt;</code>ParameterHandler<code>-&gt;</code>ResultSetHandler</strong></p>
</blockquote>
<h4 id="2、同种拦截对象的执行顺序"><a href="#2、同种拦截对象的执行顺序" class="headerlink" title="2、同种拦截对象的执行顺序"></a>2、同种拦截对象的执行顺序</h4><h6 id="针对同种对象如果存在多种拦截器对象，其拦截顺序如何？"><a href="#针对同种对象如果存在多种拦截器对象，其拦截顺序如何？" class="headerlink" title="针对同种对象如果存在多种拦截器对象，其拦截顺序如何？"></a>针对同种对象如果存在多种拦截器对象，其拦截顺序如何？</h6><blockquote>
<p>首先在前面，知道了插件功能的实现是通过代理的方式对原有的如：Executor、ParameterHandler 等进行了代理增强，而经过代理后的原有的 Executor 、ParameterHandler 等对象会以如下方式存在：<br><img src="/images/img-72.png"></p>
<p>如图，存在多个拦截器都是先进后出，针对代理模式来说来说，可以对被代理的原始对象的处理前后进行代码增强操作。</p>
<p>而那个拦截器优先执行，取决于在生成代理对象时的顺序，也就是包裹在最外层的插件（拦截器）优先执行。</p>
<p>来回顾一下代理对象生成时的逻辑然后结合mybatis-config.xml 配置文件的关于 <plugins> 的配置信息，即可知道相关的执行顺序。</p>
</blockquote>
<h6 id="来看代理生成代码-InterceptorChain-pluginAll，如下："><a href="#来看代理生成代码-InterceptorChain-pluginAll，如下：" class="headerlink" title="来看代理生成代码 InterceptorChain#pluginAll，如下："></a>来看代理生成代码 InterceptorChain#pluginAll，如下：</h6><blockquote>
<p><img src="/images/img-73.png"><br>如上述代码所示，通过遍历 interceptors List 列表对 target 对象进行包装（target 可以是 Executor or ParameterHandler等）。</p>
<p>也就是在 List 列表的最开始的 interceptor 插件最先被包裹在 target 对象外层，也就是如下图所示：<br><img src="/images/img-74.png" alt="upload successful"></p>
<p>如上图所示，在配置文件中越靠前的插件配置，在 interceptors List 列表中的位置自然越靠前，其执行顺序自然越靠后。</p>
</blockquote>
<h4 id="总结：同个对象的多个拦截器执行顺序根据配置文件-mybatis-config-xml-插件配置顺序有关，配置越靠前，执行顺序越靠后"><a href="#总结：同个对象的多个拦截器执行顺序根据配置文件-mybatis-config-xml-插件配置顺序有关，配置越靠前，执行顺序越靠后" class="headerlink" title="总结：同个对象的多个拦截器执行顺序根据配置文件 mybatis-config.xml 插件配置顺序有关，配置越靠前，执行顺序越靠后"></a>总结：同个对象的多个拦截器执行顺序根据配置文件 mybatis-config.xml 插件配置顺序有关，配置越靠前，执行顺序越靠后</h4>]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 运行时序图</title>
    <url>/2021/08/20/MyBatis-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%8F%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="架构分层"><a href="#架构分层" class="headerlink" title="架构分层"></a>架构分层</h3><p><img src="/images/pasted-4.png" alt="架构分层"></p>
<span id="more"></span>

<h4 id="1-创建会话工厂类"><a href="#1-创建会话工厂类" class="headerlink" title="1. 创建会话工厂类"></a>1. 创建会话工厂类</h4><p><img src="/images/pasted-5.png" alt="创建会话过程"></p>
<h4 id="2-创建会话"><a href="#2-创建会话" class="headerlink" title="2. 创建会话"></a>2. 创建会话</h4><p><img src="/images/pasted-6.png" alt="创建会话过程"></p>
<h4 id="3-获取代理对象"><a href="#3-获取代理对象" class="headerlink" title="3. 获取代理对象"></a>3. 获取代理对象</h4><p><img src="/images/pasted-7.png" alt="获取代理对象过程"></p>
<h4 id="4-调用代理对象方法-执行SQL"><a href="#4-调用代理对象方法-执行SQL" class="headerlink" title="4. 调用代理对象方法, 执行SQL"></a>4. 调用代理对象方法, 执行SQL</h4><p><img src="/images/pasted-8.png" alt="调用代理对象方法, 执行SQL过程"></p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql 8.0新特性</title>
    <url>/2021/08/23/MySQL8-0%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="MySql-8-0新特性"><a href="#MySql-8-0新特性" class="headerlink" title="MySql 8.0新特性"></a><strong>MySql 8.0新特性</strong></h1><p>MySQL从5.7一跃直接到8.0，这其中的缘由，咱就不关心那么多了，有兴趣的朋友自行百度，本次的版本更新，在功能上主要有以下6点：</p>
<p>　　<strong>账户与安全</strong></p>
<p>　　<strong>优化器索引</strong></p>
<p>　　<strong>通用表表达式</strong></p>
<p>　　<strong>窗口函数</strong></p>
<p>　　<strong>InnoDB 增强</strong></p>
<p>　　<strong>JSON 增强</strong></p>
<span id="more"></span>

<h3 id="一、账户与安全"><a href="#一、账户与安全" class="headerlink" title="一、账户与安全"></a><strong>一、账户与安全</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.用户的创建与授权</span><br><span class="line"></span><br><span class="line">　　在MySQL5.7的版本：</span><br><span class="line"></span><br><span class="line">　　&gt; grant all privileges on *.* to &#x27;用户名&#x27;@&#x27;主机&#x27; identified by &#x27;密码&#x27;；</span><br><span class="line"></span><br><span class="line">　　在MySQL8.0需要分开执行：</span><br><span class="line"></span><br><span class="line">　　&gt;create user &#x27;用户名&#x27;@&#x27;主机&#x27; identified by &#x27;密码&#x27;；</span><br><span class="line"></span><br><span class="line">　　&gt;grant all privileges on *.* to &#x27;用户名&#x27;@&#x27;主机&#x27;；</span><br><span class="line"></span><br><span class="line">　　用以前的一条命令在8.0里面创建用户，会出现sql语法错误</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.认证插件更新</span><br><span class="line"></span><br><span class="line">　　MySQL5.7默认身份插件是mysql_native_password</span><br><span class="line"></span><br><span class="line">　　MySQL8.0默认的身份插件是caching_sha2_password</span><br><span class="line">　　查看身份认证插件命令：show variables like &#x27;default_authentication_plugin%&#x27;;</span><br><span class="line">　　身份认证插件可以通过以下2中方式改变：</span><br><span class="line">　　</span><br><span class="line">　　1）系统变量default_authentication_plugin去改变，在my.ini文件的[mysqld]下面设置default_authentication_plugin=mysql_native_password即可</span><br><span class="line"></span><br><span class="line">　　2）如果希望只是某一个用户通过mysql_native_password的方式认证，可以修改数据库mysql下面的user表的字段，执行以下命令：</span><br><span class="line"></span><br><span class="line">　　&gt;alter user &#x27;用户名&#x27;@&#x27;主机&#x27; identified width mysql_native_password by &#x27;密码&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.密码管理</span><br><span class="line"></span><br><span class="line">　　MySQL8.0的密码管理策略有3个变量</span><br><span class="line"></span><br><span class="line">　　password_history 修改密码不允许与最近几次使用或的密码重复，默认是0，即不限制</span><br><span class="line">　　</span><br><span class="line">　　password_reuse_interval 修改密码不允许与最近多少天的使用过的密码重复，默认是0,即不限制</span><br><span class="line">　　password_require_current 修改密码是否需要提供当前的登录密码，默认是OFF,即不需要；如果需要，则设置成ON</span><br><span class="line"></span><br><span class="line">　　查询当前MySQL密码管理策略相关变量，使用以下命令：</span><br><span class="line">　　</span><br><span class="line">　　&gt;show variables like &#x27;password%&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">　　1)设置全局的密码管理策略，在my.ini配置文件中，设置以上3个变量的值这种设置方式，需要重启mysql服务器；某些生产环境不允许重启，MySQL8.0提供了关键字persist,持久化，执行以下命令：</span><br><span class="line"></span><br><span class="line">　　&gt;set persist password_history=6;</span><br><span class="line"></span><br><span class="line">　　这条命令会在数据目录下生成新的配置文件（/var/lib/mysql/mysqld-auto.cnf），下次服务器重启的时候除了读取全局配置文件，还会读取这个配置文件,这条配置就会被读入从而达到持久化的目的</span><br><span class="line">　　2)针对某一个用户单独设置密码管理策略</span><br><span class="line"></span><br><span class="line">　　&gt;alter user &#x27;用户名&#x27;@&#x27;主机&#x27; password history 5;</span><br><span class="line"></span><br><span class="line">　　这样，这个用户的password_history 就被设置成了5,查看一下：</span><br><span class="line"></span><br><span class="line">　　&gt;show user,host,Password_reuse_history from user;</span><br><span class="line">　　</span><br><span class="line">　　查看某一张的字段的所有字段，使用以下命令:</span><br><span class="line"></span><br><span class="line">　　&gt;desc 表名;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.角色管理</span><br><span class="line">　　</span><br><span class="line">　　角色：一组权限的集合</span><br><span class="line">　　</span><br><span class="line">　　一组权限赋予某个角色，再把某个角色赋予某个用户，那用户就拥有角色对应的权限</span><br><span class="line">　　</span><br><span class="line">　　1)创建一个角色</span><br><span class="line">　　&gt;create role &#x27;角色1&#x27;;</span><br><span class="line">　　</span><br><span class="line">　　2)为这个角色赋予相应权限</span><br><span class="line">　　&gt;grant insert,update on *.* to &#x27;角色1&#x27;;</span><br><span class="line">　　</span><br><span class="line">　　3)创建一个用户</span><br><span class="line">　　&gt;create user &#x27;用户1&#x27; identified by &#x27;用户1的密码&#x27;;</span><br><span class="line">　　</span><br><span class="line">　　4)为这个用户赋予角色的权限</span><br><span class="line">　　&gt;grant &#x27;角色1&#x27; on *.* to &#x27;用户1&#x27;；</span><br><span class="line"></span><br><span class="line">　　执行完上面4步，用户1就拥有了插入与更新的权限</span><br><span class="line">　　</span><br><span class="line">　　5)再创建1个用户</span><br><span class="line">　　&gt;create user &#x27;用户2&#x27; identified by &#x27;用户2的密码&#x27;;</span><br><span class="line">　　</span><br><span class="line">　　6)为这个用户赋予同样的角色</span><br><span class="line">　　&gt;grant &#x27;角色1&#x27; on *.* to &#x27;用户2&#x27;;</span><br><span class="line">　　</span><br><span class="line">　　执行完上面2步，用户2也用了角色1的权限，即插入与更新</span><br><span class="line"></span><br><span class="line">　　查看用户权限，执行以下命令：</span><br><span class="line">　　&gt;show grants for &#x27;用户名&#x27;;</span><br><span class="line"></span><br><span class="line">　　7)启用角色,设置了角色，如果不启用，用户登录的时候，依旧没有该角色的权限</span><br><span class="line">　　&gt;set default role &#x27;角色名&#x27; to &#x27;用户名&#x27;;</span><br><span class="line"></span><br><span class="line">　　8)如果一个用户有多个角色，使用以下命令</span><br><span class="line">　　&gt;set default role all to &#x27;用户名&#x27;;</span><br><span class="line"></span><br><span class="line">　　MySQL中与用户角色相关的表：mysql.default_roles、mysql.role_edges,有兴趣的朋友可以进去查看下。</span><br><span class="line"></span><br><span class="line">　　9)撤销权限</span><br><span class="line">　　&gt;revoke insert,update on *.* from &#x27;角色名&#x27;;</span><br></pre></td></tr></table></figure>



<h3 id="二、优化器索引"><a href="#二、优化器索引" class="headerlink" title="二、优化器索引"></a><strong>二、优化器索引</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.隐藏索引（invisible index）</span><br><span class="line"></span><br><span class="line">　　隐藏索引不会被优化器使用，但仍需要维护</span><br><span class="line"></span><br><span class="line">　　应用场景：</span><br><span class="line"></span><br><span class="line">　　1）软删除</span><br><span class="line"></span><br><span class="line">　　　　删除索引，在线上，如果删除错了索引，只能通过创建索引的方式将其添加回来，对于一些大的数据库而言，是比较耗性能的；为了避免删错，可以先将其设置为不可见，优化器这时候就不会使用它，但是后台仍然在维护，确定后，再删除。</span><br><span class="line"></span><br><span class="line">　　2）灰度发布</span><br><span class="line"></span><br><span class="line">　　　　与软删除差不多，如果想要测试一些索引的功能或者随后可能会使用到这个索引，可以先将其设置为隐藏索引，对于现有的查询不会产生影响，测试后，确定需要该索引，可以将其设置成可见索引。</span><br><span class="line"></span><br><span class="line">　　创建隐藏索引，执行如下命令（如果是不隐藏，则不需要后面的invisible关键字）：</span><br><span class="line"></span><br><span class="line">　　&gt;create index 索引名称 on 表名(字段名) invisible;</span><br><span class="line"></span><br><span class="line">　　查询某一张表的索引，执行如下命令：</span><br><span class="line"></span><br><span class="line">　　&gt;show index from 表名；</span><br><span class="line"></span><br><span class="line">　　使用explain语句查看查询优化器对索引的使用情况</span><br><span class="line"></span><br><span class="line">　　&gt;explain select * from 表名 where 条件;</span><br><span class="line"></span><br><span class="line">　　查询优化器有很多开关，有一个是use_invisible_indexes(是否使用隐藏索引),默认是off(不适用)，将其设置成on,即可使用隐藏索引。查看当前查询优化器的所有开关变脸，执行如下命令：</span><br><span class="line"></span><br><span class="line">　　&gt;select @@optimizer_switch;</span><br><span class="line"></span><br><span class="line">　　设置已经存在的索引为可见或者隐藏，执行如下命令：</span><br><span class="line"></span><br><span class="line">　　&gt;alter table 表名 alter index 索引名 visible;</span><br><span class="line"></span><br><span class="line">　　&gt;alter table 表名 alter index 索引名 invisible;</span><br></pre></td></tr></table></figure>

<p><strong>主键不可以设置为隐藏索引。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.降序索引（descending index）</span><br><span class="line"></span><br><span class="line">　　MySQL8.0开始真正支持降序索引，只有InnoDB引擎支持降序所以，且必须是BTREE降序索引，MySQL8.0不在对group by操作进行隐式排序。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.函数索引</span><br><span class="line"></span><br><span class="line">　　索引中使用函数表达式</span><br><span class="line">　　</span><br><span class="line">　　支持JSON数据节点的索引</span><br><span class="line"></span><br><span class="line">　　函数索引是基于虚拟列的功能实现的</span><br><span class="line"></span><br><span class="line">假设用户表（tb_user）的的用户登录账号(username)不需要区分大小写，则可以创建一个函数索引</span><br><span class="line"></span><br><span class="line">&gt;create index username_upper_index on tb_user((upper(username)));</span><br><span class="line">这样在查询的时候 SELECT * FROM tb_user WHERE upper(username) = &#x27;ABD123DSJ&#x27;; 就会使用索引。</span><br><span class="line"></span><br><span class="line">上面的函数索引，也可以通过MySQL5.7已有的虚拟计算列来模拟，为用户表（tb_user）创建新的一列（new_column）,这一列是计算列，不需要赋值，它的值就是username的大写。</span><br><span class="line"></span><br><span class="line">&gt;alter tbale tb_user add column new_column varchar(10) generated always as (upper(username));</span><br><span class="line"></span><br><span class="line">然后给new_column创建一个索引，可以达到模拟MySQL8.0中的函数索引的效果。</span><br></pre></td></tr></table></figure>



<h3 id="三、通用表表达式"><a href="#三、通用表表达式" class="headerlink" title="三、通用表表达式"></a><strong>三、通用表表达式</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.非递归 CTE</span><br><span class="line"></span><br><span class="line">　　派生表：select * from (select 1) as dt;</span><br><span class="line"></span><br><span class="line">　　通用表表达式：with cte as (select 1) select * from cte;</span><br><span class="line">　　</span><br><span class="line">　　　　　　　　　with cte1(id) as (select 1),cte2 as (select id+1 from cte1) select * from cte1 join cte2;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.递归 CTE</span><br></pre></td></tr></table></figure>



<h3 id="四、窗口函数"><a href="#四、窗口函数" class="headerlink" title="四、窗口函数"></a><strong>四、窗口函数</strong></h3><h3 id="五、InnoDB增强"><a href="#五、InnoDB增强" class="headerlink" title="五、InnoDB增强"></a><strong>五、InnoDB增强</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.集成数据字段</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.原子ddl操作</span><br><span class="line"></span><br><span class="line">　　MySQL5.7执行drop命令 drop table t1,t2; 如果t1存在，t2不存在，会提示t2表不存在，但是t1表仍然会被删除。</span><br><span class="line"></span><br><span class="line">　　MySQL8.0执行同样的drop命令，会提示t2表不存在，而且t1表不会被删除，保证了原子性。</span><br><span class="line"></span><br><span class="line">　　ddl操作（针对表）的原子性前提是该表使用的存储引擎是InnoDB</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.自增列持久化</span><br><span class="line"></span><br><span class="line">　　解决了之前的版本，主键重复的问题。</span><br><span class="line"></span><br><span class="line">　　MySQL5.7及其以前的版本，MySQL服务器重启，会重新扫描表的主键最大值，如果之前已经删除过id=100的数据，但是表中当前记录的最大值如果是99，那么经过扫描，下一条记录的id是100，而不是101。</span><br><span class="line">　　</span><br><span class="line">　　MySQL8.0则是每次在变化的时候，都会将自增计数器的最大值写入redo log,同时在每次检查点将其写入引擎私有的系统表。则不会出现自增主键重复的问题。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.死锁检查控制</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5.锁定语句选项</span><br></pre></td></tr></table></figure>



<h3 id="六、JSON增强"><a href="#六、JSON增强" class="headerlink" title="六、JSON增强"></a><strong>六、JSON增强</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.内联路径操作符 </span><br><span class="line">　　</span><br><span class="line">column-&gt;&gt;path</span><br><span class="line"></span><br><span class="line">等价于之前的：</span><br><span class="line"></span><br><span class="line">JSON_UNQUOTE(column -&gt; path)</span><br><span class="line"></span><br><span class="line">JSON_UNQUOTE(JSON_EXTRACT(column,path))</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.JSON聚合函数</span><br><span class="line"></span><br><span class="line">MySQL8.0和MySQL5.7.22增加了2个聚合函数</span><br></pre></td></tr></table></figure>
<p>  <img src="/images/img-26.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1)JSON_ARRAYAGG(),将多行数据组合成json数组</span><br><span class="line">	示例：select o_id,json_arrayagg(attribute) as attributes from t group by o_id;</span><br></pre></td></tr></table></figure>
<p>  <img src="/images/img-28.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2)JSON_OBJECTAGG()，用于生成json对象</span><br><span class="line">	示例：select o_id json_objectagg(attribute,value) as attributes from t group by o_id;  </span><br></pre></td></tr></table></figure>
<p>  <img src="/images/img-29.png"></p>
<p>　　注意：json的聚合函数针对重复key,会使用最后的覆盖前面已有的值，如果下面的o_id=3，它的color有2个值，一个green,一个yellow,使用生成json的聚合函数的时候，前面的green会被覆盖掉。<br>  <img src="/images/img-30.png">  </p>
<p>  <img src="/images/img-31.png">  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.JSON实用函数</span><br><span class="line"></span><br><span class="line">　　1)JSON_PRETTY()  输出json数据的时候，格式化。</span><br><span class="line"></span><br><span class="line">　　select json_object(&#x27;id&#x27;,3,&#x27;name&#x27;,&#x27;Barney&#x27;);</span><br></pre></td></tr></table></figure>
<p>  <img src="/images/img-32.png"></p>
<p>　　</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　select json_pretty(json_object(&#x27;id&#x27;,3,&#x27;name&#x27;,&#x27;Barney&#x27;));</span><br></pre></td></tr></table></figure>
<p>  <img src="/images/img-33.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　2)JSON_STORAGE_SIZE() json数据所占用的存储空间（单位：字节）</span><br><span class="line"></span><br><span class="line">　　3)JSON_STORAGE_FREE() json数据更新后所释放的空间（单位：字节）</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.JSON合并函数</span><br><span class="line"></span><br><span class="line">MySQL8.0废弃了JSON_MERGE()函数，推荐使用以下两个函数合并JSON数据</span><br><span class="line"></span><br><span class="line">　　1)JSON_MERGE_PATCH()</span><br><span class="line"></span><br><span class="line">　　2)JSON_MERGE_PRESERV()</span><br><span class="line"></span><br><span class="line">上面两个函数都是JSON数据合并，最大的区别就是前者遇到相同key的时候会用后面的覆盖前面的，后者会都保留，看下面的截图：</span><br></pre></td></tr></table></figure>
<p>  <img src="/images/img-34.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5.JSON表函数</span><br><span class="line">　　</span><br><span class="line">　　MySQL8.0新增了JSON_TABLE()函数，将JSON数据转换成关系表，可以将该函数的返回结果当做一个普通的临时表进行sql查询。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql MVCC机制</title>
    <url>/2021/08/25/MySql-MVCC%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>MVCC：Multi-Version Concurrent Control，多版本并发控制。</p>
</blockquote>
<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><ol>
<li>当多个线程执行事务的时候，对同一个缓存页里的一行数据进行更新。这个冲突如何处理</li>
<li>当一个事务更新一条数据时，另一个事务在查询这条数据。</li>
</ol>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="脏写-amp-脏读"><a href="#脏写-amp-脏读" class="headerlink" title="脏写&amp;脏读"></a>脏写&amp;脏读</h2><p>因为一个事务去更新或者查询了另一个没有提交的事务更新过去的数据。因为另一个事务还没提交，所以随时可能回滚。导致自己更新的数据或者查询的数据没了。</p>
<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>在一个事务开始之后，多次读取同一条数据的结果因为其他事务修改的提交，显示为多次读取到不同的值。</p>
<h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><span id="more"></span>
<p>在一个是事务开始后，多次读取一组数据的结果因为其他事务的新增或者删除的提交，显示为新增了数据或者减少了数据。</p>
<h1 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h1><h2 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h2><p>read uncommitted<br>能够解决脏写，因为一个事务对同一条数据进行操作时（更新，删除），其他对该条数据的操作的事务将会卡住。当第一个事务提交后第二个事务才会执行。否则第二个事务等待一段时间后报错。一般没人用这个。  <br><img src="/images/img-42.png"><br><img src="/images/img-43.png"></p>
<h2 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h2><p>read committed<br>能够解决脏读和脏写，只会读取到其他事物已经提交的数据。ORACLE的默认隔离级别</p>
<h2 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h2><p>repeatable read<br>能够解决脏读，脏写和不可重复读。但是会出现幻读。事务一旦开始，多次查询一个值，会一直读取到同一个值。<em>MYSQL的默认隔离级别，MYSQL中RR级别不存在幻读。</em></p>
<h2 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h2><p>serializable<br>基本解决以上所有问题，因为事务是串行进行，不存在并发的情况。</p>
<h2 id="隔离级别的修改"><a href="#隔离级别的修改" class="headerlink" title="隔离级别的修改"></a>隔离级别的修改</h2><p>set [global | session] transaction_isolation level xxx<br>xxx：REPEATABLE READ，READ COMMITTED，READ UNCOMMITTED，SERIALIZABLE</p>
<h1 id="基于undo多版本链表实现的ReadView机制"><a href="#基于undo多版本链表实现的ReadView机制" class="headerlink" title="基于undo多版本链表实现的ReadView机制"></a>基于undo多版本链表实现的ReadView机制</h1><p><font color="red">在MYSQL中，事务的ID是自增的，这是一个重点！！！</font><br>在执行一个事务的时候，会生成一个ReadView，其中包括了以下4个（不仅仅是4个）关键内容：</p>
<ul>
<li>m_ids：在生成readview时，当前系统中==活跃的读写事务==的事务id列表【当前事务（新建事务）与正在内存中commit的事务不在活跃事务列表中】</li>
<li>min_trx_id：表示在生成readview时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值</li>
<li>max_trx_id：生成readview时系统中==应该分配给下一个事务的id值==</li>
<li>creator_trx_id：生成readview的事务的事务id<br>通过这些信息，在Readview生成后，当前事务更新的数据可以被自身读到，或者是在Readview生成前提交的事务修改的值，也是可以读到的。但是在生成ReadView的时候就已经活跃的事务，或者是ReadView生成后再开启的事务，修改的数据也是读不到的。</li>
</ul>
<h2 id="举个栗子（RR）"><a href="#举个栗子（RR）" class="headerlink" title="举个栗子（RR）"></a>举个栗子（RR）</h2><ol start="0">
<li><p>数据库中存在一条数据，事务id是32，是初始值。  <br><img src="/images/img-44.png"></p>
</li>
<li><p>事务A（trx=36）和事务B（trx=39）同时开启，事务A查询，事务B更新。<br><img src="/images/img-46.png"></p>
</li>
<li><p>事务A根据min_trx=36&gt;trx_id=32，知道这个数据在事务开启前就已经提交过了。所以可以查询到该条数据。<br>事务B同理也能查询到，然后事务B把值改成了值B。<br><img src="/images/img-47.png"></p>
</li>
<li><p>事务A再次查询的时候，此时数据中的trx_id=39处于[min_trx_id,max_trx_id]，说明更新数据的事务是和自己差不多同时开启的，并且trx_id=39∈[36,39]。所以就不能查询这条数据了</p>
</li>
<li><p>虽然事务A不能查询trx_id=39这条数据，但是可以顺着roll_ptr找下去，能找到最近的一条trx_id=32&lt;36的数据。说明这一个undo log版本是在事务A开启之前就提交过的。所以查询得到的是原始值。<br><img src="/images/img-48.png"></p>
</li>
<li><p>如果此时事务A更新该数据为值A，trx_id修改为36，同时保存之前事务B修改的值的快照，如下图<br><img src="/images/img-49.png"></p>
</li>
<li><p>当事务A来查询数据时，发现trx_id=45刚好和自己Read_View中的creator_trx_id一致，说明数据是自己修改的，自己可以直接读取到。</p>
</li>
<li><p>当事务C来进行一次更新操作后。事务A再去读取，发现trx_id=41&gt;max_trx_id，说明在自己开启事务后有一个事务去更新了这笔数据，自己也不能去查询。然后顺着roll_ptr刚好找到一个trx_id=36的undo日志，说明是自己修改过的，直接拿到了值A<br><img src="/images/img-50.png"></p>
</li>
</ol>
<h2 id="READ-COMMITTED是如何基于READ-VIEW实现的"><a href="#READ-COMMITTED是如何基于READ-VIEW实现的" class="headerlink" title="READ COMMITTED是如何基于READ VIEW实现的"></a>READ COMMITTED是如何基于READ VIEW实现的</h2><p>核心点在于：每次发起的查询，都生成一个新的Read View<br>上面的例子中，第2步事务B提交后，事务A查询时，创建新的Read View，此时活跃的事务就只有事务A（trx_id=36）了，查询到的数据trx_id=39，在min_trx_id和max_trx_id这个区间内，并且不在m_ids列表中，说明已经提交了，所以可以读取到这个值。    <br><img src="/images/img-51.png"></p>
<h2 id="REPEATABLE-READ是如何基于READ-VIEW实现的"><a href="#REPEATABLE-READ是如何基于READ-VIEW实现的" class="headerlink" title="REPEATABLE READ是如何基于READ VIEW实现的"></a>REPEATABLE READ是如何基于READ VIEW实现的</h2><p>核心点在于：每次发起的查询，使用的Read View仍然是第一次SELECT生成的。所以即便其他的事务提交了，m_ids中的内容也不会发生变化。    </p>
<h2 id="RR如何基于READ-VIEW解决幻读"><a href="#RR如何基于READ-VIEW解决幻读" class="headerlink" title="RR如何基于READ VIEW解决幻读"></a>RR如何基于READ VIEW解决幻读</h2><p>在事务A开启后，进行了一次范围查询；之后事务C插入了符合范围查询的数据，但是这些数据的DB_TRX_ID是事务C的ID，因为Read View只会创建一次，事务C大于事务A的ReadView中的max_trx_id，所以事务A的再次查询是获取不到新增的数据的。</p>
<p>A57</p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql Redolog（重做日志）</title>
    <url>/2021/08/25/MySql-Redolog%EF%BC%88%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>在执行增删改操作的时候，是基于Buffer Pool中的缓存页中的数据的。更新了缓存页中的数据后，会写入一条数据到Redo Log中。在提交事务的时候，会立马把Redo Log刷入磁盘（推荐方式），然后在RedoLog中写入binlog信息和一个commit标记，事务至此提交完毕。</p>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="RedoLog保障了什么"><a href="#RedoLog保障了什么" class="headerlink" title="RedoLog保障了什么"></a>RedoLog保障了什么</h2><p>当更新了缓存中的数据页后，缓存页还没有刷到磁盘上。MYSQL宕机，那么MYSQL重启后，会直接读取RedoLog中的内容，重做到Buffer Pool中，然后在刷到磁盘。因为RedoLog是顺序读写，所以效率很高。并且为了保证数据的不丢失，RedoLog也要设置成不经过OS Cache。</p>
<h2 id="为什么要写入RedoLog，直接刷到磁盘的缺点在哪里？"><a href="#为什么要写入RedoLog，直接刷到磁盘的缺点在哪里？" class="headerlink" title="为什么要写入RedoLog，直接刷到磁盘的缺点在哪里？"></a>为什么要写入RedoLog，直接刷到磁盘的缺点在哪里？</h2><ol>
<li>一个缓存页是16KB，刷盘比较耗时。而且你可能只修改了几个字节的数据。</li>
<li>缓存页刷入磁盘是随机读写。效率很低。而RedoLog是顺序读写，效率高</li>
</ol>
<span id="more"></span>

<h1 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h1><h2 id="RedoLog的类型"><a href="#RedoLog的类型" class="headerlink" title="RedoLog的类型"></a>RedoLog的类型</h2><p>根据数据页修改的字节数划分了不同的类型    </p>
<ul>
<li>MLOG_1BYTE：修改了1个字节</li>
<li>MLOG_2BYTE：修改了2个字节</li>
<li>MLOG_4BYTE：修改了4个字节</li>
<li>MLOG_WRITE_STRING：修改了一大串的值</li>
</ul>
<h2 id="RedoLog的大致内容"><a href="#RedoLog的大致内容" class="headerlink" title="RedoLog的大致内容"></a>RedoLog的大致内容</h2><p>MLOG_NBYTE，表空间ID，数据页号，数据页中的偏移量，具体修改的值<br>MLOG_WRITE_STRING，表空间ID，数据页号，数据页中的偏移量，修改的长度，具体修改的值</p>
<h2 id="RedoLog-Block"><a href="#RedoLog-Block" class="headerlink" title="RedoLog Block"></a>RedoLog Block</h2><p>RedoLog中，包含着多个RedoLog Block。每个RedoLog大小是512KB；<br>在写入Redolog之前先写入内存中的RedoLog Block，然后再把RedoLog Block写入磁盘文件。具体的结构见图。    <br><img src="/images/img-40.png"></p>
<h2 id="RedoLog-buffer"><a href="#RedoLog-buffer" class="headerlink" title="RedoLog buffer"></a>RedoLog buffer</h2><p>好比Buffer Pool，基于内存中的一块连续空间。里面分配了多个空的RedoLog block。用来存放redolog。    </p>
<ul>
<li>在一个事务中，多个操作对应多个redo Log，对应着一组redolog，现在别的地方暂存，执行完了再把一组的redolog写入到内存中的redolog buffer中的block中</li>
<li>如果一个事务对应的redoLog太多，就会放到两个甚至多个redolog block中。</li>
<li>如果一个redolog group比较小，也可能会把多个redolog group合并在一个redolog block中。</li>
</ul>
<h2 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h2><ol>
<li>写入redolog buffer的日志占用了总容量（innodb_log_buffer_size）的50%。</li>
<li>事务提交的时候</li>
<li>后台线程定时刷新</li>
<li>MYSQL关闭的时候</li>
</ol>
<h2 id="RedoLog的一些默认处理"><a href="#RedoLog的一些默认处理" class="headerlink" title="RedoLog的一些默认处理"></a>RedoLog的一些默认处理</h2><p>磁盘上默认redolog数量：2个(innodb_log_files_in_group)<br>磁盘上默认redolog大小：48MB(innodb_log_file_size)<br>磁盘上的默认名：ib_logfile0，ib_logfile1<br>一般情况是向一个redolog中写，写满了就换下一个。所以redolog最多保存96MB的redolog，如果第二个写满了，就覆盖第一个日志文件里面原来的redolog</p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql Undolog（回滚日志）</title>
    <url>/2021/08/25/MySql-Undolog%EF%BC%88%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>为了在事务提交前，随时能够回滚缓存页中已经修改的数据，就需要用undolog来记录之前的改动情况。新增操作就对应着一个删除操作来回滚，删除操作也有对应的一个新增操作。更新操作也有对应的更新操作。</p>
<h1 id="回滚类型"><a href="#回滚类型" class="headerlink" title="回滚类型"></a>回滚类型</h1><p>undolog根据操作类型分为3种类型。</p>
<h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><p>类型：TRX_UNDO_INSERT_REC<br>内容：</p>
<ul>
<li>日志开始位置</li>
<li>主键的各列长度和值（可能是联合主键）</li>
<li>表id</li>
<li>undolog日志编号</li>
<li>undolog日志类型</li>
<li>日志结束位置<br>操作：<br>在回滚时，通过获取主键的值以及表id可以直接定位到对应的缓存页，从里面删除之前插入的数据 </li>
</ul>
<span id="more"></span>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>如果更新的条件是主键列，则删除行然后添加一条记录。<br>如果更新的条件不是主键列，则进行反向更新。</p>
<h1 id="undolog版本链"><a href="#undolog版本链" class="headerlink" title="undolog版本链"></a>undolog版本链</h1><p>在<font color="red"><b>03.数据在磁盘上的存储</b></font>中，说到了数据在磁盘上的存储格式，其中就包含了隐藏字段：DB_TRX_ID和DB_ROLL_PTR。    </p>
<ul>
<li>DB_TRX_ID：最近一次更新这条数据事务的ID</li>
<li>DB_ROLL_PTR：更新这个事务之前生成的undolog<br>通过这2个隐藏字段，就可以在多事务并发访问下，保证数据的串行修改。</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/images/img-41.png"></p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql 关于索引的一些特殊情况</title>
    <url>/2021/08/25/MySql-%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h1 id="范围查询数据量过大导致索引失效"><a href="#范围查询数据量过大导致索引失效" class="headerlink" title="范围查询数据量过大导致索引失效"></a>范围查询数据量过大导致索引失效</h1><p>存在索引idx_fk_customer_id(customer_id)，表中数据16000条。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rental <span class="keyword">WHERE</span> customer_id<span class="operator">&lt;</span><span class="number">102</span>; # 使用索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> rental <span class="keyword">WHERE</span> customer_id<span class="operator">&lt;</span><span class="number">103</span>; # 全表扫描</span><br></pre></td></tr></table></figure>
<p>当范围查询时，如果符合条件的数据过多时，因为建立索引的字段虽然在索引树上有序，但是这一部分数据还要回源到聚簇索引中再次查询，并且得到的数据在磁盘上并不是连续的，这样会产生大量的随机IO，而随机IO是非常慢的，与其这样还不如全表扫描。全表扫描最起码是顺序IO。</p>
<h1 id="Semi-join半连接"><a href="#Semi-join半连接" class="headerlink" title="Semi join半连接"></a>Semi join半连接</h1><ul>
<li>explain列中filtered为什么有时候不准</li>
<li>Extra列中Using index condition都是索引下推吗？</li>
</ul>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql 基础</title>
    <url>/2021/08/25/MySql-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="名词说明"><a href="#名词说明" class="headerlink" title="名词说明"></a>名词说明</h1><h2 id="MYSQL驱动"><a href="#MYSQL驱动" class="headerlink" title="MYSQL驱动"></a>MYSQL驱动</h2><p>在底层跟数据库建立网络连接</p>
<h2 id="系统连接池"><a href="#系统连接池" class="headerlink" title="系统连接池"></a>系统连接池</h2><p>建立数据库连接是一个非常耗时的操作，而实际业务中往往会有很多请求去访问数据库，所以要使用一个数据库连接池来维护多个数据库连接。线程使用完连接后不用销毁，直接放回连接池以便后续使用。</p>
<h2 id="MYSQL连接池"><a href="#MYSQL连接池" class="headerlink" title="MYSQL连接池"></a>MYSQL连接池</h2><p>维护了与系统之间的多个数据库连接。除此之外，系统每次与MYSQL建立连接的时候，还会进行账户信息验证，库表权限验证。</p>
<h2 id="SQL接口"><a href="#SQL接口" class="headerlink" title="SQL接口"></a>SQL接口</h2><p>MYSQL内部提供的一个组件，负责执行线程传递过来的SQL语句</p>
<span id="more"></span>
<h2 id="查询解析器"><a href="#查询解析器" class="headerlink" title="查询解析器"></a>查询解析器</h2><p>负责对SQL语句进行解析，知道做什么操作，对哪张表操作，操作哪些数据，怎么操作等</p>
<h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><p>得到一个效率最高的执行计划</p>
<h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>根据查询优化器选择的一套执行计划，不停的调用存储引擎的各种接口去完成SQL语句的执行计划。    </p>
<blockquote>
<p>比如执行器可能先会调用存储引擎的一个接口去获取user表的第一行数据，判断id是否为我们期望的一个值，如果不是就继续调用接口获取下一行数据继续判断</p>
</blockquote>
<h2 id="存储引擎接口"><a href="#存储引擎接口" class="headerlink" title="存储引擎接口"></a>存储引擎接口</h2><p>执行SQL语句，按照一定的步骤去查询内存缓存数据，更新磁盘数据，查询磁盘数据等。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/images/img-35.png" alt="流程图"></p>
<h1 id="InnoDB内存结构"><a href="#InnoDB内存结构" class="headerlink" title="InnoDB内存结构"></a>InnoDB内存结构</h1><h2 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h2><p>缓冲池（Buffer Pool），方便查询的时候，直接可以从内存缓冲池中获取，减少对磁盘的查询    </p>
<h2 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h2><p>用于回滚数据</p>
<h2 id="更新缓存数据流程"><a href="#更新缓存数据流程" class="headerlink" title="更新缓存数据流程"></a>更新缓存数据流程</h2><ol>
<li>记录加载到缓冲池</li>
<li>加锁</li>
<li>旧值写入undo日志文件</li>
<li>更新缓冲池中的记录，此时这个数据就是脏数据了（和磁盘数据不一致）</li>
</ol>
<h2 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h2><p>记录内存中的数据修改，避免内存修改后没有同步到磁盘上。InnoDB存储引擎特有的一个东西。在mysql重启时会加载redo日志中的修改到内存里去，然后等适当时机通过IO线程把修改后的数据同步到磁盘上。</p>
<h2 id="RedoLog-Buffer"><a href="#RedoLog-Buffer" class="headerlink" title="RedoLog Buffer"></a>RedoLog Buffer</h2><p>内存中的一个缓冲区。暂时存放redo日志。</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>归档日志，<font color="red"><strong>偏向物理性质的重做日志</strong></font>，类似于，对XX表中某一行数据进行了修改，修改后的值是XXX；在提交事务的时候，还会把binlog的文件名，位置以及commit标记写入对应的redo日志中。</p>
<h2 id="事务提交流程"><a href="#事务提交流程" class="headerlink" title="事务提交流程"></a>事务提交流程</h2><p><img src="/images/img-36.png" alt="事务提交流程"><br>1.根据策略(innodb_flush_log_at_trx_commit)，把redo日志从redo log buffer刷到磁盘文件。    </p>
<blockquote>
<p>0：不管事务，每一秒都会把日志写入，并且刷到磁盘。事务提交时不会主动触发写磁盘的操作。<br><strong>1：只要事务提交成功，redo log就必然在磁盘里（建议）</strong><br>2：提交事务的时候，把redo日志写入磁盘对应的os cache缓存，而不是直接进入磁盘文件，可能要过一段时间再写入磁盘    </p>
</blockquote>
<ol start="2">
<li><p>根据策略(sync_binlog)，把binlog日志写入磁盘</p>
<blockquote>
<p>0：写入os cache，一段时间后写入磁盘（默认）<br>1：强制在提交事务的时候，直接写入到磁盘文件</p>
</blockquote>
</li>
<li><p>把写入磁盘的binlog日志的文件名，位置以及一个commit标记写入到redo日志</p>
</li>
<li><p>至此，事务才算提交完成。只要redo日志中不存在commit标记则认为提交失败。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql 执行计划</title>
    <url>/2021/08/25/MySql-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h1 id="执行计划类型"><a href="#执行计划类型" class="headerlink" title="执行计划类型"></a>执行计划类型</h1><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>直接通过聚簇索引或者二级索引+聚簇索引回源，查询到想要的数据。这种根据索引可以直接快速查询到数据的过程，在执行计划里称之为<strong>const</strong>。<br><font color="red">二级索引必须是unique，才是const。否则就是ref</font></p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>一般走索引都是ref，如果是组合索引，则要求查询条件必须是从索引最左侧开始连续多列都是等值比较。    </p>
<h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>对索引列使用范围查询。</p>
<h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>只需要遍历二级索引就可以拿到想要的数据，而不需要回源到聚簇索引的访问方式。</p>
<ul>
<li>索引：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idx(S21,S22,S23,S24)</span><br></pre></td></tr></table></figure>
SQL：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT S21,S22,S23 FROM TABLE WHERE S22 = &#x27;X&#x27; AND S23 = &#x27;Z&#x27;; </span><br></pre></td></tr></table></figure>
  第一反应：这个SQL无法直接从联合索引树的根节点进行二分查找。    基于上面的索引以及SQL，可以直接遍历联合索引树的叶子节点，找到所需要的数据，不需要再回源到聚簇索引进行二次查询，这种方式就是使用的index访问。    虽然遍历了叶子节点，但是叶子节点内容少。也比回表查询快。</li>
</ul>
<span id="more"></span>
<h1 id="什么情况下一次查询用到多个索引"><a href="#什么情况下一次查询用到多个索引" class="headerlink" title="什么情况下一次查询用到多个索引"></a>什么情况下一次查询用到多个索引</h1><ul>
<li>现有索引：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idx(x1)，idx(x2);</span><br></pre></td></tr></table></figure>
现有SQL：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM TABLE WHERE X1 = XX AND X2 = ZZ;</span><br></pre></td></tr></table></figure>
  在一般情况下，查询优化器生成执行计划只会按照其中一个字段的索引树去查找，然后再回表到聚簇索引查完整数据，然后根据另一个字段的值过滤。    <strong>当按照某个索引值查询之后得到了上万条的数据，此时就要考虑再通过另一个索引查询，将两个索引得到的结果的主键进行求交集，然后再去回表查询。</strong></li>
</ul>
<h1 id="多表关联的SQL语句的执行计划"><a href="#多表关联的SQL语句的执行计划" class="headerlink" title="多表关联的SQL语句的执行计划"></a>多表关联的SQL语句的执行计划</h1><h2 id="驱动表与被驱动表"><a href="#驱动表与被驱动表" class="headerlink" title="驱动表与被驱动表"></a>驱动表与被驱动表</h2><p>在多表关联查询时，一般是通过部分条件先从一张表中取出符合条件的数据，然后再在这些数据中进行后续的条件匹配。先查询的表叫做驱动表，后查询的表就叫被驱动表。</p>
<h2 id="内连接与外连接"><a href="#内连接与外连接" class="headerlink" title="内连接与外连接"></a>内连接与外连接</h2><ul>
<li><p>内连接：INNER JOIN，连接条件写在WHERE中，并且按照表与表之间的字段关系严格判断，为空的不会显示</p>
</li>
<li><p>外连接：[LEFT | RIGHT] OUTER JOIN，连接条件写在ON中；如果是LEFT则表示左侧表中的数据不管右侧表里是否有关联都会返回出来，右侧大不了显示为NULL。</p>
</li>
</ul>
<h2 id="嵌套循环关联"><a href="#嵌套循环关联" class="headerlink" title="嵌套循环关联"></a>嵌套循环关联</h2><p>多表关联查询，往往都是利用驱动表的结果，去被驱动表中通过where条件，on条件进行遍历匹配。因此如果关联表很多，就会因为遍历的效率影响整个SQL的执行效率，所以要合理的在驱动表和被驱动表上建立合适的索引。</p>
<h1 id="执行成本的计算"><a href="#执行成本的计算" class="headerlink" title="执行成本的计算"></a>执行成本的计算</h1><h2 id="成本的组成"><a href="#成本的组成" class="headerlink" title="成本的组成"></a>成本的组成</h2><ul>
<li><p>IO成本</p>
</li>
<li><p>CPU成本</p>
</li>
</ul>
<h2 id="计算方式"><a href="#计算方式" class="headerlink" title="计算方式"></a><a href="https://www.jianshu.com/p/aecdcc2babdd">计算方式</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. MYSQL规定读取一页花费的成本默认是1.0，读取以及检测一条记录是否符合搜索条件的成本默认是0.2。</span><br><span class="line">2. 不管读取到的记录需不需要检测是否符合搜索条件，其成本都是0.2</span><br><span class="line">3. 通过show table status like &#x27;表名&#x27;，可以查看指定表的一些信息</span><br><span class="line">4. rows是表中的记录数（对于innodb来说这个是个估计值），data_length是聚簇索引的字节数大小。通过data_length/(1024*16)可以算出有多少页，就能算出全表扫描的成本。</span><br><span class="line">5. IO成本=数据页数量*1+1.1</span><br><span class="line">6. CPU成本=行记录数*0.2+1.0</span><br><span class="line">7. 总成本=IO成本+CPU成本</span><br></pre></td></tr></table></figure>

<h3 id="计算示例"><a href="#计算示例" class="headerlink" title="计算示例"></a>计算示例</h3><p><img src="/images/img-62.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据页数=(98304/1024)/16=6    </span><br><span class="line">行记录数=603    </span><br><span class="line">总成本=6*1+0.2*603=126.6</span><br></pre></td></tr></table></figure>

<h3 id="二级索引要注意的点"><a href="#二级索引要注意的点" class="headerlink" title="二级索引要注意的点"></a>二级索引要注意的点</h3><ul>
<li><p>二级索引在计算时要先计算二级索引根据条件查一波数据的IO成本，比如score between 25,200 or score between 250,300，这是2个范围，否则score=XX就是一个区间。</p>
</li>
<li><p>一般一个区间可以简单的认为是<strong>一个数据页</strong>，也可能是n个数据页，反正是个位数级别的。</p>
</li>
<li><p>二级索引得到的结果再回表，一条数据回表一次。</p>
</li>
<li><p>a104</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>MySql 数据在磁盘上的存储</title>
    <url>/2021/08/25/MySql-%E6%95%B0%E6%8D%AE%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%8A%E7%9A%84%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="物理数据存储格式"><a href="#物理数据存储格式" class="headerlink" title="物理数据存储格式"></a>物理数据存储格式</h1><h2 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h2><ul>
<li>COMPACT格式<br>  大致格式：变长字段的长度列表，null值列表（长度为8n），数据头[隐藏字段]，col1的值，col2的值。。。    </li>
<li>xxx格式</li>
</ul>
<h2 id="变长字段的存储"><a href="#变长字段的存储" class="headerlink" title="变长字段的存储"></a>变长字段的存储</h2><p>因为变长字段的内容不固定，所以无法判断数据要从何处截断，因此在数据的头部保存了变长字段的长度列表。多个变长字段按照字段顺序<font color="red"><strong>逆序</strong></font>放入变长字段的长度列表中。不考虑为null的列。    </p>
<span id="more"></span>
<h2 id="NULL值的存储"><a href="#NULL值的存储" class="headerlink" title="NULL值的存储"></a>NULL值的存储</h2><p>对于所有的NULL值，是通过二进制的bit位来存储，一行数据如果有多个字段的值为NULL，那么这些字段的NULL会以bit位的形式存放在NULL值列表中。0表示不是NULL，1表示是NULL，同样也是<font color="red"><strong>逆序</strong></font>存放.==需要注意的是，不允许为NULL的列是不考虑的==。</p>
<h2 id="数据头"><a href="#数据头" class="headerlink" title="数据头"></a>数据头</h2><table>
<thead>
<tr>
<th>bit位</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>预留位</td>
<td>无</td>
</tr>
<tr>
<td>1</td>
<td>预留位</td>
<td>无</td>
</tr>
<tr>
<td>1</td>
<td>delete_mask</td>
<td>删除标志位</td>
</tr>
<tr>
<td>1</td>
<td>min_rec_mask</td>
<td>B+树的每一层非叶子节点的最小值会有这个标志</td>
</tr>
<tr>
<td>4</td>
<td>n_owned</td>
<td>拥有的记录数</td>
</tr>
<tr>
<td>13</td>
<td>heap_no</td>
<td>当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td>3</td>
<td>record_type</td>
<td>当前记录的类型，0：普通；1：B+树非叶子节点；2：最小值数据；3：最大值数据</td>
</tr>
<tr>
<td>16</td>
<td>next_record</td>
<td>下一条数据的指针</td>
</tr>
</tbody></table>
<h2 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h2><ul>
<li>DB_ROW_ID：行唯一标识，在没有指定主键和Unique key唯一索引的时候，会以他作为主键</li>
<li>DB_TRX_ID：事务相关</li>
<li>DB_ROLL_PTR：回滚指针，用于事务回滚</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote>
<p>红色的列表示不允许为空</p>
</blockquote>
<table>
<thead>
<tr>
<th><font color="red"> varchar(10)</font></th>
<th>varchar(20)</th>
<th>varchar(5)</th>
<th>char(2)</th>
<th>char(3)</th>
<th>可能格式</th>
</tr>
</thead>
<tbody><tr>
<td>hello</td>
<td>nice</td>
<td>a</td>
<td>zx</td>
<td>cc</td>
<td>[0x01,0x04,0x05][00000000][头字段]hello nice a zx cc</td>
</tr>
<tr>
<td>ppt</td>
<td>word</td>
<td>flash</td>
<td>d</td>
<td>z</td>
<td>[0x05,0x04,0x03][00000000][头字段]ppt wprd flash d z</td>
</tr>
<tr>
<td>jack</td>
<td>NULL</td>
<td>cc</td>
<td>ps</td>
<td>NULL</td>
<td>[0x02,0x04][00001001][头字段]jack cc ps</td>
</tr>
<tr>
<td>tom</td>
<td>3</td>
<td>mg</td>
<td>NULL</td>
<td>KG</td>
<td>[0x02,0x01,0x03][00000100][头字段]tom 3 mg KG</td>
</tr>
</tbody></table>
<h3 id="紧凑的意义"><a href="#紧凑的意义" class="headerlink" title="紧凑的意义"></a>紧凑的意义</h3><p>节省空间？</p>
<h2 id="读取的过程"><a href="#读取的过程" class="headerlink" title="读取的过程"></a>读取的过程</h2><ol start="0">
<li>示例样本(选自上方)<br>[0x02,0x01,0x03][00000100][010000001000011111]tom 3 mg KG   </li>
<li>先读取出变长字段长度列表和NULL值列表，分析得到几个变长字段以及哪几个字段是NULL。因为MYSQL自己定义的列以及类型自己最清楚哪些列是变长哪些列允许NULL</li>
<li>第一个字段不允许为空所以不会出现在NULL值列表中，是变长类型所以从变长列表中取出0x03，就去字段列表中读取3个字符的长度，得到tom</li>
<li>第二个字段为变长允许为空，所以读取NULL值列表知道不为空，在读取变长列表得到长度为0x01,所以读取1个字符的长度得到3</li>
<li>第三个字段为变长允许为空，所以读取NULL值列表知道不为空，在读取变长列表得到长度为0x02,所以读取2个字符的长度得到mg</li>
<li>第四个字段为定长允许为空，所以直接读取NULL值列表知道为空，所以直接为null</li>
<li>第五个字段为定长允许为空，直接读取NULL值列表知道不为空，所以直接读取固定的3个长度得到KG 。（这里KG后面还有一个空格补充长度）</li>
</ol>
<h1 id="行溢出"><a href="#行溢出" class="headerlink" title="行溢出"></a>行溢出</h1><p>因为每行数据都是存放在一个数据页中的，一个数据页是16KB，如果一行数据的大小超过了数据页的大小。比如一个字段是VARCHAR(65532),最多可以放65532个字符，65532个字符至少也是65532b≈64kb&gt;&gt;16kb。<br>这个时候就会在那一页存放你的数据，然后特别长的字段中，只会包含部分数据，同时还==包含一个20个字节的指针，指向其他的数据页==，用于把这些数据页用链表串联起来，存放超大数据。</p>
<h1 id="数据页的拆分"><a href="#数据页的拆分" class="headerlink" title="数据页的拆分"></a>数据页的拆分</h1><p>数据页16kb的大小实际上被拆分成了多个部分，包括    </p>
<ul>
<li>文件头（38b）</li>
<li>数据页头（56b）</li>
<li>最小记录和最大记录（26b）</li>
<li>多个数据行</li>
<li>空闲空间</li>
<li>数据页目录</li>
<li>文件尾部（8b）</li>
</ul>
<h1 id="数据区与数据组"><a href="#数据区与数据组" class="headerlink" title="数据区与数据组"></a>数据区与数据组</h1><p>在磁盘上，一个表空间的数据文件中可能包含多个数据页，为了便于管理，引入了数据区的概念。一个数据区对应着64个连续的数据页，每页16kb，所以一个数据区是1MB。256个数据区划分为1组(extent)。所以1组是256MB。    </p>
<h2 id="第一个数据区特殊的3页"><a href="#第一个数据区特殊的3页" class="headerlink" title="第一个数据区特殊的3页"></a>第一个数据区特殊的3页</h2><p>一个表空间的第一个数据区的前3个数据页是固定的，存放描述性信息。</p>
<ul>
<li>FSP_HDR</li>
<li>IBUF_BITMAP</li>
<li>INODE</li>
</ul>
<h2 id="其他数据区特殊的2页"><a href="#其他数据区特殊的2页" class="headerlink" title="其他数据区特殊的2页"></a>其他数据区特殊的2页</h2><p>同理也是存放描述性信息</p>
<ul>
<li>XDES</li>
<li>未知</li>
</ul>
<h1 id="一个口述的数据插入流程"><a href="#一个口述的数据插入流程" class="headerlink" title="一个口述的数据插入流程"></a>一个口述的数据插入流程</h1><ol>
<li>根据表名找到对应的表空间，定位到对应的磁盘文件</li>
<li>从磁盘文件中拿到一个extent组，从里面找出一页数据页</li>
<li>加载数据页到Buffer Pool</li>
</ol>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql 索引引入的前提</title>
    <url>/2021/08/25/MySql-%E7%B4%A2%E5%BC%95%E5%BC%95%E5%85%A5%E7%9A%84%E5%89%8D%E6%8F%90/</url>
    <content><![CDATA[<h1 id="磁盘数据页的存储结构"><a href="#磁盘数据页的存储结构" class="headerlink" title="磁盘数据页的存储结构"></a>磁盘数据页的存储结构</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>数据页是按顺序一页一页的存放的，两两相邻的数据页之间会采用双向链表的格式相互引用。</li>
<li>数据页内部多个数据行通过主键顺序形成单向链表</li>
<li>每个数据页都有一个页目录，根据数据行的主键存放了一个目录，同时数据行是被分散存储到不同的槽位里去的。所以每个数据页的目录里，就是这个页里没个主键跟所在槽位的映射关系。</li>
</ul>
<h2 id="主键查询"><a href="#主键查询" class="headerlink" title="主键查询"></a>主键查询</h2><p>通过传入的主键到页目录中根据主键进行二分查找，通过二分查找在目录中定位到数据的槽位，到对应的槽位遍历每一行数据进行对比</p>
<h2 id="非主键查询"><a href="#非主键查询" class="headerlink" title="非主键查询"></a>非主键查询</h2><p>进入数据页里，根据单向链表依次遍历查找数据，性能很差</p>
<h1 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h1><p>在没有任何索引数据结构的时候，无论如何查询数据，都是一个全表扫描的过程。根据双向链表依次把磁盘上的数据页加载到缓存页里去，然后在缓存页内部来查找那条数据。</p>
<h1 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h1><p><img src="/images/img-61.png"><br>数据页中包含了一个起始行，行类型是2；包含了一个行类型为3的结束行（具体可以看03.数据在磁盘上的存储，里面有提到行格式）。其他行都是普通行，类型为0；<br>当不停的插入数据时，最开始在第一个数据页。当第一个数据页满了，就创建了第二个数据页。但是有时候主键不一定是自增长的，所以会出现第二页中的数据的主键大于第一页中的数据的主键；<br><strong>为了避免这种情况，在新增一个数据页的时候，会把前一个数据页中主键值较大的，挪动到新的数据页中来。然后把新插入的主键较小的数据挪到上一个数据页中，保证新数据页中的主键值一定比上一个数据页里的主键值大（索引的一个核心基础），这就是页分裂</strong></p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql 索引机制</title>
    <url>/2021/08/25/MySql-%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="主键索引的设计"><a href="#主键索引的设计" class="headerlink" title="主键索引的设计"></a>主键索引的设计</h1><p>每个数据页中都有一个页目录，可以方便在当前数据页中进行数据的查询。但是如果有多个数据页的情况下，对于一个主键的查询，得知数据在哪个数据页显得尤为重要。<br>因此针对主键设计了一个主键目录，就是把每个数据页的页号以及数据页中最小的主键放在一起，组成一个索引的目录，如下图：<br><img src="/images/img-54.png"><br>基于主键目录，先通过主键目录可以对比得到查询的数据可能在哪个数据页，然后到对应的数据页中基于二分法查找。</p>
<h1 id="索引页"><a href="#索引页" class="headerlink" title="索引页"></a>索引页</h1><span id="more"></span>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>当数据量超级大的时候，数据页的数量也非常的多。主键目录就得存放大量的数据页和最小主键值。性能没有得到突破。<br>此时，通过<strong>索引页</strong>来存放索引数据。<br><img src="/images/img-56.png"><br>需要注意的是，索引页中，出现了类型为1的行数据。表示的是B+树非叶子节点。<br><strong>虽然索引页多了，但是又应该到哪个索引页中去查主键数据，此时又可以把索引页进行一次“索引”，在更高层的索引层级中，保存了每个索引页里的最小主键值和索引页号。</strong><br><img src="/images/img-58.png"><br><strong>（如果跟高层的索引层级中数据也嫌多，那就继续套娃，这就形成了一个树结构）</strong><br><img src="/images/img-59.png"></p>
<h2 id="基于索引页的查找"><a href="#基于索引页的查找" class="headerlink" title="基于索引页的查找"></a>基于索引页的查找</h2><p>如果要查询一个数据的主键为19，就应该先从顶层的索引页60里去找，通过二分法的方式得到下层要去索引页17中查找。然后一直找到了数据可能在数据页2中，然后去数据页2中，通过页目录，找到对应的槽位，读取数据。</p>
<h1 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h1><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>如果在一个B+树索引数据结构中，叶子节点就是数据页本身，那么可以称这个B+数为聚簇索引。（innodb默认创建的一套基于主键的索引结构，表中的数据直接放在聚簇索引里，作为叶子节点的数据页）</p>
<h2 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h2><p>如果要对非主键的字段创建索引，那么会重新生成一颗B+树，叶子节点也是数据页，<strong>但是数据页中只会存放主键字段和对应的索引字段</strong>。<br>排序规则也是按照创建索引字段的顺序来严格排序的，也会有页分裂来保证顺序。</p>
<h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>在二级索引上进行查询时，比如对name字段建立的二级索引，当select name from xxx where id = xxx时，通过叶子节点中的数据页内容就能直接返回。<br>但是如果select * from xxx where name = xxx时，叶子节点的数据不足以返回，还得通过主键去聚簇索引中定位到主键对应的完整数据行，此时才能把select * 要查询的字段值全部拿出来。</p>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>多个字段建立二级索引，也是一颗独立的B+树，叶子节点的数据页中包含了id，colA，colB。然后按照colA排序，如果colA相同就按照colB排序。</p>
<h1 id="插入数据时如何维护不同索引的B-树"><a href="#插入数据时如何维护不同索引的B-树" class="headerlink" title="插入数据时如何维护不同索引的B+树"></a>插入数据时如何维护不同索引的B+树</h1><ol>
<li>创建表时，就一个数据页。目前为空</li>
<li>开始插入数据，这个初始的数据页就是根页。数据页内部有一个基于主键的页目录，此时通过页目录查询就行。</li>
<li>数据越来越多数据页满了，创建一个新的数据页，然后把根页中的数据拷贝过去，同时再搞一个新的数据页，根据主键值的大小进行挪动，让两个数据页根据主键值排序，使得第二个数据页的主键值都大于第一个数据页的主键值。此时根页就变成了索引页。根页中存放了两个数据页的页号和他们里面的最小的主键值。</li>
<li>随着不停的增加数据，数据页不断的页分裂。索引页中的数据页索引条目越来越多，索引页开始分裂成两个索引页，然后根页继续往上走一个层级，引用两个索引页。</li>
<li>然后开始套娃。</li>
</ol>
<blockquote>
<p>与聚簇索引不同的是，二级索引的B+树的索引页中，除了存放页号和最小的索引字段值外，还会额外存放最小索引字段对应的主键值。</p>
</blockquote>
<h1 id="使用索引的几个原则"><a href="#使用索引的几个原则" class="headerlink" title="使用索引的几个原则"></a>使用索引的几个原则</h1><blockquote>
<p>索引idx_abc(a,b,c)</p>
</blockquote>
<h2 id="等值匹配原则"><a href="#等值匹配原则" class="headerlink" title="等值匹配原则"></a>等值匹配原则</h2><p>where条件中字段采用等于连接，并且完全包含了索引中的所有字段。<br>比如where a=1 and b=2 and c=3</p>
<h2 id="最左侧列匹配"><a href="#最左侧列匹配" class="headerlink" title="最左侧列匹配"></a>最左侧列匹配</h2><p>采用索引中左侧的部分字段来查询，不能跳跃。<br>比如where a=1 and b=2 可以使用索引。但是where a=1 and c=3 不行。</p>
<h2 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h2><p>如果使用like查询，则最左侧不能出现通配符。<br>比如where a like ‘1%’。</p>
<h2 id="范围查找规则"><a href="#范围查找规则" class="headerlink" title="范围查找规则"></a>范围查找规则</h2><p>where语句里如果有范围查询，那只有对联合索引里最左侧的列进行范围查询才能用到索引！后续的字段无法使用到索引。<br>比如where a &gt; 1 and a&lt;5 and b&lt;1只会使用a列的索引</p>
<h2 id="等值匹配-范围匹配"><a href="#等值匹配-范围匹配" class="headerlink" title="等值匹配+范围匹配"></a>等值匹配+范围匹配</h2><p>按照前面的列等值匹配，后面的列范围匹配，需要注意的是，如果多列范围匹配只会生效最靠左的那一列。<br>比如where a=1 and b &gt;1 and b&lt;4 and c&lt;5只会使用a,b列的索引</p>
<h1 id="利用索引优化查询"><a href="#利用索引优化查询" class="headerlink" title="利用索引优化查询"></a>利用索引优化查询</h1><h2 id="SQL排序如何利用索引"><a href="#SQL排序如何利用索引" class="headerlink" title="SQL排序如何利用索引"></a>SQL排序如何利用索引</h2><p>对语句<code>SELECT * FROM TABLE ORDER BY TOTAL_SCORE DESC, NAME DESC LIMIT 20,10</code><br>语句主要是把表根据总分降序，名字降序排序后从第20页取出10条数据，可以建立（TOTAL_SCORE,NAME）的一个索引，这样的话，直接从索引树中最大的数据开始进行偏移，然后读取10条数据就行。因为索引树本身自带排序。<br><strong>这样的索引建立有一个前提，就是ORDER BY后面要么都是升序，要么都是降序，不能出现部分升序，部分降序。</strong></p>
<h2 id="SQL分组如何利用索引"><a href="#SQL分组如何利用索引" class="headerlink" title="SQL分组如何利用索引"></a>SQL分组如何利用索引</h2><p>通常而言，对于group by后的字段，最好也是按照联合索引里的最左侧的字段开始，按顺序排列开来，这样的话，其实就可以完美的运用上索引来直接提取一组一组的数据，然后针对每一组的数据执行聚合函数就可以了。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果我们建立了一个索引idx_name_age，那么我们在执行select * from student where name = ‘张三’ and age &gt;5 时，会先扫描一次idx_name_age索引，拿到主键后再去聚簇索引中查询一次，这叫做回表。但是如果查询的字段恰好是索引中的一部分，比如select name，这样的话，直接通过索引树就能够直接返回，这叫做覆盖索引。</p>
<h1 id="如何尽可能的减少回表"><a href="#如何尽可能的减少回表" class="headerlink" title="如何尽可能的减少回表"></a>如何尽可能的减少回表</h1><p>在利用联合索引查询的实际情况下，往往可能因为回表到聚簇索引的次数太多，直接进行全表扫描。因此要尽可能的减少回表次数。    </p>
<ul>
<li>尽可能在SQL中指定要查询的字段名，尽量走覆盖索引</li>
<li>即便是要回表，尽可能使用limit，where等语句限定回表到聚簇索引的次数。</li>
</ul>
<h1 id="设计索引的考虑因素"><a href="#设计索引的考虑因素" class="headerlink" title="设计索引的考虑因素"></a>设计索引的考虑因素</h1><ol>
<li>实际查询中在where，group by,order by后面高频出现的字段</li>
<li>基数比较大的字段（基数：不同的数据对于同一个列的不同值，比如性别这一列的基数最大只能是2，而出生年月日因人而异就会很多）</li>
<li>字段类型比较小的字段</li>
<li>如果非得在varchar(255)这样的字段上建立索引，也可以考虑只建立前20个字符的一个索引。</li>
<li>对索引列使用函数会导致无法使用到索引</li>
<li>不要建立太多的索引，因为新增数据可能会导致多个索引树的页分裂，很费时间</li>
</ol>
<h1 id="一款交友软件，陌生人搜索相关的索引建立过程"><a href="#一款交友软件，陌生人搜索相关的索引建立过程" class="headerlink" title="一款交友软件，陌生人搜索相关的索引建立过程"></a>一款交友软件，陌生人搜索相关的索引建立过程</h1><h2 id="字段的确定"><a href="#字段的确定" class="headerlink" title="字段的确定"></a>字段的确定</h2><ul>
<li>省份provice</li>
<li>城市city</li>
<li>性别sex</li>
<li>年龄age</li>
</ul>
<h2 id="如果where和order-by中的字段不同，建立谁的索引？"><a href="#如果where和order-by中的字段不同，建立谁的索引？" class="headerlink" title="如果where和order by中的字段不同，建立谁的索引？"></a>如果where和order by中的字段不同，建立谁的索引？</h2><p>对于SQL：SELECT * FROM USER WHERE provice = ‘四川’ order by age = 24<br>WHERE条件和ORDER BY使用了不同的字段；建立PROVINCE的索引，ORDER BY利用不到索引；建立age的索引，WHERE条件利用不到索引；如果建立联合索引Idx(province,age)也解决不了问题，只能二选一建立索引。<br>以where条件中的字段建立索引，因为基于where筛选可以最快速度筛选出所需要的少量数据。如果数据量不是特别大的情况下，order by的成本也不会太大</p>
<h2 id="如何跳过基数很小的字段在索引中的位置"><a href="#如何跳过基数很小的字段在索引中的位置" class="headerlink" title="如何跳过基数很小的字段在索引中的位置"></a>如何跳过基数很小的字段在索引中的位置</h2><p>对于建立了索引idx(provice,city,sex,age)的SQL：<br>SELECT * FROM USER WHERE provice = xx and city = xx and age = 15    </p>
<p>上面的SQL，说明了对于sex的条件没有勾选；<br>因为sex的基数最大是2。上面的SQL在已有的索引下，是无法通过age在索引中进行筛选的。但是可以通过添加上sex in (‘male’,’female’) 这个等值条件，使得索引生效。</p>
<h2 id="根据七天内是否在线作为过滤条件"><a href="#根据七天内是否在线作为过滤条件" class="headerlink" title="根据七天内是否在线作为过滤条件"></a>根据七天内是否在线作为过滤条件</h2><p>原始字段：latest_login_time<br>如果添加了这个字段，势必会利用latest_login_time的一个大于或者小于操作来筛选数据，但是在idx(provice,city,sex,age)的情况下，修改索引为(provice,city,sex,latest_login_time,age)也会导致age使用不到索引。<br>新增字段：does_login_in_latest_7_days（基数为2，原理同sex，利用等值查询）</p>
<h2 id="通过对基数很小的字段进行索引的创建"><a href="#通过对基数很小的字段进行索引的创建" class="headerlink" title="通过对基数很小的字段进行索引的创建"></a>通过对基数很小的字段进行索引的创建</h2><p>对于SQL：SELECT * FROM USER WHERE SEX = ‘female’ ORDER BY VIP_SCORE DESC LIMIT 0,10<br>如果只是建立索引idx(sex)，上面的SQL经过索引后依然有海量的数据，再进行磁盘文件排序，性能很低。<br>再这样的情况下，可以针对于基数很低的字段再加上一个排序字段单独设计一个辅助索引，idx(sex,score)。此时依然可以使用到索引来排序。因为sex=’female’的数据在磁盘上是排在一起的。找到这一部分数据后，他们肯定都是按照score排序的，此时根据score字段值的顺序去读取limit语句指定的数据就行。</p>
<h2 id="区间查询的字段一定要放在索引的最右边"><a href="#区间查询的字段一定要放在索引的最右边" class="headerlink" title="区间查询的字段一定要放在索引的最右边"></a>区间查询的字段一定要放在索引的最右边</h2>]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql 锁机制</title>
    <url>/2021/08/25/MySql-%E9%94%81/</url>
    <content><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>当多个事务同时更新一条数据的时候，如何防止脏写的问题</p>
<h1 id="锁机制的引入"><a href="#锁机制的引入" class="headerlink" title="锁机制的引入"></a>锁机制的引入</h1><p>依靠锁机制让多个事务更新同一行数据的时候串行化，避免同时更新。</p>
<h1 id="锁机制下的更新步骤"><a href="#锁机制下的更新步骤" class="headerlink" title="锁机制下的更新步骤"></a>锁机制下的更新步骤</h1><ol>
<li>事务A要更新一条数据，先判断当前数据是否有锁。没锁则当前事务创建一个锁，其中包含了自己的trx_id和等待状态，然后把锁和数据关联起来。</li>
<li>此时数据和锁都是在内存中。</li>
<li>事务B也要更新这条数据，检查数据是否有锁时发现存在着事务A创建的锁。则创建了属于自己的一个锁，其中等待状态为true。表示正在等待</li>
<li>事务A更新完后，释放锁，然后寻找到事务B对这条数据加锁了。此时就会把事务B的锁中的等待状态修改为false，然后唤醒事务B。</li>
</ol>
<h1 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h1><h2 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h2><span id="more"></span>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>又叫X锁，Exclude锁。当有一个事务加了独占锁后，其他事务再来更新当前数据，都是要加独占锁的，但是只能在独占锁后面等待。</p>
<h3 id="备注说明"><a href="#备注说明" class="headerlink" title="备注说明"></a>备注说明</h3><p>当多事务更新同一行数据时，其他事物是能够直接读取这行数据的，并不需要加锁。因为默认开启mvcc机制可以基于ReadView去undo log版本链中找到一个能够读取的版本。</p>
<h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>又叫S锁。语法是：SELECT * FROM TABLE <strong>LOCK IN SHARE MODE</strong>；意思是在查询的时候对一行数据加共享锁。</p>
<h3 id="备注说明-1"><a href="#备注说明-1" class="headerlink" title="备注说明"></a>备注说明</h3><p>当一行数据加了X锁后，S锁是无法添加的，因为两者互斥。<br>当一行数据加了S锁后，其他事物也能添加S锁，因为S锁不互斥。</p>
<h3 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h3><p>查询操作通过<strong>LOCK IN SHARE</strong> 添加共享锁；<br>查询操作通过<strong>FOR UPDATE</strong> 添加互斥锁；</p>
<h1 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>LOCK TABLES xxx READ；加表级共享锁（很少用）<br>LOCK TABLES xxx WRITE；加表级独占锁（很少用）        </p>
<h2 id="其他加锁的操作"><a href="#其他加锁的操作" class="headerlink" title="其他加锁的操作"></a>其他加锁的操作</h2><ol>
<li>如果有事务在表里执行增删改操作，就会在行级加独占锁。还会在表级加一个<strong>意向独占锁</strong>。</li>
<li>如果事务在表里执行查询操作，那么会在表级添加一个<strong>意向共享锁</strong>。</li>
</ol>
<h2 id="备注说明-2"><a href="#备注说明-2" class="headerlink" title="备注说明"></a>备注说明</h2><ol>
<li>意向独占锁和意向共享锁不互斥</li>
</ol>
<h1 id="互斥关系"><a href="#互斥关系" class="headerlink" title="互斥关系"></a>互斥关系</h1><table>
<thead>
<tr>
<th>锁类型</th>
<th>独占锁</th>
<th>意向独占锁</th>
<th>共享锁</th>
<th>意向共享锁</th>
</tr>
</thead>
<tbody><tr>
<td>独占锁</td>
<td>互斥</td>
<td>互斥</td>
<td>互斥</td>
<td>互斥</td>
</tr>
<tr>
<td>意向独占锁</td>
<td>互斥</td>
<td><strong>不互斥</strong></td>
<td>互斥</td>
<td><strong>不互斥</strong></td>
</tr>
<tr>
<td>共享锁</td>
<td>互斥</td>
<td>互斥</td>
<td><strong>不互斥</strong></td>
<td><strong>不互斥</strong></td>
</tr>
<tr>
<td>意向共享锁</td>
<td>互斥</td>
<td><strong>不互斥</strong></td>
<td><strong>不互斥</strong></td>
<td><strong>不互斥</strong></td>
</tr>
</tbody></table>
<blockquote>
<ol>
<li><strong>独占锁与其他锁都互斥</strong></li>
<li>意向XX锁与意向XX锁之间不互斥</li>
<li>共享锁，意向共享锁之间不互斥</li>
<li>意向共享锁只与独占锁互斥</li>
</ol>
</blockquote>
<h1 id="不确定性的性能抖动"><a href="#不确定性的性能抖动" class="headerlink" title="不确定性的性能抖动"></a>不确定性的性能抖动</h1><h2 id="脏页刷盘"><a href="#脏页刷盘" class="headerlink" title="脏页刷盘"></a>脏页刷盘</h2><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>当一个查询语句，加载了大量的数据到缓存页中，导致内存中大量的缓存页被淘汰然后刷回磁盘。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>减少缓存页刷盘的频率：增加buffer pool分配的内存空间</p>
<h2 id="Redolog刷盘"><a href="#Redolog刷盘" class="headerlink" title="Redolog刷盘"></a>Redolog刷盘</h2><h3 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h3><p>redolog不断的写入，当日志文件写满了，就会对第一个日志文件进行覆盖写入，此时如果<br>第一个日志文件中的一些redolog<br>对应的内存里的缓存页的数据<br>如果还没有被刷回磁盘的话。也会触发脏页回盘的过程。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>提升缓存页刷盘的速度</p>
<ul>
<li>因为刷盘是典型的随机IO，所以要提升随机IO的性能，使用SSD固态硬盘。</li>
<li>配置参数innodb_io_capacity：采用多大的IO速率刷盘（每秒随机IO的次数）</li>
<li>配置参数innodb_flush_neighbors：刷盘时把缓存页临近的其他缓存页也刷盘，但是这样刷回的缓存页就会变多，如果是SSD，把这个设置为0就行。</li>
</ul>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 数据库事务隔离级别</title>
    <url>/2021/08/27/Mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h2 id="Mysql-——-通过例子理解事务的4种隔离级别"><a href="#Mysql-——-通过例子理解事务的4种隔离级别" class="headerlink" title="[Mysql] —— 通过例子理解事务的4种隔离级别"></a>[Mysql] —— 通过例子理解事务的4种隔离级别</h2><blockquote>
<p>第1级别：Read Uncommitted(读取未提交内容)</p>
</blockquote>
<blockquote>
<p>第2级别：Read Committed(读取提交内容)</p>
</blockquote>
<blockquote>
<p>第3级别：Repeatable Read(可重读)</p>
</blockquote>
<blockquote>
<p>第4级别：Serializable(可串行化)</p>
</blockquote>
<p><strong>SQL标准定义了4种隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。</strong></p>
<p><strong>低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。</strong></p>
<p><strong>首先，我们使用 test 数据库，新建 tx 表，并且如图所示打开两个窗口来操作同一个数据库：</strong></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/images/img-68.png"></h2><h4 id="第1级别：Read-Uncommitted-读取未提交内容"><a href="#第1级别：Read-Uncommitted-读取未提交内容" class="headerlink" title="第1级别：Read Uncommitted(读取未提交内容)"></a>第1级别：Read Uncommitted(读取未提交内容)</h4><p>(1)所有事务都可以看到其他未提交事务的执行结果</p>
<span id="more"></span>

<p>(2)本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少</p>
<p>(3)该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#首先，修改隔离级别</span><br><span class="line"><span class="keyword">set</span> tx_isolation<span class="operator">=</span><span class="string">&#x27;READ-UNCOMMITTED&#x27;</span>; </span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br><span class="line"># mysql <span class="number">8.0</span> 使用:</span><br><span class="line"># <span class="keyword">set</span> transaction_isolation<span class="operator">=</span><span class="string">&#x27;READ-UNCOMMITTED&#x27;</span>;</span><br><span class="line"># <span class="keyword">select</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx</span>_isolation   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> READ<span class="operator">-</span>UNCOMMITTED <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"></span><br><span class="line">#事务A：启动一个事务</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tx;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> num  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"></span><br><span class="line">#事务B：也启动一个事务(那么两个事务交叉了)</span><br><span class="line">       在事务B中执行更新语句，且不提交</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line">update tx <span class="keyword">set</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tx;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> num  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"></span><br><span class="line">#事务A：那么这时候事务A能看到这个更新了的数据吗?</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tx;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> num  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span>   <span class="comment">---&gt;可以看到！说明我们读到了事务B还没有提交的数据</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"></span><br><span class="line">#事务B：事务B回滚,仍然未提交</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tx;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> num  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"></span><br><span class="line">#事务A：在事务A里面看到的也是B没有提交的数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tx;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> num  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>      <span class="comment">---&gt;脏读意味着我在这个事务中(A中)，事务B虽然没有提交，但它任何一条数据变化，我都可以看到！</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="第2级别：Read-Committed-读取提交内容"><a href="#第2级别：Read-Committed-读取提交内容" class="headerlink" title="第2级别：Read Committed(读取提交内容)"></a>第2级别：Read Committed(读取提交内容)</h4><p>(1)这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）</p>
<p>(2)它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变</p>
<p>(3)这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。<br>     |——&gt;导致这种情况的原因可能有：(1)有一个交叉的事务有新的commit，导致了数据的改变;(2)一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#首先修改隔离级别</span><br><span class="line"><span class="keyword">set</span> tx_isolation<span class="operator">=</span><span class="string">&#x27;read-committed&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br><span class="line"># mysql <span class="number">8.0</span> 使用:</span><br><span class="line"># <span class="keyword">set</span> transaction_isolation<span class="operator">=</span><span class="string">&#x27;read-committed&#x27;</span>;</span><br><span class="line"># <span class="keyword">select</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx</span>_isolation <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> READ<span class="operator">-</span>COMMITTED <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"></span><br><span class="line">#事务A：启动一个事务</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tx;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> num  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"></span><br><span class="line">#事务B：也启动一个事务(那么两个事务交叉了)</span><br><span class="line">       在这事务中更新数据，且未提交</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line">update tx <span class="keyword">set</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tx;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> num  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"></span><br><span class="line">#事务A：这个时候我们在事务A中能看到数据的变化吗?</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tx; <span class="comment">---------------&gt;</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+                |</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> num  <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+                |</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span><span class="comment">---&gt;并不能看到！  |</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+                |——&gt;相同的select语句，结果却不一样</span></span><br><span class="line">                               <span class="operator">|</span></span><br><span class="line">#事务B：如果提交了事务B呢?         <span class="operator">|</span></span><br><span class="line"><span class="keyword">commit</span>;                        <span class="operator">|</span></span><br><span class="line">                               <span class="operator">|</span></span><br><span class="line">#事务A:                         <span class="operator">|</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tx; <span class="comment">---------------&gt;</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> num  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span><span class="comment">---&gt;因为事务B已经提交了，所以在A中我们看到了数据变化</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="第3级别：Repeatable-Read-可重读"><a href="#第3级别：Repeatable-Read-可重读" class="headerlink" title="第3级别：Repeatable Read(可重读)"></a>第3级别：Repeatable Read(可重读)</h4><p>(1)这是MySQL的默认事务隔离级别</p>
<p>(2)它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行</p>
<p>(3)此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行</p>
<p>(4)InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#首先，更改隔离级别</span><br><span class="line"><span class="keyword">set</span> tx_isolation<span class="operator">=</span><span class="string">&#x27;repeatable-read&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br><span class="line"># mysql <span class="number">8.0</span> 使用:</span><br><span class="line"># <span class="keyword">set</span> transaction_isolation<span class="operator">=</span><span class="string">&#x27;repeatable-read&#x27;</span>;</span><br><span class="line"># <span class="keyword">select</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx</span>_isolation  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"></span><br><span class="line">#事务A：启动一个事务</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tx;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> num  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"></span><br><span class="line">#事务B：开启一个新事务(那么这两个事务交叉了)</span><br><span class="line">       在事务B中更新数据，并提交</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line">update tx <span class="keyword">set</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tx;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> num  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line">#事务A：这时候即使事务B已经提交了,但A能不能看到数据变化？</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tx;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> num  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="comment">---&gt;还是看不到的！(这个级别2不一样，也说明级别3解决了不可重复读问题)</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"></span><br><span class="line">#事务A：只有当事务A也提交了，它才能够看到数据变化</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tx;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> num  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="第4级别：Serializable-可串行化"><a href="#第4级别：Serializable-可串行化" class="headerlink" title="第4级别：Serializable(可串行化)"></a>第4级别：Serializable(可串行化)</h4><p>(1)这是最高的隔离级别</p>
<p>(2)它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。</p>
<p><strong>(3)在这个级别，可能导致大量的超时现象和锁竞争</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#首先修改隔离界别</span><br><span class="line"><span class="keyword">set</span> tx_isolation<span class="operator">=</span><span class="string">&#x27;serializable&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br><span class="line"># mysql <span class="number">8.0</span> 使用:</span><br><span class="line"># <span class="keyword">set</span> transaction_isolation<span class="operator">=</span><span class="string">&#x27;serializable&#x27;</span>;</span><br><span class="line"># <span class="keyword">select</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx</span>_isolation <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> SERIALIZABLE   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"></span><br><span class="line">#事务A：开启一个新事务</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"></span><br><span class="line">#事务B：在A没有<span class="keyword">commit</span>之前，这个交叉事务是不能更改数据的</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> tx <span class="keyword">values</span>(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">update tx <span class="keyword">set</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MySql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot自动装配</title>
    <url>/2021/09/30/Spring-Boot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<p>转载自: <a href="https://mrbird.cc/deepin-springboot-autoconfig.html">https://mrbird.cc/deepin-springboot-autoconfig.html</a></p>
<h2 id="模式注解"><a href="#模式注解" class="headerlink" title="模式注解"></a>模式注解</h2><p>Stereotype Annotation俗称为模式注解，Spring中常见的模式注解有@Service，@Repository，@Controller等，它们都“派生”自@Component注解。我们都知道，凡是被@Component标注的类都会被Spring扫描并纳入到IOC容器中，那么由@Component派生的注解所标注的类也会被扫描到IOC容器中。下面我们主要通过自定义模式注解来了解@Component的“派生性”和“层次性”。</p>
<span id="more"></span>

<h3 id="Component-“派生性”"><a href="#Component-“派生性”" class="headerlink" title="@Component “派生性”"></a>@Component “派生性”</h3><p>新建一个Spring Boot工程，Spring Boot版本为2.1.0.RELEASE，artifactId为autoconfig，并引入spring-boot-starter-web依赖。项目结构如下所示:</p>
<p><img src="/images/img-75.png"></p>
<p>在com.example.demo下新建annotation包，然后创建一个FirstLevelService注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FirstLevelService &#123;</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解定义由@Service标注，查看@Service的源码会发现其被@Component注解标注，所以它们的层次关系为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">└─<span class="meta">@Component</span></span><br><span class="line">	└─<span class="meta">@Service</span></span><br><span class="line">		└─<span class="meta">@FirstLevelService</span></span><br></pre></td></tr></table></figure>
<p>即@FirstLevelService为@Component派生出来的模式注解，我们来测试一下被它标注的类是否能够被扫描到IOC容器中：</p>
<p>在com.example.demo下新建service包，然后创建一个TestService类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FirstLevelService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在com.example.demo下新建bootstrap包，然后创建一个ServiceBootStrap类，用于测试注册TestService并从IOC容器中获取它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.example.demo.service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">new</span> SpringApplicationBuilder(ServiceBootstrap.class)</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .run(args);</span><br><span class="line">        TestService testService = context.getBean(<span class="string">&quot;testService&quot;</span>, TestService.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;TestService Bean: &quot;</span> + testService);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行该类的main方法，控制台输出如下：<br><img src="/images/img-76.png"></p>
<h3 id="Component-“层次性”"><a href="#Component-“层次性”" class="headerlink" title="@Component “层次性”"></a><strong>@Component “层次性”</strong></h3><p>我们在com.example.demo.annotation路径下再创建一个SecondLevelService注解定义，该注解由上面的@FirstLevelService标注：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@FirstLevelService</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SecondLevelService &#123;</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候层次关系为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">└─<span class="meta">@Component</span></span><br><span class="line">   └─<span class="meta">@Service</span></span><br><span class="line">      └─<span class="meta">@FirstLevelService</span></span><br><span class="line">            └─<span class="meta">@SecondLevelService</span></span><br></pre></td></tr></table></figure>
<p>我们将TestService上的注解换成@SecondLevelService，然后再次运行ServiceBootStrap的main方法，输出如下：</p>
<p><img src="/images/img-77.png"></p>
<p>可见结果也是成功的</p>
<blockquote>
<p>这里有一点需要注意的是：**@Component注解只包含一个value属性定义，所以其“派生”的注解也只能包含一个value属性定义。 **</p>
</blockquote>
<h2 id="Enable模块驱动"><a href="#Enable模块驱动" class="headerlink" title="@Enable模块驱动"></a>@Enable模块驱动</h2><p>@Enable模块驱动在Spring Framework 3.1后开始支持。这里的模块通俗的来说就是一些为了实现某个功能的组件的集合。通过@Enable模块驱动，我们可以开启相应的模块功能。</p>
<p>@Enable模块驱动可以分为“注解驱动”和“接口编程”两种实现方式，下面逐一进行演示：</p>
<h3 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a><strong>注解驱动</strong></h3><p>Spring中，基于注解驱动的示例可以查看@EnableWebMvc源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该注解通过@Import导入一个配置类DelegatingWebMvcConfiguration：</p>
<p><img src="/images/img-78.png"></p>
<p>该配置类又继承自WebMvcConfigurationSupport，里面定义了一些Bean的声明。</p>
<blockquote>
<p>所以，基于注解驱动的@Enable模块驱动其实就是通过@Import来导入一个配置类，以此实现相应模块的组件注册，当这些组件注册到IOC容器中，这个模块对应的功能也就可以使用了。 **</p>
</blockquote>
<p>我们来定义一个基于注解驱动的@Enable模块驱动。</p>
<p>在com.example.demo下新建configuration包，然后创建一个HelloWorldConfiguration配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个配置类里定义了一个名为hello的Bean，内容为hello world。</p>
<p>在com.example.demo.annotation下创建一个EnableHelloWorld注解定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(HelloWorldConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHelloWorld &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该类的main方法，控制台输出如下：</p>
<p><img src="/images/img-79.png"></p>
<p>说明我们自定义的基于注解驱动的@EnableHelloWorld是可行的。</p>
<h3 id="接口编程"><a href="#接口编程" class="headerlink" title="接口编程"></a><strong>接口编程</strong></h3><p>除了使用上面这个方式外，我们还可以通过接口编程的方式来实现@Enable模块驱动。Spring中，基于接口编程方式的有@EnableCaching注解，查看其源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;CachingConfigurationSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCaching &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> 2147483647</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EnableCaching注解通过@Import导入了CachingConfigurationSelector类，该类间接实现了ImportSelector接口，在 深入学习Spring组件注册 中，我们曾介绍了可以通过ImportSelector来实现组件注册。</p>
<blockquote>
<p>所以通过接口编程实现@Enable模块驱动的本质是：通过@Import来导入接口ImportSelector实现类，该实现类里可以定义需要注册到IOC容器中的组件，以此实现相应模块对应组件的注册。</p>
</blockquote>
<p>接下来我们根据这个思路来自个实现一遍：</p>
<p>在com.example.demo下新建selector包，然后在该路径下新建一个HelloWorldImportSelector实现ImportSelector接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;HelloWorldConfiguration.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果看不懂上面这段代码含义的朋友可以阅读深入学习Spring组件注册一文。</p>
<p>接着我们修改 EnableHelloWorld：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(HelloWorldImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHelloWorld &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面导入的是HelloWorldImportSelector，而非HelloWorldConfiguration。</p>
<p>再次运行TestEnableBootstap的main方法，你会发现输出是一样的。</p>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>Spring Boot中的自动装配技术底层主要用到了下面这些技术:</p>
<ol>
<li><p>Spring 模式注解装配</p>
</li>
<li><p>Spring @Enable 模块装配</p>
</li>
<li><p>Spring 条件装配装（深入学习Spring组件注册中有介绍）</p>
</li>
<li><p>Spring 工厂加载机制</p>
</li>
</ol>
<p>Spring 工厂加载机制的实现类为SpringFactoriesLoader，查看其源码：</p>
<p><img src="/images/img-80.png"></p>
<p>该类的方法会读取META-INF目录下的spring.factories配置文件，我们查看spring-boot-autoconfigure-2.1.0.RELEASE.jar下的该文件：</p>
<p><img src="/images/img-81.png"></p>
<p><img src="/images/img-82.png"></p>
<p>当启动类被@EnableAutoConfiguration标注后，上面截图中的所有类Spring都会去扫描，看是否可以纳入到IOC容器中进行管理。</p>
<p>比如我们查看org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration的源码：</p>
<p><img src="/images/img-83.png"></p>
<p>可看到该类上标注了一些注解，其中@Configuration为模式注解，@EnableConfigurationProperties为模块装配技术，ConditionalOnClass为条件装配技术。这和我们上面列出的Spring Boot自动装配底层主要技术一致，所以我们可以根据这个思路来自定义一个自动装配实现。</p>
<p>新建一个配置类HelloWorldAutoConfiguration：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableHelloWorld</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;helloworld&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAutoConfiguration</span> </span>&#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后在resources目录下新建META-INF目录，并创建spring.factories文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.example.demo.configuration.HelloWorldAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>接着在配置文件application.properties中添加helloworld=true配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helloworld=true</span><br></pre></td></tr></table></figure>

<p>最后创建EnableAutoConfigurationBootstrap，测试下HelloWorldAutoConfiguration是否生效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableAutoConfigurationBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">new</span> SpringApplicationBuilder(EnableAutoConfigurationBootstrap.class)</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .run(args);</span><br><span class="line">        String hello = context.getBean(<span class="string">&quot;hello&quot;</span>, String.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Bean: &quot;</span> + hello);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行该main方法，控制台输出如下：<br><img src="/images/img-84.png"></p>
<p>说明我们自定义的自动装配已经成功了。</p>
<p>下面简要分析下代码的运行逻辑：</p>
<ol>
<li><p>Spring 的工厂加载机制会自动读取META-INF目录下spring.factories文件内容；</p>
</li>
<li><p>我们在spring.factories定义了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.example.demo.configuration.HelloWorldAutoConfiguration</span><br></pre></td></tr></table></figure>
<p>我们在测试类上使用了@EnableAutoConfiguration注解标注，那么HelloWorldAutoConfiguration就会被Spring扫描，看是否符合要求，如果符合则纳入到IOC容器中；</p>
</li>
<li><p>HelloWorldAutoConfiguration上的@ConditionalOnProperty的注解作用为：当配置文件中配置了helloworld=true（我们确实添加了这个配置，所以符合要求）则这个类符合扫描规则；@EnableHelloWorld注解是我们前面例子中自定义的模块驱动注解，其引入了hello这个Bean，所以IOC容器中便会存在hello这个Bean了；</p>
</li>
<li><p>通过上面的步骤，我们就可以通过上下文获取到hello这个Bean了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 事务传播原理及数据库事务操作原理</title>
    <url>/2021/08/20/Spring-%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E5%8E%9F%E7%90%86%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1. 什么是事务?"></a>1. 什么是事务?</h3><p>事务(Transaction) 是访问并可能更新数据库中各个数据的一个程序执行单元(unit).<br>特点: 事务是恢复和并发控制的基本单位, 事务应该具备四个属性<br><strong>原子性、一致性、隔离性、持久性</strong>.<br>这四个属性通常称为 <strong>ACID</strong> 特性.</p>
<h3 id="2-Spring-事务传播属性"><a href="#2-Spring-事务传播属性" class="headerlink" title="2. Spring 事务传播属性"></a>2. Spring 事务传播属性</h3><p><img src="/images/img-63.png" alt="Spring 事务传播属性"></p>
<h3 id="3-数据库事务的隔离级别"><a href="#3-数据库事务的隔离级别" class="headerlink" title="3. 数据库事务的隔离级别"></a>3. 数据库事务的隔离级别</h3><blockquote>
<p><a href="http://pdyun.cc:4000/2021/08/27/Mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/">http://pdyun.cc:4000/2021/08/27/Mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</a><br><img src="/images/img-64.png" alt="数据库的隔离级别"></p>
</blockquote>
<p><img src="/images/img-66.png"></p>
<h3 id="4-Spring-事务的隔离级别"><a href="#4-Spring-事务的隔离级别" class="headerlink" title="4. Spring 事务的隔离级别"></a>4. Spring 事务的隔离级别</h3><p><img src="/images/img-67.png" alt="Spring 事务的隔离级别"></p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 启动流程简述</title>
    <url>/2021/08/20/Spring-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>beanDefinitionMap  -&gt; 用来存储 BeanDefinition(Bean 的配置信息)<br>factoryBeanObjectCache  -&gt;  用来存储原生 Bean 对象的Map, 指反射创建出的实际对象<br>factoryBeanInstanceCache  -&gt;  用来存储 BeanWrapper 的Map, 指原生 Bean 的包装类  </p>
</blockquote>
<h3 id="Spring-启动流程简述"><a href="#Spring-启动流程简述" class="headerlink" title="Spring 启动流程简述"></a>Spring 启动流程简述</h3><h4 id="一-配置阶段"><a href="#一-配置阶段" class="headerlink" title="一. 配置阶段"></a>一. 配置阶段</h4><ul>
<li>web.xml<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DispatcherServlet 路径</span><br><span class="line">设定 init-param ( contextConfigLocation = classPath:application.xml )</span><br><span class="line">设定 url-pattern ( /* )</span><br><span class="line">配置 Annotation 等</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>

<ul>
<li>appication.xml<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置 包扫描路径、Bean定义、视图解析配置等......</span><br></pre></td></tr></table></figure></li>
<li>……</li>
</ul>
<h4 id="二-初始化阶段"><a href="#二-初始化阶段" class="headerlink" title="二. 初始化阶段"></a>二. 初始化阶段</h4><ul>
<li><p>Servlet.init()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring 是 servlet 编程模型, 容器启动时会调用 servlet 的 init() 方法, </span><br><span class="line">在该方法中会读取配置进行 IoC 容器及 MVC 组件的初始化.</span><br></pre></td></tr></table></figure></li>
<li><p>IoC 部分 (定位、加载、注册) </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化 IoC 容器</span><br><span class="line"> 1. 通过 web.xml 的配置定位 application .xml配置文件. </span><br><span class="line"> 2. 使用 BeanDefinitionReader 读取配置文件, 扫描类并封装成 BeanDefinition</span><br><span class="line"> 3. 创建 BeanFatory, 将 *beanDefinition 注册到 DefalutListableBeanFactory 的 beanDefinitionMap 中</span><br></pre></td></tr></table></figure></li>
<li><p>DI 、 AOP 部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. 初始化非延迟加载的 bean</span><br><span class="line">0). 标记 bean 为创建中      </span><br><span class="line">1). 通过反射 new 出 bean 对象, 封装成 BeanWrapper 对象      </span><br><span class="line">2). 如果 bean 为单例且支持循环依赖则生成三级缓存 singletonFactories, 可提前暴露 bean      </span><br><span class="line">3). 填充bean属性，解决属性依赖      </span><br><span class="line">4). 初始化bean的各个Aware接口(各个Aware接口能让bean获取到部分属性: ApplicationContextAware-能获取到ApplicationContex; BeanFactoryAware 能获取到 BeanFactory) 并执行各类 bean 的后处理器, 执行初始化方法, 如果有 AOP 配置需要生成 AOP 代理对象 </span><br><span class="line">5). 如果存在循环依赖，解决之 – 这里有点问题，这一步是如果之前解决了aop循环依赖，则缓存中放置了提前生成的代理对象，然后使用原始bean继续执行初始化，所以需要再返回最终bean前，把原始bean置换为代理对象返回。      </span><br><span class="line">6). 此时 bean 已经可以使用, 将 bean 放入一级缓存 singletonObjects , 移除创建中标记以及二三级缓存</span><br></pre></td></tr></table></figure></li>
<li><p>MVC 部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. 初始化 MVC 九大组件</span><br><span class="line">// 1). 初始化文件上传解析器</span><br><span class="line">initMultipartResolver(context);</span><br><span class="line">// 2). 初始化本地语言环境</span><br><span class="line">initLocaleResolver(context);</span><br><span class="line">// 3). 初始化模板处理器</span><br><span class="line">initThemeResolver(context);</span><br><span class="line">// 4). 初始化 HandlerMapping 组件</span><br><span class="line">initHandlerMappings(context);</span><br><span class="line">// 5). 初始化参数适配器</span><br><span class="line">initHandlerAdapters(context);</span><br><span class="line">// 6). 初始化异常拦截器</span><br><span class="line">initHandlerExceptionResolvers(context);</span><br><span class="line">// 7). 初始化视图预处理器</span><br><span class="line">initRequestToViewNameTranslator(context);</span><br><span class="line">// 8). 初始化视图解析器</span><br><span class="line">initViewResolvers(context);</span><br><span class="line">// 9). 初始化 FlashMap 管理器</span><br><span class="line">( 为了解决请求转发和重定向过程中参数的丢失问题: redirect-&gt;重定向, request 参数会丢失 ; forward-&gt;转发, 自动将 request 参数系诶带到下一个请求 )</span><br><span class="line">initFlashMapManager(context);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="三-运行阶段"><a href="#三-运行阶段" class="headerlink" title="三. 运行阶段"></a>三. 运行阶段</h4><blockquote>
<ol>
<li>从页面点击按钮或者 url 访问资源请求会先到 DispatcherServlet 的 doDispatch() 方法, 该方法会从 HandlerMapping 中通过 url 去匹配对应的控制器及方法  </li>
<li>通过参数解析器解析参数并反射执行方法, 返回一个 ModelAndView  </li>
<li>通过视图解析器解析 ModelAndView, 决定返回页面或者输出数据  </li>
<li>前端根据对应结果来展示</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 基础认知与技术架构</title>
    <url>/2021/08/19/Spring-%E5%9F%BA%E7%A1%80%E8%AE%A4%E7%9F%A5%E4%B8%8E%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><blockquote>
<p>Spring 是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。 </p>
</blockquote>
<blockquote>
<p>Spring最根本的使命是解决企业级应用开发的复杂性，即简化Java开发。</p>
</blockquote>
<h3 id="1-Spring-简化开发的四个基本策略"><a href="#1-Spring-简化开发的四个基本策略" class="headerlink" title="1. Spring 简化开发的四个基本策略"></a>1. Spring 简化开发的四个基本策略</h3><blockquote>
<ol>
<li>基于POJO 的轻量级和最小侵入性编程.</li>
<li>通过依赖注入和面向接口松耦合.</li>
<li>基于切面和惯性进行声明式编程.</li>
<li>通过切面和模板减少样版式代码.</li>
</ol>
</blockquote>
<span id="more"></span>

<h3 id="2-Spring-中的编程思想"><a href="#2-Spring-中的编程思想" class="headerlink" title="2. Spring 中的编程思想"></a>2. Spring 中的编程思想</h3><table>
<thead>
<tr>
<th>Spring思想</th>
<th>应用场景 (特点)</th>
<th>一句话归纳</th>
</tr>
</thead>
<tbody><tr>
<td><strong>OOP</strong></td>
<td>Object Oriented Programming (面向对象编程) 用程序归纳总结生活中一切事物</td>
<td>封装、继承、多态.</td>
</tr>
<tr>
<td><strong>BOP</strong></td>
<td>Bean Oriented Programming (面向Bean编程) 面向Bean (普通Java类) 设计程序, 解放程序员.</td>
<td>一切从Bean开始.</td>
</tr>
<tr>
<td><strong>AOP</strong></td>
<td>Aspect Oriented Programming (面向切面编程) 找出多个类中有一定规律的代码, 开发时拆开, 应运行时再合并. 面向切面编程, 及面向规则编程.</td>
<td>解耦, 专人做专事.</td>
</tr>
<tr>
<td><strong>IoC</strong></td>
<td>Inversion of Control (控制反转) 将new对象的动作交给Spring管理, 并由Spring保存已创建的对象 (IOC容器).</td>
<td>转交控制权(即控制权反转).</td>
</tr>
<tr>
<td><strong>DI/D</strong>L</td>
<td>Dependency Injection (依赖注入) 或者Dependency Lookup (依赖查找) , Spring不仅保存自己创建的对象, 而且保存对象与对象之间的关系. 注入即赋值, 主要三种方式 — 构造方法、set方法、直接赋值.</td>
<td>自动赋值.</td>
</tr>
</tbody></table>
<h3 id="3-Spring-注解编程演化"><a href="#3-Spring-注解编程演化" class="headerlink" title="3. Spring 注解编程演化"></a>3. Spring 注解编程演化</h3><p>V1.X | V2.0 | V2.5 | V3.X | V4.X | V5.X<br>— | — | — | — | — | — | —<br><strong>注解驱动启蒙时代</strong> | <strong>注解驱动过渡时代</strong> | <strong>引入新的骨架式Annotation</strong> | <strong>注解驱动黄金时代</strong> | <strong>注解驱动完善时代</strong> | <strong>注解驱动成熟时代</strong></p>
<h3 id="4-Spring-模块结构"><a href="#4-Spring-模块结构" class="headerlink" title="4. Spring 模块结构"></a>4. Spring 模块结构</h3><blockquote>
<p>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access/Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中。 </p>
</blockquote>
<p><img src="/images/img-13.png" alt="Spring 模块结构"></p>
<h3 id="5-Spring-系统架构模块功能介绍"><a href="#5-Spring-系统架构模块功能介绍" class="headerlink" title="5. Spring 系统架构模块功能介绍"></a>5. Spring 系统架构模块功能介绍</h3><h4 id="Spring-核心模块"><a href="#Spring-核心模块" class="headerlink" title="Spring 核心模块"></a>Spring 核心模块</h4><table>
<thead>
<tr>
<th>模块名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-core</strong></td>
<td>IoC控制反转与DI依赖注入的最基本实现</td>
</tr>
<tr>
<td><strong>spring-beans</strong></td>
<td>Bean工厂与Bean的装配</td>
</tr>
<tr>
<td><strong>spring-context</strong></td>
<td>定义基础的Spring的Context上下文即IoC容器</td>
</tr>
<tr>
<td><strong>spring-context-support</strong></td>
<td>对Spring IoC的扩展支持, 以及IoC子容器</td>
</tr>
<tr>
<td><strong>spring-context-indexer</strong></td>
<td>Spring的类管理组件和Classpath扫描</td>
</tr>
<tr>
<td><strong>spring-expression</strong></td>
<td>Spring表达式语言</td>
</tr>
</tbody></table>
<hr>
<h5 id="Spring-面向切面编程模块"><a href="#Spring-面向切面编程模块" class="headerlink" title="Spring 面向切面编程模块"></a>Spring 面向切面编程模块</h5><table>
<thead>
<tr>
<th>模块名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-aop</strong></td>
<td>面向切面编程的引用模块, 整合Asm, CGLib、JDKProxy</td>
</tr>
<tr>
<td><strong>spring-aspects</strong></td>
<td>继承AspectJ, AOP应用框架</td>
</tr>
<tr>
<td><strong>spring-instrument</strong></td>
<td>动态Class Loading模块</td>
</tr>
</tbody></table>
<hr>
<h5 id="Spring-数据访问与继承模块"><a href="#Spring-数据访问与继承模块" class="headerlink" title="Spring 数据访问与继承模块"></a>Spring 数据访问与继承模块</h5><table>
<thead>
<tr>
<th>模块名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-jdbc</strong></td>
<td>Spring 提供的JDBC抽象框架的组要实现模块, 用于简化 Spring JDBC 操作</td>
</tr>
<tr>
<td><strong>spring-tx</strong></td>
<td>Spring JDBC 事务控制实现模块</td>
</tr>
<tr>
<td><strong>spring-orm</strong></td>
<td>主要继承 Hibernate, Java Persitence API (JPA) 和 Java Data Object (JDO)</td>
</tr>
<tr>
<td><strong>spring-oxm</strong></td>
<td>将Java对象映射成XML数据, 或者将XML数据映射成Java对象</td>
</tr>
<tr>
<td><strong>spring-jms</strong></td>
<td>Java Messaging Service 能够发送和接收信息</td>
</tr>
</tbody></table>
<hr>
<h5 id="Spring-Web-模块"><a href="#Spring-Web-模块" class="headerlink" title="Spring Web 模块"></a>Spring Web 模块</h5><table>
<thead>
<tr>
<th>模块名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-web</strong></td>
<td>提供了最基础Web支持, 主要建立于核心容器之上, 通过 Servlet 或者 Listeners 来初始化 IoC 容器</td>
</tr>
<tr>
<td><strong>spring-webmvc</strong></td>
<td>实现了 Spring-MVC (model-view-controller) 的 Web 应用</td>
</tr>
<tr>
<td><strong>spring-websokect</strong></td>
<td>主要是与 Web 前端的全双工通讯的协议</td>
</tr>
<tr>
<td><strong>spring-webflux</strong></td>
<td>一个新的非阻塞函数式 Reactive Web 框架, 可以用来建立异步的. 非阻塞, 事件驱动的服务</td>
</tr>
</tbody></table>
<hr>
<h5 id="Spring-通信报文-模块"><a href="#Spring-通信报文-模块" class="headerlink" title="Spring 通信报文 模块"></a>Spring 通信报文 模块</h5><table>
<thead>
<tr>
<th>模块名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-messaging</strong></td>
<td>从 Spring4 开始新加入的一个模块, 主要职责是为 Spring 框架继承一些基础的报文传输应用</td>
</tr>
</tbody></table>
<hr>
<h5 id="Spring-集成测试-模块"><a href="#Spring-集成测试-模块" class="headerlink" title="Spring 集成测试 模块"></a>Spring 集成测试 模块</h5><table>
<thead>
<tr>
<th>模块名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-test</strong></td>
<td>主要为测试提供支持的</td>
</tr>
</tbody></table>
<hr>
<h5 id="Spring-集成兼容-模块"><a href="#Spring-集成兼容-模块" class="headerlink" title="Spring 集成兼容 模块"></a>Spring 集成兼容 模块</h5><table>
<thead>
<tr>
<th>模块名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-framwork-bom</strong></td>
<td>Bill of Materials. 解除 Spring 的不同模块依赖版本不同问题</td>
</tr>
</tbody></table>
<h3 id="6-Spring-模块之依赖关系图"><a href="#6-Spring-模块之依赖关系图" class="headerlink" title="6. Spring 模块之依赖关系图"></a>6. Spring 模块之依赖关系图</h3><p><img src="/images/img-14.png" alt="模块依赖关系"></p>
<h3 id="7-版本命名规则"><a href="#7-版本命名规则" class="headerlink" title="7. 版本命名规则"></a>7. 版本命名规则</h3><h4 id="Spring-版本命名规则"><a href="#Spring-版本命名规则" class="headerlink" title="Spring 版本命名规则"></a>Spring 版本命名规则</h4><blockquote>
<p><img src="/images/img-15.png" alt="Spring 版本命名规则"></p>
</blockquote>
<h4 id="其他常见软件版本命名规则"><a href="#其他常见软件版本命名规则" class="headerlink" title="其他常见软件版本命名规则"></a>其他常见软件版本命名规则</h4><blockquote>
<p><img src="/images/img-16.png" alt="upload successful"></p>
</blockquote>
<h4 id="语义化版本命名通用规则"><a href="#语义化版本命名通用规则" class="headerlink" title="语义化版本命名通用规则"></a>语义化版本命名通用规则</h4><blockquote>
<p><img src="/images/img-17.png" alt="upload successful"></p>
</blockquote>
<h4 id="商业软件中常见的修饰词"><a href="#商业软件中常见的修饰词" class="headerlink" title="商业软件中常见的修饰词"></a>商业软件中常见的修饰词</h4><blockquote>
<p><img src="/images/img-18.png" alt="upload successful"></p>
</blockquote>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 循环依赖-AOP详解</title>
    <url>/2022/02/24/Spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96-AOP%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<!DOCTYPE html>
<html>
<head>
<meta  charset=utf-8"/>
    <style>
        mark {
            background-color:#f0e0ed; 
            color:#c7254e;
          }
    </style>
                     

<p>该文章引用自: <a href="https://blog.csdn.net/chaitoudaren/article/details/105060882">《当Spring AOP遇上循环依赖》</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>问：Spring如何解决<mark>循环依赖</mark>？</p>
<p>答：Spring通过<mark>提前曝光</mark>机制，利用<mark>三级缓存</mark>解决<mark>循环依赖</mark>（这原理还是挺简单的，参考：三级缓存、图解循环依赖原理）</p>
<hr>
<p>问：只用一级缓存可以能解决问题吗?</p>
<p>答：<mark>不能</mark>. 在整个处理中, 缓存中放的<mark>是成品和半成品对象</mark>, 如果只使用一级缓存, 成品和半成品对象都存在一个缓存, <mark>有可能获取Bean的时候会获取到半成品对象</mark>, 此时的对象是无法使用的, 因此至少都需要一级缓存和二级缓存把成品对象和半成品对象分开.</p>
<hr>
<p>再问：<mark>只使用二级缓存</mark>能解决循环依赖吗? 为什么需要<mark>三级缓存</mark>？</p>
<p>答：Spring通过<mark>提前曝光</mark>，直接曝光到<mark>二级缓存</mark>已经可以解决循环依赖问题了; 使用<mark>三级缓存的本质在于AOP代理问题</mark>, 因为三级缓存中存放的是<mark>ObjectFactory(也可以说是放的一个lambda表达式)</mark>,存在AOP的时候,就会调用它来完成代理对象的覆盖过程.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br></pre></td></tr></table></figure>

<hr>
<p>再细问：如果循环依赖的时候，所有类又都需要<mark>Spring AOP</mark>自动代理，那Spring如何提前曝光？曝光的是<mark>原始bean</mark>还是<mark>代理后的bean</mark>？</p>
<p>这些问题算是Spring源码的压轴题了，如果这些问题都弄明白，恭喜你顺利结业Spring源码了。就单单对Spring这一块的理解，不夸张的说可以达到阿里水准了</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>进入正题，在Spring<mark>创建Bean</mark>的核心代码<mark>doGetBean</mark>中，在<mark>实例化bean</mark>之前，会先尝试从<mark>三级缓存</mark>获取bean，这也是Spring解决循环依赖的开始</p>
<h2 id="一-缓存中获取bean"><a href="#一-缓存中获取bean" class="headerlink" title="(一) 缓存中获取bean"></a>(一) 缓存中获取bean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractBeanFactory.java</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">		Object bean;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 尝试从缓存中获取bean</span></span><br><span class="line">		Object sharedInstance = getSingleton(beanName);</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, Boolean allowEarlyReference)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从一级缓存获取，key=beanName value=bean</span></span><br><span class="line">  Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">  <span class="keyword">if</span> (singletonObject &lt;mark&gt; <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">      <span class="comment">// 从二级缓存获取，key=beanName value=bean</span></span><br><span class="line">      singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">      <span class="comment">// 是否允许循环引用</span></span><br><span class="line">      <span class="keyword">if</span> (singletonObject &lt;mark&gt; <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 三级缓存获取，key=beanName value=objectFactory，objectFactory中存储getObject()方法用于获取提前曝光的实例</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 而为什么不直接将实例缓存到二级缓存，而要多此一举将实例先封装到objectFactory中？</span></span><br><span class="line"><span class="comment">           * 主要关键点在getObject()方法并非直接返回实例，而是对实例又使用</span></span><br><span class="line"><span class="comment">           * SmartInstantiationAwareBeanPostProcessor的getEarlyBeanReference方法对bean进行处理</span></span><br><span class="line"><span class="comment">           *</span></span><br><span class="line"><span class="comment">           * 也就是说，当spring中存在该后置处理器，所有的单例bean在实例化后都会被进行提前曝光到三级缓存中，</span></span><br><span class="line"><span class="comment">           * 但是并不是所有的bean都存在循环依赖，也就是三级缓存到二级缓存的步骤不一定都会被执行，有可能曝光后直接创建完成，没被提前引用过，</span></span><br><span class="line"><span class="comment">           * 就直接被加入到一级缓存中。因此可以确保只有提前曝光且被引用的bean才会进行该后置处理</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 通过getObject()方法获取bean，通过此方法获取到的实例不单单是提前曝光出来的实例，</span></span><br><span class="line"><span class="comment">             * 它还经过了SmartInstantiationAwareBeanPostProcessor的getEarlyBeanReference方法处理过。</span></span><br><span class="line"><span class="comment">             * 这也正是三级缓存存在的意义，可以通过重写该后置处理器对提前曝光的实例，在被提前引用时进行一些操作</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">          singletonObject = singletonFactory.getObject();</span><br><span class="line">          <span class="comment">// 将三级缓存生产的bean放入二级缓存中</span></span><br><span class="line">          <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">          <span class="comment">// 删除三级缓存</span></span><br><span class="line">          <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>三级缓存分别是：</strong></p>
<ul>
<li><mark>singletonObject</mark>：一级缓存，该缓存<mark>key = beanName, value = bean</mark>;这里的bean是已经创建完成的，该bean经历过实例化-&gt;属性填充-&gt;初始化以及各类的后置处理。因此，一旦需要获取bean时，我们第一时间就会寻找一级缓存</li>
<li><mark>earlySingletonObjects</mark>：二级缓存，该缓存<mark>key = beanName, value = bean</mark>;这里跟一级缓存的区别在于，该缓存所获取到的bean是提前曝光出来的，是还没创建完成的。也就是说获取到的bean只能确保已经进行了实例化，但是属性填充跟初始化肯定还没有做完，因此该bean还没创建完成，仅仅能作为指针提前曝光，被其他bean所引用</li>
<li></li>
<li><mark>singletonFactories</mark>：三级缓存，该缓存<mark>key = beanName, value = beanFactory</mark>;在bean实例化完之后，属性填充以及初始化之前，如果允许提前曝光，spring会将实例化后的bean提前曝光，也就是把该bean转换成<mark>beanFactory</mark>并加入到三级缓存。在需要引用提前曝光对象时再通过<mark>singletonFactory.getObject()</mark>获取。</li>
</ul>
<p>这里抛出问题，如果我们直接将提前曝光的对象放到二级缓存<mark>earlySingletonObjects</mark>，Spring循环依赖时直接取就可以解决循环依赖了，为什么还要三级缓存<mark>singletonFactory</mark>然后再通过<mark>getObject()</mark>来获取呢？这不是多此一举？</p>
<h2 id="二-三级缓存的添加"><a href="#二-三级缓存的添加" class="headerlink" title="(二) 三级缓存的添加"></a>(二) 三级缓存的添加</h2><p>我们回到添加三级缓存，添加<mark>SingletonFactory</mark>的地方，看看<mark>getObject()</mark>到底做了什么操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.addSingletonFactory(beanName, () -&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到在返回<mark>getObject()</mark>时，多做了一步<mark>getEarlyBeanReference</mark>操作，这步操作是<mark>BeanPostProcess</mark>的一种，也就是给子类重写的一个后处理器，目的是用于<mark>被提前引用</mark>时进行拓展。即：曝光的时候并不调用该后置处理器，只有曝光，且被提前引用的时候才调用，确保了<mark>被提前引用</mark>这个时机触发。</p>
<h2 id="三-提前曝光代理earlyProxyReferences"><a href="#三-提前曝光代理earlyProxyReferences" class="headerlink" title="(三) 提前曝光代理earlyProxyReferences"></a>(三) 提前曝光代理earlyProxyReferences</h2><p>因此所有的重点都落到了<mark>getEarlyBeanReference</mark>上，<mark>getEarlyBeanReference</mark>方法是<mark>SmartInstantiationAwareBeanPostProcessor</mark>所规定的接口。再通过UML的类图查看实现类，仅有<mark>AbstractAutoProxyCreator</mark>进行了实现。也就是说，除了用户在子类重写，否则仅有<mark>AbstractAutoProxyCreator</mark>一种情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractAutoProxyCreator.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 缓存当前bean，表示该bean被提前代理了</span></span><br><span class="line">	Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">	<span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">	<span class="comment">// 对bean进行提前Spring AOP代理</span></span><br><span class="line">	<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>wrapIfNecessary</mark>是用于Spring AOP自动代理的。Spring将当前bean缓存到<mark>earlyProxyReferences</mark>中标识<mark>提前曝光的bean</mark>在被提前引用之前，然后进行了Spring AOP代理。</p>
<p>但是经过Spring AOP代理后的bean就已经不再是原来的bean了，经过代理后的bean是一个全新的bean，也就是说代理前后的2个bean连内存地址都不一样了。这时将再引出新的问题：<strong>B提前引用A将引用到A的代理，这是符合常理的，但是最原始的bean A在B完成创建后将继续创建，那么Spring Ioc最后返回的Bean是Bean A呢还是经过代理后的Bean呢？</strong></p>
<p>这个问题我们得回到Spring AOP代理，Spring AOP代理时机有2个：</p>
<ol>
<li>当自定义了<mark>TargetSource</mark>，则在bean实例化前完成Spring AOP代理并且直接发生短路操作，返回bean</li>
<li>正常情况下，都是在bean初始化后进行Spring AOP代理</li>
<li>如果要加上今天说的提前曝光代理，<mark>getEarlyBeanReference</mark>可以说3种</li>
</ol>
<p>第一种情况就没什么好探究的了，直接短路了，根本没有后续操作。而我们关心的是第二种情况，在Spring初始化后置处理器中发生的Spring AOP代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Object result = existingBean;</span><br><span class="line">	<span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">		<span class="comment">// 调用bean初始化后置处理器处理</span></span><br><span class="line">		Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">		<span class="keyword">if</span> (current &lt;mark&gt; <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		result = current;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractAutoProxyCreator.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 获取缓存key</span></span><br><span class="line">		Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		<span class="comment">// 查看该bean是否被Spring AOP提前代理！而缓存的是原始的bean，因此如果bean被提前代理过，这此处会跳过</span></span><br><span class="line">		<span class="comment">// 如果bean没有被提前代理过，则进入AOP代理</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">			<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>earlyProxyReferences</mark>是不是有点熟悉，是的，这就是我们刚刚提前曝光并且进行Spring AOP提前代理时缓存的原始bean，如果缓存的原始bean跟当前的bean是一至的，那么就不进行Spring AOP代理了！返回原始的bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 4. 填充属性</span></span><br><span class="line"><span class="comment">			 * 如果<span class="doctag">@Autowired</span>注解属性，则在上方完成解析后，在这里完成注入</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * <span class="doctag">@Autowired</span></span></span><br><span class="line"><span class="comment">			 * private Inner inner;</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">			<span class="comment">// 5. 初始化</span></span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">				<span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">						mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 6. 存在提前曝光情况下</span></span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="comment">// earlySingletonReference：二级缓存，缓存的是经过提前曝光提前Spring AOP代理的bean</span></span><br><span class="line">			Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// exposedObject跟bean一样，说明初始化操作没用应用Initialization后置处理器(指AOP操作)改变exposedObject</span></span><br><span class="line">				<span class="comment">// 主要是因为exposedObject如果提前代理过，就会跳过Spring AOP代理，所以exposedObject没被改变，也就等于bean了</span></span><br><span class="line">				<span class="keyword">if</span> (exposedObject &lt;mark&gt; bean) &#123;</span><br><span class="line">					<span class="comment">// 将二级缓存中的提前AOP代理的bean赋值给exposedObject，并返回</span></span><br><span class="line">					exposedObject = earlySingletonReference;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 引用都不相等了，也就是现在的bean已经不是当时提前曝光的bean了</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">					<span class="comment">// dependentBeans也就是B, C, D</span></span><br><span class="line">					String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">					Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">					<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">						<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">							actualDependentBeans.add(dependentBean);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 被依赖检测异常</span></span><br><span class="line">					<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">								<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">								<span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">								<span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">								<span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">								<span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候我们需要理清一下3个变量</p>
<ol>
<li><mark>earlySingletonReference</mark>：二级缓存，缓存的是经过提前曝光提前AOP代理的bean</li>
<li><mark>bean</mark>：这个就是经过了实例化、填充、初始化的bean</li>
<li><mark>exposedObject</mark>：这个是经过<mark>了AbstractAutoProxyCreator</mark>的<mark>postProcessAfterInitialization</mark>处理过后的bean，但是在其中因为发现当前bean已经被<mark>earlyProxyReferences</mark>缓存，所以并没有进行AOP处理，而是直接跳过，因此还是跟第2点一样的bean</li>
</ol>
<p>理清这3个变量以后，就会发现，<mark>exposedObject = earlySingletonReference</mark>;<br>AOP代理过的Bean赋值给<mark>了exposedObject</mark>并返回，这时候用户拿到的bean就是AOP代理过后的bean了，一切皆大欢喜了。</p>
<p>但是中间还有一个问题！提前曝光的bean在提前引用时被Spring AOP代理了，但是此时的bean只是经过了实例化的bean，还没有进行@Autowire的注入啊！<mark>也就是说此时代理的bean里面自动注入的属性是空的！<mark></p>
<h2 id="四-提前AOP代理对象的-属性填充、初始化"><a href="#四-提前AOP代理对象的-属性填充、初始化" class="headerlink" title="(四) 提前AOP代理对象的 属性填充、初始化"></a>(四) 提前AOP代理对象的 属性填充、初始化</h2><p>是的，确实在<mark>Spring AOP提前代理</mark>后没有经过属性<mark>填充</mark>和<mark>初始化</mark>。那么这个代理又是如何保证依赖属性的注入的呢？答案回到Spring AOP最早最早讲的<a href="https://blog.csdn.net/chaitoudaren/article/details/104833279">JDK动态代理</a>上找，JDK动态代理时，会将<mark>目标对象target</mark>保存在最后生成的代理$proxy中，当调用$proxy方法时会<mark>回调h.invoke</mark>，而<mark>h.invoke</mark>又会回调<mark>目标对象target</mark>的原始方法。因此，其实在Spring AOP动态代理时，<mark>原始bean</mark>已经被保存在提前曝光代理中了。而后<mark>原始Bean</mark>继续完成<mark>属性填充</mark>和<mark>初始化</mark>操作。因为AOP代理<mark>$proxy</mark>中保存着<mark>traget</mark>也就是是原始bean的引用，因此后续<mark>原始bean</mark>的完善，也就相当于Spring AOP中的<mark>target</mark>的完善，这样就保证了Spring AOP的<mark>属性填充</mark>与<mark>初始化</mark>了！</p>
<h2 id="五-循环依赖遇上Spring-AOP-图解"><a href="#五-循环依赖遇上Spring-AOP-图解" class="headerlink" title="(五) 循环依赖遇上Spring AOP 图解"></a>(五) 循环依赖遇上Spring AOP 图解</h2><p>为了帮助大家理解，这里灵魂画手画张流程图帮助大家理解</p>
<p>首先又bean A，bean B，他们循环依赖注入，同时bean A还需要被Spring AOP代理，例如事务管理或者日志之类的操作。</p>
<p>原始bean A，bean B图中用a，b表示，而代理后的bean A我们用aop.a表示</p>
<p><img src="/images/img-89.png"></p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 循环依赖及三级缓存</title>
    <url>/2021/08/20/Spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%8F%8A%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h3 id="Spring-循环依赖及三级缓存"><a href="#Spring-循环依赖及三级缓存" class="headerlink" title="Spring 循环依赖及三级缓存"></a>Spring 循环依赖及三级缓存</h3><ul>
<li><p>Spring 在启动过程中，使用到了三个map，称为三级缓存。<br><img src="/images/img-19.png" alt="三级缓存"></p>
</li>
<li><p>Spring启动过程大致如下：</p>
<blockquote>
<p>1.加载配置文件<br>2.解析配置文件转化beanDefination，获取到bean的所有属性、依赖及初始化用到的各类处理器等<br>3.创建beanFactory并初始化所有单例bean<br>4.注册所有的单例bean并返回可用的容器，一般为扩展的applicationContext</p>
</blockquote>
</li>
</ul>
<span id="more"></span>

<h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><ul>
<li>在第三步中，所有单例的bean初始化完成后会存放在一个Map(singletonObjects)中，beanName为key，单例bean为value。<br>第三步单例bean的初始化过程大致如下：<blockquote>
<p>0.标记bean为创建中<br>1.new出bean对象<br>2.如果支持循环依赖则生成三级缓存，可以提前暴露bean<br>3.填充bean属性，解决属性依赖<br>4.初始化bean，处理Aware接口并执行各类bean后处理器，执行初始化方法，如果需要生成aop代理对象<br>5.如果存在循环依赖，解决之 – 这里有点问题，这一步是如果之前解决了aop循环依赖，则缓存中放置了提前生成的代理对象，然后使用原始bean继续执行初始化，所以需要再返回最终bean前，把原始bean置换为代理对象返回。<br>6.此时bean已经可以被使用，进行bean注册(标记)并注册销毁方法。<br>7.将bean放入容器中(一级缓存)，移除创建中标记及二三级缓存(后面再具体分析)<br><img src="/images/img-20.png" alt="1"><br><img src="/images/img-21.png" alt="2"><br><img src="/images/img-22.png" alt="3"></p>
</blockquote>
</li>
</ul>
<h4 id="循环依赖及三级缓存"><a href="#循环依赖及三级缓存" class="headerlink" title="循环依赖及三级缓存"></a>循环依赖及三级缓存</h4><ul>
<li><p>根据以上步骤可以看出bean初始化是一个相当复杂的过程，假如<strong>初始化A bean时，发现A bean依赖B bean</strong>,即A初始化执行到了第2步，此时B还没有初始化，则需要暂停A，先去初始化B，那么此时new出来的A对象放哪里，直接放在容器Map里显然不合适，半残品怎么能用，所以需要提供一个可以<strong>标记创建中bean(A)的Map，可以提前暴露正在创建的bean供其他bean依赖</strong>，如果在初始化A所依赖的bean B时，发现B也需要注入一个A的依赖，<strong>则B可以从创建中的beanMap中直接获取A对象（创建中）注入A</strong>，然后完成B的初始化，返回给正在注入属性的A，最终A也完成初始化，皆大欢喜。</p>
</li>
<li><p>如果配置不允许循环依赖，则上述缓存就用不到了，A 依赖B，就是创建B，B依赖C就去创建C，创建完了逐级返回就行，所以，<strong>一级缓存之后的其他缓存(二三级缓存)就是为了解决循环依赖</strong>！而配置支持循环依赖后，就一定要解决循环依赖吗？肯定不是！循环依赖在实际应用中也有，但不会太多，简单的应用场景是： controller注入service，service注入mapper，只有复杂的业务，可能service互相引用，有可能出现循环依赖，<strong>所以为了出现循环依赖才去解决，不出现就不解决，虽然支持循环依赖，但是只有在出现循环依赖时才真正暴露早期对象，否则只暴露个获取bean的方法，并没有真正暴露bean，因为这个方法不会被执行到，这块的实现就是三级缓存（singletonFactories），只缓存了一个单例bean工厂</strong>。<br><img src="/images/img-23.png">  </p>
</li>
<li><p>这个bean工厂不仅可以暴露早期bean还可以暴露代理bean，如果存在aop代理，则依赖的应该是代理对象，而不是原始的bean。而暴露原始bean是在单例bean初始化的第2步，填充属性第3步，生成代理对象第4步，这就矛盾了，A依赖到B并去解决B依赖时，要去初始化B，然后B又回来依赖A，而此时A还没有执行代理的过程，所以，需要在填充属性前就生成A的代理并暴露出去，第2步时机就刚刚好。</p>
</li>
<li><p>三级缓存的bean工厂getObject方式，实际执行的是getEarlyBeanReference，如果对象需要被代理(存在beanPostProcessors -&gt; SmartInstantiationAwareBeanPostProcessor)，则提前生成代理对象。<br><img src="/images/img-24.png"></p>
</li>
</ul>
<h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><ul>
<li><p>根据以上步骤可以看出bean初始化是一个相当复杂的过程，但是貌似三级缓存已经解决所有问题了，二级缓存用来做什么呢？为什么三级缓存不直接叫做二级缓存?这个应该是在缓存使用时决定的：<br><img src="/images/img-25.png">  </p>
</li>
<li><p>三级缓存中提到<strong>出现循环依赖才去解决</strong>，也就是说出现循环依赖时，才会执行工厂的getObject生成(获取)早期依赖，这个时候就需要给它挪个窝了，因为真正暴露的不是工厂，而是对象，所以需要使用一个新的缓存保存暴露的早期对象(<strong>earlySingletonObjects</strong>)，同时移除提前暴露的工厂，也不需要在多重循环依赖时每次去执行getObject(虽然个人觉得不会出问题，因为代理对象不会重复生成，详细可以了解下代理里面的逻辑，如wrapIfNecessary)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 核心类依赖图</title>
    <url>/2022/02/24/Spring-%E6%A0%B8%E5%BF%83%E7%B1%BB%E4%BE%9D%E8%B5%96%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="BeanFactory-相关核心依赖"><a href="#BeanFactory-相关核心依赖" class="headerlink" title="BeanFactory 相关核心依赖"></a>BeanFactory 相关核心依赖</h1><p><img src="/images/img-87.png" alt="BeanFactory 相关核心依赖"></p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 相关面试答疑</title>
    <url>/2022/02/25/Spring-%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p><strong>1. 使用 Spring 框架能给我们带来哪些好处?</strong></p>
<blockquote>
<ol>
<li>简化开发, 解放双手</li>
<li>提供了内置的解决方案 BOP、IoC、AOP</li>
<li>声明式事务管理, TransactionManager</li>
<li>提供诸多的工具类, 围绕 Spring 生态, 比如 JdbcTemplate, BeanUtils</li>
</ol>
</blockquote>
<p><strong>2. BeanFactory 和 ApplicationContext 有什么区别?</strong></p>
<blockquote>
<ol>
<li>ApplicationContext 是 BeanFactory 的实现类</li>
<li>BeanFactory 是顶层设计(抽象), 而 ApplicationContext 是 User Interface</li>
<li>功能会非常丰富, API是最全的, 一般会认为 ApplicationContext 就是 Ioc容器, 但是Ioc 的功能是在 DefaultListableBeanFactory 类中完成的, 但是有共同的接口</li>
</ol>
</blockquote>
<p><strong><mark>3. 请解释 Spring Bean 的生命周期</mark></strong></p>
<blockquote>
<p>所谓生命周期, 从创建, 到调用, 到销毁 ( <strong>作用域决定了生命周期的长短</strong>)</p>
<ol>
<li>单例 Bean: 从容器的启动到 Spring容器的销毁, 如果是延迟加载的 Bean, 会在调用前创建</li>
<li>原型 Bean: 在调用前创建, 在调用后销毁.</li>
</ol>
</blockquote>
<p><strong>4. Spring Bean 各作用域之间的区别?</strong></p>
<blockquote>
<ol>
<li><strong>sigleton</strong> 作用域全局, 在任何地方可以通过 Ioc 拿到</li>
<li><strong>prototype</strong> 作用域全局</li>
<li><strong>request</strong> 在一次请求发起和结束之间</li>
<li><strong>session</strong> 在一个 session 创建和失效之间, 根据配置的 session 失效时长 </li>
<li><strong>global-session</strong> 可以理解为容器中的一个应用 ( <strong>Spring 5 不再支持</strong> )</li>
</ol>
</blockquote>
<p><strong><mark>5. Spring 中的 Bean 是线程安全吗?</mark></strong></p>
<blockquote>
<p><strong>不一定, 要结合情况. <br><br>spring 中的 Bean 是从IOC容器中获得的, IOC容器中的 Bean 是通过配置得到的,<br><br>我们在配置 Bean 的时候, 如果该Bean 的 scope 为原型, 则每次都会创建一个新对象, <br><br>因此该 Bean 不存在线程之间的竞争, 所以不会存在线程安全的问题; 如果该 Bean 为单例, <br><br>所有线程会共享一个单例实例Bean , 所以可能会存在线程安全问题.</strong></p>
</blockquote>
<p><strong><mark>6. Spring 中用到了那些设计模式?</mark></strong></p>
<blockquote>
<p>工厂模式、单例模式(容器式单例)、代理模式、享元模式、门面模式、适配器模式、委派模式、<br><br>装饰器模式、责任链模式、解释器模式、策略模式、建造者模式、观察者模式、访问者模式 …</p>
</blockquote>
<p><strong><mark>7. 讲述Spring 的基本实现思路</mark></strong></p>
<blockquote>
<p>(见1. Spring 实现的基本思路 MarkDown … )</p>
</blockquote>
<p><strong><mark>8. Spring、SpringBoot、SpringCloud 有什么区别?</mark></strong></p>
<blockquote>
<p><strong>Spring</strong> 是已有的生态, 继承了各种工具, 能完成我们日常开发的所有功能 <br><br><strong>SpringBoot</strong> 基于 Spring, 更加简化了开发, 官方层面提供了一套脚手架, 一键搭建, 节省时间, 我们只需要遵从约定, 就能体验到更加简便的开发, 实现零配置, 并且全面的去 Servlet 化, 能够自运行, 部署也更加简便.<br><br><strong>SpringCloud</strong> 基于 SpringBoot, 主要用于搭建分布式微服务, 集成了各种如 注册中心、服务发现、服务监控、配置中心、负载、熔断等… 打造一个微服务生态.</p>
</blockquote>
<p><strong><mark>9. Spring 事务实现原理</mark></strong></p>
<blockquote>
<p>Spring 事务管理分为<mark>编程式</mark>和<mark>声明式</mark>两种,  编程式事务指的是通过编码方式实现事务; <mark>声明式事务基于 AOP</mark> <br></p>
<ol>
<li><strong>before</strong>() -&gt; 从连接池获取 connection 连接</li>
<li>我们业务操作sql </li>
<li><strong>after</strong>() -&gt; 根据条件(捕获异常等…) 来决定 <strong>connection.commit</strong>  或者<strong>connection.rollback</strong></li>
</ol>
</blockquote>
<p><strong>10. BeanFactory 和 FactoryBean 的区别?</strong></p>
<blockquote>
<p>BeanFactory 是 Ioc 容器的顶层设计, 用于从容器获取 Bean <br><br>FactoryBean 用来构建 Bean 的一个包装类, 用于给容器创建 Bean</p>
</blockquote>
<p><strong>11. 项目中如何应用AOP?</strong></p>
<blockquote>
<p>声明式事务管理、做日志、权限等…</p>
</blockquote>
<p><strong><mark>12. @Qualifier是干啥用的?</mark></strong></p>
<blockquote>
<p>默认情况下，@Autowired 按类型装配 Spring Bean。如果容器中有多个相同类型的 bean，则框架将抛出 NoUniqueBeanDefinitionException， 以提示有多个满足条件的 bean 进行自动装配。 </p>
</blockquote>
<p>通过将 @Qualifier 注解与我们想要使用的特定 Spring bean 的名称一起进行装配，Spring 框架就能从多个相同类型并满足装配要求的 bean 中找到我们想要的，避免让Spring脑裂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;fooFormatter&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Formatter formatter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//todo </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要做的是@Component或者@Bean注解中声明的value属性以确定名称。其实我们也可以在 Formatter 实现类上使用 @Qualifier 注释，而不是在 @Component 或者 @Bean 中指定名称，也能达到相同的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;fooFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;barFormatter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BarFormatter</span> <span class="keyword">implements</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p><strong>13. 构造方法注入和设值注入有什么区别?</strong></p>
<blockquote>
<p>使用构造函数依赖注入时，Spring保证所有一个对象所有依赖的对象先实例化后，才实例化这个对象。（没有他们就没有我原则）<br>        <br>使用set方法依赖注入时，Spring首先实例化对象，然后才实例化所有依赖的对象</p>
</blockquote>
<p><strong>14. FileSystemResource 和 ClassPathResource 有何区别?</strong></p>
<p>在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径。</p>
<p>在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource 文件放在ClassPath下。</p>
<p>如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。</p>
<p>简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件。</p>
]]></content>
      <categories>
        <category>面试答疑</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS</title>
    <url>/2022/03/05/Untitled/</url>
    <content><![CDATA[<h1 id="一、AbstractQueuedSynchronizer-AQS"><a href="#一、AbstractQueuedSynchronizer-AQS" class="headerlink" title="一、AbstractQueuedSynchronizer(AQS)"></a>一、AbstractQueuedSynchronizer(AQS)</h1><h2 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h2><ul>
<li>共享锁</li>
<li>互斥锁</li>
</ul>
<p>AQS 是一种抽象的队列同步器, 它是java除了synchroized之外自带的一种锁机制, 底层使用了大量的CAS进行互斥.</p>
<h2 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h2><p>以ReentrantLock为例, 在我们执行lock()方法进行上锁的时候, 如果有多个线程同时访问上锁的资源, 其底层会对AQS中的共享变量state进行一个CAS操作, 该操作是具有原子性, 如果线程A通过CAS将state状态修改成功就会获取到锁, 并记录一个共享变量设为A线程独享,则线程B尝试获取锁时由于锁状态state已经发生改变不再为0, 则就会把线程B存入一个FIFO的双向链表中, 该链表主要存储的是没有获取到锁的线程, 然后将里面的线程阻塞, 等到线程A释放锁完毕之后, 再唤醒队列中等待的线程. </p>
<p>由于AQS是自旋锁, 在等待唤醒的时候, 会不停的使用while(cas())的方式, 不停的尝试获取锁. </p>
<h2 id="AQS中为什么采用双向链表，它和单向链表相比，有什么优势？"><a href="#AQS中为什么采用双向链表，它和单向链表相比，有什么优势？" class="headerlink" title="AQS中为什么采用双向链表，它和单向链表相比，有什么优势？"></a>AQS中为什么采用双向链表，它和单向链表相比，有什么优势？</h2><p>ASQ中使用双向链表更容易访问相邻的节点. </p>
<h1 id="二、Lock"><a href="#二、Lock" class="headerlink" title="二、Lock"></a>二、Lock</h1><p><strong>重入锁</strong> -&gt; 互斥锁</p>
<h2 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h2><ul>
<li><p>公平锁和非公平锁</p>
<ul>
<li><p>公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//抢占1把锁 .</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    -&gt; AQS里面的方法</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Boolean <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//表示无锁状态</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">        compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//CAS（#Lock） -&gt; 原子操作| 实现互斥 的判断</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="comment">//把获得锁的线程保存到 exclusiveOwnerThread中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前获得锁的线程和当前抢占锁的线程是同一个，表示重入 else if (current == getExclusiveOwnerThread()) &#123;</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">//增加重入次数 .      if (nextc &lt; 0)</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="comment">//保存state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>非公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不管当前AQS队列中是否有排队的情况，先去插队</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">//返回false表示抢占锁失败 setExclusiveOwnerThread(Thread.currentThread()); else</span></span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    --<span class="function">AQS</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(!tryAcquire(arg)</span> &amp;&amp;                             <span class="title">acquireQueued</span><span class="params">(addWaiter(Node.EXCLUSIVE)</span>, arg))</span></span><br><span class="line"><span class="function">      <span class="title">selfInterrupt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Boolean <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Boolean <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//hasQueuedPredecessors</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="加入队列并进行自旋等待"><a href="#加入队列并进行自旋等待" class="headerlink" title="加入队列并进行自旋等待"></a>加入队列并进行自旋等待</h2><ul>
<li><p>acquire(int arg)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</p>
<ul>
<li><p>addWaiter(Node.EXCLUSIVE) -&gt; <strong>添加一个互斥锁的节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把当前线程封装成一个Node节点。</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//后续唤醒线程的时候，需要 得到被唤醒的线程 .</span></span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">//假设不存在竞争的情况</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Must initialize //初始化一个head节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                = node;</span><br><span class="line">                t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>acquireQueued() -&gt; <strong>自旋锁和阻塞的操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//node表示当前来抢占锁的线程，有可能是ThreadB、 ThreadC。。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Boolean <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    Boolean failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Boolean interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//自旋</span></span><br><span class="line">            <span class="comment">//begin  -&gt;尝试去获得锁(如果是非公平锁)</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//如果返回true，则不需要等待，直接返 回。</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//end</span></span><br><span class="line">            <span class="comment">//否则，让线程去阻塞(park)</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            parkAndCheckInterrupt()) <span class="comment">//LockSupport.park</span></span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadB、 ThreadC、ThreadD、ThreadE  -&gt; 都会阻塞在下面这个代码的位置 .</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Boolean <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">//被唤醒 . (interrupt()-&gt;)</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted(); <span class="comment">//中断状态（是否因为中断被唤醒的 .）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h2><ul>
<li><p>release(int arg)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Boolean <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//得到当前AQS队列中的head节点。</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">//head节点不为空</span></span><br><span class="line">        unparkSuccessor(h);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>unparkSuccessor(Node node)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) <span class="comment">//表示可以唤醒状态</span></span><br><span class="line">    compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//恢复成0</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> | | s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//说明ThreadB这个线程可能已经被销毁，或 者出现异常 ...</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//从tail -&gt; head进行遍历 .</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">//查找到小于等于0的节点</span></span><br><span class="line">        s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    LockSupport.unpark(s.thread);</span><br><span class="line">    <span class="comment">//封装在Node中的被阻塞的线程。ThreadB、</span></span><br><span class="line">    ThreadC。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-ReentrantLock"><a href="#1-ReentrantLock" class="headerlink" title="1. ReentrantLock"></a>1. ReentrantLock</h2><h3 id="ReentrantLock的实现原理"><a href="#ReentrantLock的实现原理" class="headerlink" title="ReentrantLock的实现原理"></a>ReentrantLock的实现原理</h3><p>满足线程的互斥特性</p>
<p>意味着同一个时刻，只允许一个线程进入到加锁的代码中。 -&gt; 多线程环境下，线程的顺序访问。</p>
<h4 id="锁的设计猜想（如果我们自己去实现）"><a href="#锁的设计猜想（如果我们自己去实现）" class="headerlink" title="锁的设计猜想（如果我们自己去实现）"></a>锁的设计猜想（如果我们自己去实现）</h4><ul>
<li>一定会设计到锁的抢占 ， 需要有一个标记来实现互斥。 全局变量（0，1）</li>
<li>抢占到了锁，怎么处理（不需要处理.）</li>
<li>没抢占到锁，怎么处理<ul>
<li>需要等待（让处于排队中的线程，如果没有抢占到锁，则直接先阻塞-&gt;释放CPU资源）。<ul>
<li>如何让线程等待？</li>
<li>wait/notify(线程通信的机制，无法指定唤醒某个线程)</li>
<li>LockSupport.park/unpark（阻塞一个指定的线程，唤醒一个指定的线程）</li>
<li>Condition</li>
</ul>
</li>
<li>需要排队（允许有N个线程被阻塞，此时线程处于活跃状态）。<ul>
<li>通过一个数据结构，把这N个排队的线程存储起来。</li>
</ul>
</li>
</ul>
</li>
<li>抢占到锁的释放过程，如何处理<ul>
<li>LockSupport.unpark() -&gt; 唤醒处于队列中的指定线程.\</li>
</ul>
</li>
<li>锁抢占的公平性（是否允许插队）<ul>
<li>公平</li>
<li>非公平</li>
</ul>
</li>
</ul>
<h4 id="ReentrantLock的实现原理分析"><a href="#ReentrantLock的实现原理分析" class="headerlink" title="ReentrantLock的实现原理分析"></a>ReentrantLock的实现原理分析</h4><p><img src="/images/img-154.png"></p>
<h2 id="2-Wait-Notify"><a href="#2-Wait-Notify" class="headerlink" title="2. Wait/Notify"></a>2. Wait/Notify</h2><p>线程的通信 -&gt; 共享内存</p>
<p>Wait/Notify 不是 J.U.C 包下的 -&gt; 基于某个条件来等待或者唤醒</p>
<p><img src="/images/img-155.png"></p>
<h3 id="基于Wait-Notify-实现生产者-消费者"><a href="#基于Wait-Notify-实现生产者-消费者" class="headerlink" title="基于Wait/Notify 实现生产者/消费者"></a>基于Wait/Notify 实现生产者/消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; bags;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Queue&lt;String&gt; bags, <span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bags = bags;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (bags)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bags.isEmpty())&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;bags为空&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bags.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                String bag=bags.remove();</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费： &quot;</span>+bag);</span><br><span class="line">                bags.notify(); <span class="comment">//这里只是唤醒Producer线程，但是Producer线程并不能马上执行。</span></span><br><span class="line">            &#125; <span class="comment">//同步代码块执行结束， monitorexit指令执行完成</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; bags;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Queue&lt;String&gt; bags, <span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bags = bags;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">synchronized</span> (bags)&#123;</span><br><span class="line">                <span class="comment">//抢占锁</span></span><br><span class="line">                <span class="keyword">if</span>(bags.size()==maxSize)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;bags 满了&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//park(); -&gt;JVM -&gt;Native</span></span><br><span class="line">                        bags.wait();</span><br><span class="line">                        <span class="comment">//满了，阻塞当前线程并且释放Producer抢到的锁 &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者生产：ag&quot;</span>+i);</span><br><span class="line">                bags.add(<span class="string">&quot;bag&quot;</span>+i);</span><br><span class="line">                <span class="comment">//生产bag</span></span><br><span class="line">                bags.notify();</span><br><span class="line">                <span class="comment">//表示当前已经生产了数据，提示消费者可以消费了 &#125; //同步代码快执行结束</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Queue&lt;String&gt; message = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Producer producer = <span class="keyword">new</span> Producer(message, <span class="number">10</span>);</span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> Consumer(message, <span class="number">10</span>);</span><br><span class="line">    producer.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-join"><a href="#3-join" class="headerlink" title="3. join"></a>3. join</h2><p>join 也是基于  wait/notify来实现，notify是在线程销毁之后调用的，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensure_join</span><span class="params">(JavaThread* thread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We do not need to grap the Threads_lock, since we are operating on ourself.</span></span><br><span class="line">    <span class="function">Handle <span class="title">threadObj</span><span class="params">(thread, thread-&gt;threadObj()</span>)</span>;</span><br><span class="line">    <span class="keyword">assert</span>(threadObj.not_null(), <span class="string">&quot;java thread object must exist&quot;</span>);</span><br><span class="line">    <span class="function">ObjectLocker <span class="title">lock</span><span class="params">(threadObj, thread)</span></span>;</span><br><span class="line">    <span class="comment">// Ignore pending exception (ThreadDeath), since we are exiting anyway</span></span><br><span class="line">    thread-&gt;clear_pending_exception();</span><br><span class="line">    <span class="comment">// Thread is exiting. So set thread_status field in  java.lang.Thread class to TERMINATED.</span></span><br><span class="line">    java_lang_Thread::set_thread_status(threadObj(),</span><br><span class="line">    java_lang_Thread::TERMINATED);</span><br><span class="line">    <span class="comment">// Clear the native thread instance - this makes isAlive return false and allows the join()</span></span><br><span class="line">    <span class="comment">// to complete once we&#x27;ve done the notify_all below</span></span><br><span class="line">    java_lang_Thread::set_thread(threadObj(), NULL);</span><br><span class="line">    lock.notify_all(thread);</span><br><span class="line">    <span class="comment">// Ignore pending exception (ThreadDeath), since we are exiting anyway</span></span><br><span class="line">    thread-&gt;clear_pending_exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Condition"><a href="#4-Condition" class="headerlink" title="4. Condition"></a>4. Condition</h2><p>Condition 实际上就是 J.U.C 版本的 wait/notify 。可以让线程基于某个条件去等待和唤醒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemoWait</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> Condition condition;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionDemoWait</span><span class="params">(Lock lock, Condition condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        <span class="keyword">this</span>.condition = condition;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;begin - ConditionDemoWait&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            <span class="comment">//让当前线程阻塞，Object.wait();</span></span><br><span class="line">            System.out.println(<span class="string">&quot;end - ConditionDemoWait&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemeNotify</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> Condition condition;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionDemeNotify</span><span class="params">(Lock lock, Condition condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        <span class="keyword">this</span>.condition = condition;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;begin - ConditionDemeNotify&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//synchronized(lock)</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            condition.signal();</span><br><span class="line">            <span class="comment">//让当前线程唤醒  Object.notify(); //因为任何对象都会</span></span><br><span class="line">            有monitor</span><br><span class="line">            System.out.println(<span class="string">&quot;end - ConditionDemeNotify&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Condition设计猜想"><a href="#Condition设计猜想" class="headerlink" title="Condition设计猜想"></a>Condition设计猜想</h3><ul>
<li>作用：   实现线程的阻塞和唤醒</li>
<li>前提条件：   必须先要获得锁</li>
<li>await/signal;signalAll<ul>
<li>await -&gt; 让线程阻塞，   并且释放锁</li>
<li>signal -&gt; 唤醒阻塞的线程</li>
</ul>
</li>
<li>加锁的操作，必然会涉及到AQS的阻塞队列</li>
<li>await 释放锁的时候，  -&gt; AQS队列中不存在已经释放锁的线程 -&gt; 这个被释放的线程去了哪里？ </li>
<li>signal 唤醒被阻塞的线程 -&gt; 从哪里唤醒？</li>
</ul>
<blockquote>
<p>通过await方法释放的线程，必须要有一个地方来存储，并且还需要被阻塞；   -&gt; 会存在一个等待队列，  LockSupport.park阻塞 </p>
</blockquote>
<blockquote>
<p>signal -&gt; 上面 猜想到的 等待队列中，唤醒一个线程，放哪里去？是不是应该再放到AQS队列？</p>
</blockquote>
<h2 id="5-CountDownLatch-（倒计时器）"><a href="#5-CountDownLatch-（倒计时器）" class="headerlink" title="5. CountDownLatch （倒计时器）"></a>5. CountDownLatch （倒计时器）</h2><p>① 某一线程在开始运行前等待n个线程执行完毕。将 CountDownLatch 的计数器初始化为n ：new CountDownLatch(n)，每当一个任务线程执行完毕，就将计数器减1 countdownlatch.countDown()，当计数器的值变为0时，在CountDownLatch上 await() 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</p>
<p>②实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 CountDownLatch 对象，将其计数器初始化为 1 ：new CountDownLatch(1)，多个线程在开始执行任务前首先 coundownlatch.await()，当主线程调用 countDown() 时，计数器变为0，多个线程同时被唤醒。</p>
<h3 id="CountDownLatch-的三种典型用法"><a href="#CountDownLatch-的三种典型用法" class="headerlink" title="CountDownLatch 的三种典型用法"></a>CountDownLatch 的三种典型用法</h3><ul>
<li><p>① 某一线程在开始运行前等待n个线程执行完毕。将 CountDownLatch 的计数器初始化为n ：new CountDownLatch(n)，每当一个任务线程执行完毕，就将计数器减1 countdownlatch.countDown()，当计数器的值变为0时，在CountDownLatch上 await() 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</p>
</li>
<li><p>② 实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 CountDownLatch 对象，将其计数器初始化为 1 ：new CountDownLatch(1)，多个线程在开始执行任务前首先 coundownlatch.await()，当主线程调用 countDown() 时，计数器变为0，多个线程同时被唤醒。</p>
</li>
<li><p>③ 死锁检测：一个非常方便的使用场景是，你可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。</p>
</li>
</ul>
<h3 id="CountDownLatch-的使用示例"><a href="#CountDownLatch-的使用示例" class="headerlink" title="CountDownLatch 的使用示例"></a>CountDownLatch 的使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> threadnum = i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadnum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          countDownLatch.countDown();<span class="comment">// 表示一个请求已经被完成</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，我们定义了请求的数量为550，当这550个请求被处理完成之后，才会执行System.out.println(“finish”);。</p>
<p>与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await()方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p>
<p>其他N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过 CountDownLatch.countDown()方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。所以当N个线程都调 用了这个方法，count的值等于0，然后主线程就能通过await()方法，恢复执行自己的任务。</p>
<h3 id="CountDownLatch-的不足"><a href="#CountDownLatch-的不足" class="headerlink" title="CountDownLatch 的不足"></a>CountDownLatch 的不足</h3><p>CountDownLatch是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用。</p>
<h3 id="CountDownLatch相常见面试题："><a href="#CountDownLatch相常见面试题：" class="headerlink" title="CountDownLatch相常见面试题："></a>CountDownLatch相常见面试题：</h3><p>解释一下CountDownLatch概念？</p>
<p>CountDownLatch 和CyclicBarrier的不同之处？</p>
<p>给出一些CountDownLatch使用的例子？</p>
<p>CountDownLatch 类中主要的方法？</p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>线程安全</tag>
        <tag>锁</tag>
        <tag>并发编程</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Synchronized 同步锁</title>
    <url>/2022/03/03/Synchronized-%E5%90%8C%E6%AD%A5%E9%94%81/</url>
    <content><![CDATA[<h1 id="一、并发编程带来的安全性挑战之同步锁"><a href="#一、并发编程带来的安全性挑战之同步锁" class="headerlink" title="一、并发编程带来的安全性挑战之同步锁"></a>一、并发编程带来的安全性挑战之同步锁</h1><p>如果多个线程在做同一件事情的时候。</p>
<ul>
<li>原子性 Synchronized ， AtomicXXX、 Lock、</li>
<li>可见性 Synchronized ， volatile</li>
<li>有序性 Synchronized ， volatile</li>
</ul>
<h2 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h2><p>在下面的案例中，演示了两个线程分别去去调用 demo.incr方法来对 i 这个变量进行叠加，预期结果 应该是20000，但是实际结果却是小于等于20000的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        Thread[] threads=<span class="keyword">new</span> Thread[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">2</span>;j++) &#123;</span><br><span class="line">            threads[j]=<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 创建两个线程</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10000</span>;k++) &#123;</span><br><span class="line">                    <span class="comment">// 每个线程跑10000次</span></span><br><span class="line">                    demo.incr();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            );</span><br><span class="line">            threads[j].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threads[<span class="number">0</span>].join();</span><br><span class="line">            threads[<span class="number">1</span>].join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(demo.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h2><p>这个就是典型的线程安全问题中原子性问题的体现。那什么是原子性呢？<br>在上面这段代码中，count++是属于Java高级语言中的编程指令，而这些指令最终可能会有多条CPU指 令来组成，而count++最终会生成3条指令，通过 javap -v xxx.class 查看字节码指令如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">incr</span><span class="params">()</span>V</span></span><br><span class="line"><span class="function">L0</span></span><br><span class="line"><span class="function">LINENUMBER 13 L0</span></span><br><span class="line"><span class="function">ALOAD 0</span></span><br><span class="line"><span class="function">DUP</span></span><br><span class="line"><span class="function"><span class="comment">// 访问变量i</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将整形常量1放入操作数栈</span></span></span><br><span class="line"><span class="function"><span class="comment">// 把操作数栈中的常量1出栈并相加，将相加的结</span></span></span><br><span class="line"><span class="function">果放入操作数栈</span></span><br><span class="line"><span class="function">PUTFIELD com/gupaoedu/pb/Demo.i : I   <span class="comment">// 访问类字段（类变量） ，复制给Demo.i这个变</span></span></span><br><span class="line"><span class="function">量</span></span><br></pre></td></tr></table></figure>

<p>这三个操作，如果要满足原子性，那么就需要保证某个线程在执行这个指令时，不允许其他线程干扰，然后实际上，确实会存在这个问题。</p>
<h2 id="图解问题本质"><a href="#图解问题本质" class="headerlink" title="图解问题本质"></a>图解问题本质</h2><p>前面我们说过，一个CPU核心在同一时刻只能执行一个线程，如果线程数量远远大于CPU核心数，就会 发生线程的切换，这个切换动作可以发生在任何一条CPU指令执行完之前。</p>
<p>对于 i++这三个cpu指令来说，如果线程A在执行指令1之后，做了线程切换，假设切换到线程B，线程B 同样执行CPU指令，执行的顺序如下图所示。就会导致最终的结果是1，而不是2.</p>
<p><img src="/images/img-131.png"></p>
<p>这就是在多线程环境下，存在的原子性问题，那么，怎么解决这个问题呢？</p>
<p>大家认真观察上面这个图，表面上是多个线程对于同一个变量的操作，实际上是count++这行代码，它 不是原子的。所以才导致在多线程环境下出现这样一个问题。</p>
<p>也就是说，我们只需要保证，count++这个指令在运行期间，在同一时刻只能由一个线程来访问，就可以解决问题。这就需要引出到今天的课程内容，同步锁Synchronized</p>
<h2 id="Synchronized的基本应用"><a href="#Synchronized的基本应用" class="headerlink" title="Synchronized的基本应用"></a>Synchronized的基本应用</h2><p>synchronized有三种方式来加锁，不同的修饰类型，代表锁的控制粒度：</p>
<ol>
<li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</li>
<li>静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</li>
<li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>
</ol>
<h2 id="锁的实现模型理解"><a href="#锁的实现模型理解" class="headerlink" title="锁的实现模型理解"></a>锁的实现模型理解</h2><p>Synchronized到底帮我们做了什么，为什么能够解决原子性呢？</p>
<p>在没有加锁之前，多个线程去调用incr()方法时，没有任何限制，都是可以同时拿到这个i的值进行++操 作，但是当加了Synchronized锁之后，线程A和B就由并行执行变成了串行执行。</p>
<p><img src="/images/img-132.png"></p>
<h1 id="二、Synchronized的原理"><a href="#二、Synchronized的原理" class="headerlink" title="二、Synchronized的原理"></a>二、Synchronized的原理</h1><p>Synchronized 是如何实现锁的，以及锁的信息是存储在哪里？ 就拿上面分析的图来说，线程A抢到锁了，线程B怎么知道当前锁被抢占了，这个地方一定会有一个标记来实现，而且这个标记一定是存储在某个地方。</p>
<h2 id="Markword对象头"><a href="#Markword对象头" class="headerlink" title="Markword对象头"></a>Markword对象头</h2><p>这就要引出Markword对象头这个概念了，它是对象头的意思，简单理解，就是一个对象，在JVM内存中的布局或者存储的形式。</p>
<p><strong>jdk8u: markOop.hpp</strong></p>
<p>在Hotspot虚拟机中，对象在内存中的存储布局，可以分为三个区域: **对象头(Header)、实例数据(Instance Data)、对齐填充(Padding)**。</p>
<p><img src="/images/img-133.png"></p>
<ul>
<li><p>mark-word：对象标记字段占4个字节，用于存储一些列的标记位，比如：哈希值、轻量级锁的标 记位，偏向锁标记位、分代年龄等。</p>
</li>
<li><p>Klass Pointer： Class对象的类型指针，Jdk1.8默认开启指针压缩后为4字节，关闭指针压缩（ -XX:-UseCompressedOops ）后，长度为8字节。其指向的位置是对象对应的Class对象（其对应的 元数据对象）的内存地址。</p>
</li>
<li><p>对象实际数据：包括对象的所有成员变量，大小由各个成员变量决定，比如：  byte占1个字节8比特位、int占4个字节32比特位。</p>
</li>
<li><p>对齐：最后这段空间补全并非必须，仅仅为了起到占位符的作用。由于HotSpot虚拟机的内存管理 系统要求对象起始地址必须是8字节的整数倍，所以对象头正好是8字节的倍数。因此当对象实例   数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
</li>
</ul>
<p><img src="/images/img-143.png"></p>
<h2 id="通过ClassLayout打印对象头"><a href="#通过ClassLayout打印对象头" class="headerlink" title="通过ClassLayout打印对象头"></a>通过ClassLayout打印对象头</h2><p>为了让大家更加直观的看到对象的存储和实现，我们可以使用JOL查看对象的内存布局。</p>
<ul>
<li><p>添加Jol依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写测试代码，在不加锁的情况下，对象头的信息打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    Object o=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo=<span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="comment">//o这个对象，在内存中是如何存储和布局的。</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(demo).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>输出内容如下</p>
<p>  <img src="/images/img-134.png"></p>
</li>
</ul>
<h1 id="三、关于Synchronized锁的升级"><a href="#三、关于Synchronized锁的升级" class="headerlink" title="三、关于Synchronized锁的升级"></a>三、关于Synchronized锁的升级</h1><p>Jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<p>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。</p>
<p>这么设计的目的，其实是为了减少重量级锁带来的性能开销，尽可能的在无锁状态下解决线程并发问题，其中偏向锁和轻量级锁的底层实现是基于自旋锁，它相对于重量级锁来说，算是一种无锁的实现。</p>
<p><img src="/images/img-135.png"></p>
<ul>
<li>默认情况下是偏向锁是开启状态，偏向的线程ID是0，偏向一个Anonymous BiasedLock</li>
<li>如果有线程去抢占锁，那么这个时候线程会先去抢占偏向锁，也就是把markword的线程ID改为当 前抢占锁的线程ID的过程</li>
<li>如果有线程竞争，这个时候会撤销偏向锁，升级到轻量级锁，线程在自己的线程栈帧中会创建一个 LockRecord ，用CAS操作把markword设置为指向自己这个线程的LR的指针，设置成功后表示抢    占到锁。</li>
<li>如果竞争加剧，比如有线程超过10次自旋（-XX:PreBlockSpin参数配置），或者自旋线程数超过   CPU核心数的一般，在1.6之后，加入了自适应自旋Adapative Self Spinning. JVM会根据上次竞争 的情况来自动控制自旋的时间。</li>
</ul>
<p>  升级到重量级锁，向操作系统申请资源，   Linux Mutex ，然后线程被挂起进入到等待队列。</p>
<h2 id="轻量级锁的获取及原理"><a href="#轻量级锁的获取及原理" class="headerlink" title="轻量级锁的获取及原理"></a>轻量级锁的获取及原理</h2><p>接下来，我们通过下面的例子来演示一下，通过加锁之后继续打印对象布局信息，来关注对象头里面的变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    Object o=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo=<span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="comment">//o这个对象，在内存中是如何存储和布局的。</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(demo).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (demo)&#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(demo).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的对象布局信息如下</p>
<p><img src="/images/img-136.png"><br><img src="/images/img-137.png"></p>
<p>这里很多同学会有疑惑，不是说锁的升级是基于线程竞争情况，来实现从偏向锁到轻量级锁再 到重量级锁的升级的吗？可是为什么这里明明没有竞争，它的锁的标记是轻量级锁呢？</p>
<h2 id="偏向锁的获取及原理"><a href="#偏向锁的获取及原理" class="headerlink" title="偏向锁的获取及原理"></a>偏向锁的获取及原理</h2><p>默认情况下，偏向锁的开启是有个延迟，默认是4秒。为什么这么设计呢？</p>
<p>因为JVM虚拟机自己有一些默认启动的线程，这些线程里面有很多的Synchronized代码，这些 Synchronized 代码启动的时候就会触发竞争，如果使用偏向锁，就会造成偏向锁不断的进行锁的升级和撤销，效率较低。</p>
<p>通过下面这个JVM参数可以讲延迟设置为0.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure>

<p>再次运行下面的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    Object o=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo=<span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="comment">//o这个对象，在内存中是如何存储和布局的。</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(demo).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (demo)&#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(demo).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到如下的对象布局，可以看到对象头中的的高位第一个字节最后三位数为**[101]**，表示当前为偏向锁状态。</p>
<blockquote>
<p>这里的第一个对象和第二个对象的锁状态都是101，是因为偏向锁打开状态下，默认会有配置匿名的对象获得偏向锁。</p>
</blockquote>
<p><img src="/images/img-138.png"><br><img src="/images/img-139.png"></p>
<h2 id="重量级锁的获取"><a href="#重量级锁的获取" class="headerlink" title="重量级锁的获取"></a>重量级锁的获取</h2><p>在竞争比较激烈的情况下，线程一直无法获得锁的时候，就会升级到重量级锁。</p>
<p>仔细观察下面的案例，通过两个线程来模拟竞争的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Demo testDemo = <span class="keyword">new</span> Demo();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (testDemo)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 lock ing&quot;</span>);</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(testDemo).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    );</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="keyword">synchronized</span> (testDemo)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main lock ing&quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(testDemo).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/img-140.png"><br><img src="/images/img-141.png"></p>
<h1 id="四、CAS"><a href="#四、CAS" class="headerlink" title="四、CAS"></a>四、CAS</h1><p>CAS这个在Synchronized底层用得非常多，它的全称有两种</p>
<ul>
<li>Compare and swap</li>
<li>Compare and exchange</li>
</ul>
<p>就是比较并交换的意思。它可以保证在多线程环境下对于一个变量修改的原子性。<br>CAS的原理很简单，包含三个值 <strong>当前内存值(V)、预期原来的值(E)以及期待更新的值(N)。</strong></p>
<p><img src="/images/img-142.png"></p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>线程安全</tag>
        <tag>锁</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/08/06/newpapername/</url>
    <content><![CDATA[<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>]]></content>
  </entry>
  <entry>
    <title>MySql Buffer Pool 与数据页</title>
    <url>/2021/08/25/ySql-Buffer-Pool-%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h1><p>在对数据库执行增删改查操作的时候，因为对磁盘的随机读写操作速度非常慢。所以通过Buffer Pool缓存磁盘的真实数据。</p>
<h1 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h1><p>MYSQL中抽象出来的数据单位，MYSQL把很多行数据放在一个数据页里。实际上我们更新一行数据的时候，是通过数据库找到这行数据所在的数据页，然后加载到Buffer Pool中。<br>默认情况下，一个数据页是16KB</p>
<h1 id="缓存页"><a href="#缓存页" class="headerlink" title="缓存页"></a>缓存页</h1><p>因为在Buffer Pool中存放的也是一个一个的数据页，也叫作缓存页。在默认情况下，是和磁盘上的数据页一一对应的，所以也是16KB。</p>
<span id="more"></span>
<h2 id="缓存页的描述信息"><a href="#缓存页的描述信息" class="headerlink" title="缓存页的描述信息"></a>缓存页的描述信息</h2><p>用于描述缓存页的一些基本信息，比如数据页所属表空间、数据页的编号、在Buffer Pool中的地址等。<br>每个缓存页都有对应的一个描述信息，在Buffer Pool中，每个缓存页的描述信息在最前面，然后各个缓存页放在后面<br>描述数据大概相当于缓存页是5%。</p>
<h1 id="free链表"><a href="#free链表" class="headerlink" title="free链表"></a>free链表</h1><h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><p>当读取数据页放入Buffer Pool的时候，怎么知道哪些缓存页是空闲的？<br><font color="red">free链表是一个双向链表，每个节点是一个空闲的缓存页的描述块地址</font>。    </p>
<h2 id="空间占用"><a href="#空间占用" class="headerlink" title="空间占用"></a>空间占用</h2><ul>
<li>free链表只是一个逻辑上的概念，因为每个缓存页的描述数据块中维护了两个指针，free_prev和free_next，分别指向free链表的上一个节点和下一个节点，这样就串成了一个free链表。    </li>
<li>free链表还有一个基础节点（但是不在链表中，链表头结点的prev=null，尾结点的next=null），40个字节，存放了free链表的头结点的地址、尾结点的地址以及free链表里当前还有多少个节点。</li>
</ul>
<h1 id="数据页读取到Buffer-Pool的过程"><a href="#数据页读取到Buffer-Pool的过程" class="headerlink" title="数据页读取到Buffer Pool的过程"></a>数据页读取到Buffer Pool的过程</h1><ol>
<li>从free链表里获取一个描述数据块，获取到对应的空闲缓存页</li>
<li>把数据页读取到对应的缓存页，写入相关的描述信息到描述数据块中</li>
<li>从free链表中移除</li>
</ol>
<h1 id="flush链表"><a href="#flush链表" class="headerlink" title="flush链表"></a>flush链表</h1><p>在执行增删改的时候，都是基于内存中的缓存页进行操作的，一旦更新了缓存页中的数据，使得和磁盘上的数据页里的数据不一致。那么这就是脏数据页。<br>类似于free链表，通过缓存页描述数据块中的两个指针来将脏数据页串起来。组成一个双向链表，也有一个基础节点存放头结点尾结点的地址等。</p>
<h1 id="MYSQL预读机制"><a href="#MYSQL预读机制" class="headerlink" title="MYSQL预读机制"></a>MYSQL预读机制</h1><p>当从磁盘上加载一个数据页的时候，可能会连带把这个数据页相邻的其他数据页也加载到缓存中去。分为以下两种预读方式，暂时不做说明    </p>
<ul>
<li>线性预读    <blockquote>
<p>顺序访问了一个区里的多个数据页（默认56页），就会把下一个相邻区中的所有数据页加载到缓存中</p>
</blockquote>
</li>
<li>随机预读    <blockquote>
<p>如果Buffer Pool中缓存了一个区的13个随机数据页，而且这些数据页是比较频繁被访问的，就会把这个区的其他数据页都加载到缓存中</p>
</blockquote>
</li>
</ul>
<h1 id="LRU链表"><a href="#LRU链表" class="headerlink" title="LRU链表"></a>LRU链表</h1><h2 id="简化版"><a href="#简化版" class="headerlink" title="简化版"></a>简化版</h2><ul>
<li>当free链表已经没有空闲页的时候，所有的缓存页都塞了数据库，此时就要淘汰掉一些缓存页。    </li>
<li>此时可以将一个脏数据页刷到磁盘，然后清空这个缓存页，就有了一个空闲的缓存页。但是选择哪一个脏数据页去清空，此时就要用到LRU链表。    </li>
<li>当把一个数据页加载到缓存页的时候，把对应的描述数据块放到LRU链表头部。后续查询了或者修改了某个缓存页，也会把这个缓存页挪动到LRU链表头部。    </li>
<li>但是MYSQL的预读机制可能会加载没人访问的数据页，如下图。<br><img src="/images/img-37.png"></li>
</ul>
<h2 id="基于冷热分离的LRU链表"><a href="#基于冷热分离的LRU链表" class="headerlink" title="基于冷热分离的LRU链表"></a>基于冷热分离的LRU链表</h2><ul>
<li>将链表按照5:3的比例分割，63%的热数据，37%的冷数据。</li>
<li>数据页第一次加载到缓存的时候，放入冷数据头部。在1s后（参数配置）访问这个缓存页，就会被加入热数据头部。</li>
<li>在热数据区域的前1/4部分缓存页被访问后不会移动到链表头部，避免浪费性能</li>
<li>有一个后台线程会定时把冷数据区域的尾部缓存页刷回磁盘，清空加入回free链表。</li>
<li>热数据区域也会在MYSQL闲暇的时候刷回磁盘</li>
<li>无空闲缓存页时从冷数据区域尾部找到一个缓存页刷回磁盘并清空成为空闲页。</li>
</ul>
<h1 id="Buffer-Pool-1"><a href="#Buffer-Pool-1" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h1><h2 id="并发访问Buffer-Pool的性能问题"><a href="#并发访问Buffer-Pool的性能问题" class="headerlink" title="并发访问Buffer Pool的性能问题"></a>并发访问Buffer Pool的性能问题</h2><ul>
<li>多线程同时访问Buffer Pool，就会同时操作同一个free链表、flush链表和lru链表。那必然要进行加锁</li>
<li>因为是基于内存的操作，所以很快。其次这些链表的操作，也是基于指针的操作，也不存在性能低下的可能。<h2 id="多个Buffer-Pool优化并发能力"><a href="#多个Buffer-Pool优化并发能力" class="headerlink" title="多个Buffer Pool优化并发能力"></a>多个Buffer Pool优化并发能力</h2>给Buffer Pool分配比较大的内存，则可以设置多个Buffer Pool.如果给分配的内存小于1G，最多就只有1个Buffer Pool。    <blockquote>
<p>innodb_buffer_pool_instances=8</p>
</blockquote>
</li>
</ul>
<h2 id="基于chunk机制动态调整Buffer-Pool的大小"><a href="#基于chunk机制动态调整Buffer-Pool的大小" class="headerlink" title="基于chunk机制动态调整Buffer Pool的大小"></a>基于chunk机制动态调整Buffer Pool的大小</h2><ul>
<li>Buffer Pool是由多个chunk组成的，默认一个chunk的大小是128M。    <blockquote>
<p>分配Buffer Pool的内存8G，4个Buffer Pool实例，那么每个Buffer Pool是2G，拥有16个chunk。</p>
</blockquote>
</li>
<li>需要动态扩容的话只需要申请一系列128MB大小的chunk就行，然后分配给buffer pool就行。<br><img src="/images/img-38.png"></li>
</ul>
<h2 id="内存的分配"><a href="#内存的分配" class="headerlink" title="内存的分配"></a>内存的分配</h2><ul>
<li>Buffer Pool总共占用机器内存的50%-60%</li>
<li>buffer Pool总大小 = (chunk size * buffer pool instance) * chunk count<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li>
<li>根据机器的内存设置合理的buffer pool的大小，然后设置buffer pool的数量，使得chunk数量*chunk size 接近单个buffer pool的内存。充分利用内存减少内存碎片</li>
<li>每个buffer pool里的多个chunk共用一套链表数据结构。</li>
<li>后台线程定时根据lru链表和flush链表，去把一批缓存页刷入磁盘并释放，同时更新free链表</li>
<li>如果缓存页满了，无法加载自己的缓存页，就把lru链表冷数据区域的缓存页刷盘</li>
</ul>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历</title>
    <url>/2022/01/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="递归遍历-前序、中序、后序遍历"><a href="#递归遍历-前序、中序、后序遍历" class="headerlink" title="递归遍历 (前序、中序、后序遍历)"></a>递归遍历 (前序、中序、后序遍历)</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(node)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.print(node.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preOrder(node.leftChild);</span><br><span class="line">    preOrder(node.rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(node)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inOrder(node.leftChild);</span><br><span class="line">    System.out.print(node.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    inOrder(node.rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(node)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postOrder(node.leftChild);</span><br><span class="line">    postOrder(node.rightChild);</span><br><span class="line">    System.out.print(node.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试案例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; datas = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">10</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">8</span>,<span class="keyword">null</span>,<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    TreeNode treeNode = TreeNode.createTreeNode(datas);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;前序遍历&quot;</span>);</span><br><span class="line">    preOrder(treeNode);</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">    inOrder(treeNode);</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(<span class="string">&quot;后序遍历&quot;</span>);</span><br><span class="line">    postOrder(treeNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">前序遍历</span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">9</span> <span class="number">10</span> <span class="number">8</span> <span class="number">4</span> </span><br><span class="line"></span><br><span class="line">中序遍历</span><br><span class="line"><span class="number">9</span> <span class="number">2</span> <span class="number">10</span> <span class="number">3</span> <span class="number">8</span> <span class="number">4</span> </span><br><span class="line"></span><br><span class="line">后序遍历</span><br><span class="line"><span class="number">9</span> <span class="number">10</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">3</span> </span><br></pre></td></tr></table></figure>


<h1 id="非递归遍历-层序遍历"><a href="#非递归遍历-层序遍历" class="headerlink" title="非递归遍历 (层序遍历)"></a>非递归遍历 (层序遍历)</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stackOrder</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(treeNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode poll = queue.poll();</span><br><span class="line">        System.out.print(poll.data + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (poll.leftChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(poll.leftChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (poll.rightChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(poll.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; datas = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">5</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">    TreeNode treeNode = TreeNode.createTreeNode(datas);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;层序遍历: &quot;</span>);</span><br><span class="line">    stackOrder(treeNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">层序遍历: </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法小抄</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>链表</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2022/02/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一、类型"><a href="#一、类型" class="headerlink" title="一、类型"></a>一、类型</h1><p>结构型设计模式</p>
<h1 id="二、代理模式的定义"><a href="#二、代理模式的定义" class="headerlink" title="二、代理模式的定义"></a>二、代理模式的定义</h1><p>代理模式 是指为其他对象提供一种代理, 以控制对这个对象的访问.</p>
<p>代理对象在客户端和目标对象之间起到中介作用.</p>
<h1 id="三、静态代理和动态代理区别"><a href="#三、静态代理和动态代理区别" class="headerlink" title="三、静态代理和动态代理区别"></a>三、静态代理和动态代理区别</h1><p>静态代理: 硬编码、手动注入, 手动拿到目标对象的引用, 手动调用代理目标的方法.</p>
<p>动态代理: 具有更强的扩展性, 自动注入, 自动生成一个新的类(同一个继承体系)</p>
<p><strong>特征:</strong><br>    1.拿到代理目标对象的引用<br>    2.实现功能增强<br>    3.保护目标对象 </p>
<h1 id="四、动态代理对象的创建过程"><a href="#四、动态代理对象的创建过程" class="headerlink" title="四、动态代理对象的创建过程"></a>四、动态代理对象的创建过程</h1><ol>
<li><p>动态拼接出代理对象的java类的代码(包括java类的import xxx、类名、构造方法、继承接口、方法等动态拼接出来形成一个正常的java类)</p>
</li>
<li><p>用文件流将代理对象的java类输出到磁盘, 保存为$Proxy0.java文件</p>
</li>
<li><p>将$Proxy0.java文件进行编译成.class文件, 新文件为$Proxy0.class</p>
</li>
<li><p>将生成的$Proxy0.class加载到JVM内存中</p>
</li>
<li><p>返回新的代理对象</p>
</li>
</ol>
<h1 id="五、CgLib-Proxy-与-JDK-Proxy-区别"><a href="#五、CgLib-Proxy-与-JDK-Proxy-区别" class="headerlink" title="五、CgLib Proxy 与 JDK Proxy 区别"></a>五、CgLib Proxy 与 JDK Proxy 区别</h1><ul>
<li><p><strong>不同点:</strong></p>
<ol>
<li>CgLib Proxy 使用继承的方式, 覆盖父类的方法.</li>
<li>JDK Proxy 采用实现接口的方式, 必须要求代理的目标实现一个接口.</li>
<li>CgLib Proxy 对目标类没有任何要求.</li>
<li>JDK Proxy 对于用户而言, 依赖更强, 调用更复杂.</li>
<li>CgLib Proxy 采用另外一套API, 没有使用反射, 性能更高.</li>
<li>JDK Proxy 生成逻辑较为简单, 执行效率相对较低, 每次都使用到反射.</li>
</ol>
</li>
<li><p><strong>相同点:</strong>  </p>
<ol>
<li>都是通过生成字节码, 重组成一个新的类.</li>
</ol>
</li>
<li><p><strong>CgLib 有个坑:</strong>  </p>
<ol>
<li>由于使用的继承, 目标代理类不能有final修饰的方法, 他会忽略final修饰的方法.</li>
</ol>
</li>
</ul>
<h1 id="六、代理模式优点"><a href="#六、代理模式优点" class="headerlink" title="六、代理模式优点"></a>六、代理模式优点</h1><ol>
<li><p>代理模式能将代理对象与真实被调用的目标对象分离.</p>
</li>
<li><p>一定程度上降低了系统的耦合度, 易于扩展.</p>
</li>
<li><p>代理可以起到保护目标对象的作用.</p>
</li>
<li><p>增强目标对象.</p>
</li>
</ol>
<h1 id="七、代理模式缺点"><a href="#七、代理模式缺点" class="headerlink" title="七、代理模式缺点"></a>七、代理模式缺点</h1><ol>
<li><p>代理模式会造成系统设计中类数量增加.</p>
</li>
<li><p>在客户端和目标对象之前增加了一个代理对象, 会降低请求速度.</p>
</li>
<li><p>增加系统复杂度</p>
</li>
</ol>
<h1 id="八、Spring-中的代理选择原则"><a href="#八、Spring-中的代理选择原则" class="headerlink" title="八、Spring 中的代理选择原则"></a>八、Spring 中的代理选择原则</h1><ol>
<li>当 Bean 有实现接口时, Spring 就会使用 JDK 的动态代理.</li>
<li>当 Bean 没有实现接口时, Spring 会选择 CGLib.</li>
<li>Spring 可以通过配置强制使用 CGLib, 只需在 Spring 配置文件中加入以下代码: <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&#x27;true&#x27;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="九、JDK-动态代理的使用"><a href="#九、JDK-动态代理的使用" class="headerlink" title="九、JDK 动态代理的使用"></a>九、JDK 动态代理的使用</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标对象接口</span></span><br><span class="line">    <span class="keyword">private</span> IPerson target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPerson <span class="title">getInstance</span><span class="params">(IPerson target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Class&lt;? extends IPerson&gt; clazz = target.getClass();</span><br><span class="line">        <span class="keyword">return</span> (IPerson) Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object invoke = method.invoke(<span class="keyword">this</span>.target, args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    MyProxy proxy = <span class="keyword">new</span> MyProxy();</span><br><span class="line">    IPerson instance = proxy.getInstance(<span class="keyword">new</span> Zhangsan());</span><br><span class="line">    instance.doSomething();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行结果</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">before()...</span><br><span class="line">张三正在执行某件事...</span><br><span class="line">after()...</span><br><span class="line">----------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>摘抄笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>优先队列</title>
    <url>/2022/01/15/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><strong>以下代码基于最小堆实现的最小优先队列</strong></p>
<blockquote>
<p>二叉堆实现参见 –&gt; <a href="https://pdyun.cc/2022/01/15/%E6%8E%92%E5%BA%8F-%E5%A0%86%E6%8E%92%E5%BA%8F/">二叉堆、堆排序</a></p>
</blockquote>
<h3 id="自定义实现优先队列"><a href="#自定义实现优先队列" class="headerlink" title="自定义实现优先队列"></a>自定义实现优先队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> 最小优先队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 基于最小堆堆实现的优先队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Deng PeiLin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/1/13 15:47</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 优先队列 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> 优先队列 () &#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> 优先队列 add(<span class="keyword">int</span> data)&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= arr.length) &#123;</span><br><span class="line">            resize();</span><br><span class="line">        &#125;</span><br><span class="line">        arr[size ++] = data;</span><br><span class="line">        upAdjust();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列中无数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> firstData = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[--size];</span><br><span class="line">        downAdjust();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> firstData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上浮调整</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> childIndex = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> parentIndex = (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// temp 用于保存插入的叶子节点值, 用于最后的赋值</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[childIndex];</span><br><span class="line">        <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &lt; arr[parentIndex]) &#123;</span><br><span class="line">            <span class="comment">// 无需真正交换, 单项赋值即可</span></span><br><span class="line">            arr[childIndex] = arr[parentIndex];</span><br><span class="line">            childIndex = parentIndex;</span><br><span class="line">            parentIndex = (parentIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[childIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下沉调整</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> parentIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// temp 用于保存插入的叶子节点值, 用于最后的赋值</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[parentIndex];</span><br><span class="line">        <span class="keyword">int</span> childIndex = parentIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (childIndex &lt; size) &#123;</span><br><span class="line">            <span class="comment">// 如果有右节点, 且右节点小于左节点的值, 则定位到右节点</span></span><br><span class="line">            <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; size &amp;&amp; arr[childIndex + <span class="number">1</span>] &lt; arr[childIndex]) &#123;</span><br><span class="line">                childIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果父节点小于子节点的值则跳出, 不需要调整</span></span><br><span class="line">            <span class="keyword">if</span> (temp &lt; arr[childIndex]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[parentIndex] = arr[childIndex];</span><br><span class="line">            parentIndex = childIndex;</span><br><span class="line">            childIndex = childIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[parentIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, size * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(Arrays.copyOfRange(arr, <span class="number">0</span>, size));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        优先队列 queue = <span class="keyword">new</span> 优先队列();</span><br><span class="line"></span><br><span class="line">        queue.add(<span class="number">5</span>).add(<span class="number">8</span>).add(<span class="number">9</span>).add(<span class="number">11</span>).add(<span class="number">999</span>).add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;队列数据: &quot;</span> + queue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> out = queue.out();</span><br><span class="line">        System.out.println(<span class="string">&quot;出队元素: &quot;</span> + out);</span><br><span class="line">        System.out.println(<span class="string">&quot;队列数据: &quot;</span> + queue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> out2 = queue.out();</span><br><span class="line">        System.out.println(<span class="string">&quot;出队元素: &quot;</span> + out2);</span><br><span class="line">        System.out.println(<span class="string">&quot;队列数据: &quot;</span> + queue);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>测试结果 &gt;&gt;&gt; <strong>以最小堆实现的最小优先队列, 队列头部皆为最小数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">队列数据: [<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">999</span>, <span class="number">9</span>]</span><br><span class="line">出队元素: <span class="number">1</span></span><br><span class="line">队列数据: [<span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">999</span>]</span><br><span class="line">出队元素: <span class="number">5</span></span><br><span class="line">队列数据: [<span class="number">8</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">999</span>]</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法小抄</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>二叉堆</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2022/01/15/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>冒泡排序优化版</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次: &quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        sort2(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ------------------------------------------------------------</span><br><span class="line">    打印结果</span><br><span class="line">    第一次: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">    第二次: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">    ------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isSort = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> a = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">                    nums[j] = a;</span><br><span class="line">                    isSort = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSort) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastChangeIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sortBorder = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isSort = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> a = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">                    nums[j] = a;</span><br><span class="line">                    isSort = <span class="keyword">false</span>;</span><br><span class="line">                    lastChangeIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortBorder = lastChangeIndex;</span><br><span class="line">            <span class="keyword">if</span> (isSort) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法小抄</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>加一</title>
    <url>/2022/01/15/%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</span><br><span class="line"></span><br><span class="line">最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</span><br><span class="line"></span><br><span class="line">你可以假设除了整数 0 之外，这个整数不会以零开头。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：digits = [1,2,3]</span><br><span class="line">输出：[1,2,4]</span><br><span class="line">解释：输入数组表示数字 123。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：digits = [4,3,2,1]</span><br><span class="line">输出：[4,3,2,2]</span><br><span class="line">解释：输入数组表示数字 4321。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：digits = [0]</span><br><span class="line">输出：[1]</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：digits = [9,9,9]</span><br><span class="line">输出：[1,0,0,0]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;数组加一前: &quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    arr = plusOne(arr);</span><br><span class="line">    System.out.println(<span class="string">&quot;数组加一后: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">执行结果</span><br><span class="line">数组加一前: [<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>]</span><br><span class="line">数组加一后: [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> isAddLength = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length-<span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = digits[i] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (temp % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)&#123;</span><br><span class="line">                isAddLength = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        digits[i] = temp;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isAddLength)&#123;</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法小抄</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2022/02/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一-类型"><a href="#一-类型" class="headerlink" title="一. 类型"></a>一. 类型</h1><p>创建型模式</p>
<h1 id="二-优点"><a href="#二-优点" class="headerlink" title="二. 优点"></a>二. 优点</h1><ol>
<li>保证一个类仅有一个实例，减少了内存开销.</li>
<li>可以避免对资源的多重占用.</li>
<li>设置全局访问点, 严格控制访问.</li>
</ol>
<h1 id="三-缺点"><a href="#三-缺点" class="headerlink" title="三. 缺点"></a>三. 缺点</h1><ol>
<li>没有接口, 扩展困难.</li>
<li>如果要扩展单例对象, 只有修改代码, 无其他途径.</li>
</ol>
<h1 id="四-单例的相关注意点"><a href="#四-单例的相关注意点" class="headerlink" title="四. 单例的相关注意点"></a>四. 单例的相关注意点</h1><ol>
<li><strong>私有化构造器</strong></li>
<li><strong>保证线程安全</strong></li>
<li><strong>延迟加载</strong></li>
<li><strong>防止序列化和反序列化破坏单例</strong></li>
<li><strong>防御反射破攻击单例</strong></li>
</ol>
<h1 id="五-多种单例写法"><a href="#五-多种单例写法" class="headerlink" title="五. 多种单例写法"></a>五. 多种单例写法</h1><h2 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优点：执行效率高，性能高，没有任何的锁</span></span><br><span class="line"><span class="comment"> * 缺点：由于提前创建对象, 没有使用的情况下，可能会造成内存浪费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="懒汉式单例-延迟加载"><a href="#懒汉式单例-延迟加载" class="headerlink" title="懒汉式单例(延迟加载)"></a>懒汉式单例(延迟加载)</h2><h3 id="简单写法"><a href="#简单写法" class="headerlink" title="简单写法"></a>简单写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优点：节省了内存,线程安全</span></span><br><span class="line"><span class="comment"> * 缺点：性能低</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySimpleSingletion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySimpleSingletion instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySimpleSingletion</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySimpleSingletion <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySimpleSingletion();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DCL-双重检查锁写法"><a href="#DCL-双重检查锁写法" class="headerlink" title="DCL 双重检查锁写法"></a>DCL 双重检查锁写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优点:性能高了，线程安全了</span></span><br><span class="line"><span class="comment"> * 缺点：可读性难度加大，不够优雅</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyDoubleCheckSingleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//检查是否要阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckSingleton.class) &#123;</span><br><span class="line">                <span class="comment">//检查是否要重新创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LazyDoubleCheckSingleton();</span><br><span class="line">                    <span class="comment">//指令重排序的问题</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态内部类写法"><a href="#静态内部类写法" class="headerlink" title="静态内部类写法"></a>静态内部类写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  静态内部类写法</span></span><br><span class="line"><span class="comment">  ClassPath : LazyStaticInnerClassSingleton.class</span></span><br><span class="line"><span class="comment">              LazyStaticInnerClassSingleton$LazyHolder.class</span></span><br><span class="line"><span class="comment">   优点：利用了Java本身语法特点，性能高，避免了内存浪费,不能被反射破坏</span></span><br><span class="line"><span class="comment">   缺点：不优雅</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyStaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyStaticInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 此处防止反射攻击破坏单例所做的检查, 此处让代码变得不优雅, 且不易懂</span></span><br><span class="line">        <span class="keyword">if</span>(LazyHolder.INSTANCE != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不允许非法访问&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> LazyStaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyStaticInnerClassSingleton INSTANCE = <span class="keyword">new</span> LazyStaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册式单例"><a href="#注册式单例" class="headerlink" title="注册式单例"></a>注册式单例</h2><h3 id="枚举式单例"><a href="#枚举式单例" class="headerlink" title="枚举式单例"></a>枚举式单例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举式单例</span></span><br><span class="line"><span class="comment"> * 优点: 优雅的写法</span></span><br><span class="line"><span class="comment"> * 缺点: 不能大批量创建对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容器式单例"><a href="#容器式单例" class="headerlink" title="容器式单例"></a>容器式单例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容器式单例</span></span><br><span class="line"><span class="comment"> * 基于枚举式单例的改进, 可以大批量创建对象,</span></span><br><span class="line"><span class="comment"> * 以下代码需要增加线程安全的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ContainerSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; ioc = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">        Object instance = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ioc.containsKey(className))&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                instance = Class.forName(className).newInstance();</span><br><span class="line">                ioc.put(className, instance);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ioc.get(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解决序列化的单例"><a href="#解决序列化的单例" class="headerlink" title="解决序列化的单例"></a>解决序列化的单例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeriableSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    <span class="comment">//把内存中对象的状态转换为字节码的形式</span></span><br><span class="line">    <span class="comment">//把字节码通过IO输出流，写到磁盘上</span></span><br><span class="line">    <span class="comment">//永久保存下来，持久化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    <span class="comment">//将持久化的字节码内容，通过IO输入流读到内存中来</span></span><br><span class="line">    <span class="comment">//转化成一个Java对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">final</span> <span class="keyword">static</span> SeriableSingleton INSTANCE = <span class="keyword">new</span> SeriableSingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SeriableSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SeriableSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化时, 输入流对象底层实际上是new的一个新对象返回</span></span><br><span class="line">    <span class="comment">// 如果有该方法的话, 输入流会通过反射找到该名称的方法, 获取到返回结果来避免new一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLoocal-式单例"><a href="#ThreadLoocal-式单例" class="headerlink" title="ThreadLoocal 式单例"></a>ThreadLoocal 式单例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ThreadLocalSingleton&gt; threadLocaLInstance =</span><br><span class="line">            <span class="keyword">new</span> ThreadLocal&lt;ThreadLocalSingleton&gt;()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> ThreadLocalSingleton <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocalSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocaLInstance.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>摘抄笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2022/02/10/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一-类型"><a href="#一-类型" class="headerlink" title="一. 类型"></a>一. 类型</h1><p>创建型模式</p>
<h1 id="二-定义"><a href="#二-定义" class="headerlink" title="二. 定义"></a>二. 定义</h1><p>原型模式是指原型实例创建对象的种类, 并且通过拷贝这些原型创建新的对象. </p>
<p>调用者不需要知道任何创建细节, 不调用构造函数.</p>
<h1 id="三-适用场景"><a href="#三-适用场景" class="headerlink" title="三. 适用场景"></a>三. 适用场景</h1><ol>
<li>类初始化消耗资源较多</li>
<li>new 产生的一个对象需要非常繁琐的过程(数据准备、访问权限等)</li>
<li> 构造函数比较复杂</li>
<li> 循环体中产生大量对象时</li>
</ol>
<h1 id="四-优点"><a href="#四-优点" class="headerlink" title="四. 优点"></a>四. 优点</h1><ol>
<li>性能优良, java 自带的原型模式是基于内存二进制流的拷贝, 比直接 new 一个对象性能上提升了许多</li>
<li>可以使用深克隆方式保存对象的状态, 使用原型模式将对象复制一份将其状态保存起来, 简化了创建过程.</li>
</ol>
<h1 id="五-缺点"><a href="#五-缺点" class="headerlink" title="五. 缺点"></a>五. 缺点</h1><ol>
<li>必须配备克隆(或者可拷贝)的方法</li>
<li>当对已有的类进行改造的时候, 需要修改代码, 违反了开闭原则</li>
<li>深拷贝、浅拷贝需要运用得当</li>
</ol>
<h1 id="六-原型模式写法"><a href="#六-原型模式写法" class="headerlink" title="六. 原型模式写法"></a>六. 原型模式写法</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类实现了Cloneable接口来指示Object.clone()方法，该方法可以合法地对类的实例进行字段对字段的复制。  </span></span><br><span class="line"><span class="comment"> * 在一个没有实现Cloneable接口的实例上调用Object的clone方法会导致抛出CloneNotSupportedException异常。  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConcretePrototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (ConcretePrototype)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ConcretePrototype&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, hobbies=&quot;</span> + hobbies +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建原型对象</span></span><br><span class="line">        ConcretePrototype prototype = <span class="keyword">new</span> ConcretePrototype();</span><br><span class="line">        prototype.setAge(<span class="number">18</span>);</span><br><span class="line">        prototype.setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        List&lt;String&gt; hobbies = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        hobbies.add(<span class="string">&quot;书法&quot;</span>);</span><br><span class="line">        hobbies.add(<span class="string">&quot;美术&quot;</span>);</span><br><span class="line">        prototype.setHobbies(hobbies);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拷贝原型对象</span></span><br><span class="line">        ConcretePrototype cloneType = prototype.clone();</span><br><span class="line">        cloneType.getHobbies().add(<span class="string">&quot;技术控&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原型对象：&quot;</span> + prototype);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆对象：&quot;</span> + cloneType);</span><br><span class="line">        System.out.println(prototype == cloneType);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原型对象的爱好：&quot;</span> + prototype.getHobbies());</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆对象的爱好：&quot;</span> + cloneType.getHobbies());</span><br><span class="line">        System.out.println(prototype.getHobbies() == cloneType.getHobbies());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行结果</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">原型对象：ConcretePrototype&#123;age=18, name=&#x27;Tom&#x27;, hobbies=[书法, 美术, 技术控]&#125;</span><br><span class="line">克隆对象：ConcretePrototype&#123;age=18, name=&#x27;Tom&#x27;, hobbies=[书法, 美术, 技术控]&#125;</span><br><span class="line">false</span><br><span class="line">原型对象的爱好：[书法, 美术, 技术控]</span><br><span class="line">克隆对象的爱好：[书法, 美术, 技术控]</span><br><span class="line">true</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>*<strong>结论</strong> </p>
<p><strong>浅拷贝时引用对象是通过 JDK 中的字节流去完成复制, JDK 底层有一个机制, 如果是一个类已经存在的时候不会去重新加载, 就会进行一个值与值的一个简单复制, 相当于拷贝的是引用,  就会造成以上修改克隆对象中的值时, 原对象也已经被修改</strong></p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深拷贝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>,<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConcretePrototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (ConcretePrototype)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以强转成ArrayList, ArrayList 的clone方法就是使用的深拷贝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConcretePrototype <span class="title">deepCloneHobbies</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ConcretePrototype result = (ConcretePrototype)<span class="keyword">super</span>.clone();</span><br><span class="line">            result.hobbies = (List)((ArrayList)result.hobbies).clone();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化和反序列化 可以破坏单例, 可以利用这一点来返回一个新对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConcretePrototype <span class="title">deepClone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (ConcretePrototype)ois.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ConcretePrototype&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, hobbies=&quot;</span> + hobbies +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建原型对象</span></span><br><span class="line">    ConcretePrototype prototype = <span class="keyword">new</span> ConcretePrototype();</span><br><span class="line">    prototype.setAge(<span class="number">18</span>);</span><br><span class="line">    prototype.setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    List&lt;String&gt; hobbies = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    hobbies.add(<span class="string">&quot;书法&quot;</span>);</span><br><span class="line">    hobbies.add(<span class="string">&quot;美术&quot;</span>);</span><br><span class="line">    prototype.setHobbies(hobbies);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝原型对象</span></span><br><span class="line">    ConcretePrototype cloneType = prototype.deepCloneHobbies();</span><br><span class="line">    <span class="comment">// ConcretePrototype cloneType = prototype.deepClone();</span></span><br><span class="line">    cloneType.getHobbies().add(<span class="string">&quot;技术控&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;原型对象：&quot;</span> + prototype);</span><br><span class="line">    System.out.println(<span class="string">&quot;克隆对象：&quot;</span> + cloneType);</span><br><span class="line">    System.out.println(prototype == cloneType);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;原型对象的爱好：&quot;</span> + prototype.getHobbies());</span><br><span class="line">    System.out.println(<span class="string">&quot;克隆对象的爱好：&quot;</span> + cloneType.getHobbies());</span><br><span class="line">    System.out.println(prototype.getHobbies() == cloneType.getHobbies());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行结果</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">原型对象：ConcretePrototype&#123;age=18, name=&#x27;Tom&#x27;, hobbies=[书法, 美术]&#125;</span><br><span class="line">克隆对象：ConcretePrototype&#123;age=18, name=&#x27;Tom&#x27;, hobbies=[书法, 美术, 技术控]&#125;</span><br><span class="line">false</span><br><span class="line">原型对象的爱好：[书法, 美术]</span><br><span class="line">克隆对象的爱好：[书法, 美术, 技术控]</span><br><span class="line">false</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>*<strong>结论</strong> </p>
<p><strong>以上深拷贝两种方式</strong></p>
<ol>
<li>参见 <strong>public ConcretePrototype deepCloneHobbies()</strong> 方法<br> 可以强转成ArrayList, ArrayList 的clone方法就是使用的深拷贝</li>
<li>参见 <strong>public ConcretePrototype deepClone()</strong> 方法<br> 序列化和反序列化 可以破坏单例, 可以利用这一点来返回一个新对象</li>
</ol>
]]></content>
      <categories>
        <category>摘抄笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>外网访问家庭网络小记</title>
    <url>/2021/08/14/%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E7%BD%91%E7%BB%9C%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="记录一次家庭内网使用DDNS让外网访问-同时动态更新域名"><a href="#记录一次家庭内网使用DDNS让外网访问-同时动态更新域名" class="headerlink" title="记录一次家庭内网使用DDNS让外网访问, 同时动态更新域名"></a>记录一次家庭内网使用DDNS让外网访问, 同时动态更新域名</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此篇文章献给&#x27;懒人&#x27;同学~  </span><br><span class="line">相信很多同学在自己家里学习啥的搞些小网站小程序, 比如部署一些在线看视频丶个人网盘丶个人博客等的网站, </span><br><span class="line">但是在公司时想访问记录或查询一些资料, 但是又因为访问不了家庭网络而烦躁...  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此分享能使用任意外网<strong>访问家庭内网</strong>, 同时<strong>动态更新域名</strong>的方法.<br><em><strong>当然在此之前我使用过花生壳、公云等一些软件, 他也可以让你从外网访问家庭内网, 但是别的不说, 他限速而且收费呀… 自己搭建可以全速使用家里的带宽</strong></em><br>步骤如下: </p>
</blockquote>
<h2 id="一-外网访问"><a href="#一-外网访问" class="headerlink" title="一. 外网访问"></a>一. 外网访问</h2><span id="more"></span>
<h3 id="1-申请公网IP"><a href="#1-申请公网IP" class="headerlink" title="1. 申请公网IP"></a>1. 申请公网IP</h3><blockquote>
<p>想访问家庭网络必定需要找家里开网络的运营商, 让他们给开公网IP, 我家里使用的是电信宽带, 电话直接打 10000 号人工服务让他们帮忙开通, 理由嘛很简单( 找个借口说家里安装监控就给你开了 ) , 电信现在默认都是给的私网IP. </p>
</blockquote>
<h3 id="2-光猫改为桥接模式"><a href="#2-光猫改为桥接模式" class="headerlink" title="2. 光猫改为桥接模式"></a>2. 光猫改为桥接模式</h3><blockquote>
<p>申请完公网IP先别急着挂, 还需要让他们把宽带网络改成桥接模式, 后面我们路由器使用拨号上网</p>
</blockquote>
<h3 id="3-查询宽带账号和密码"><a href="#3-查询宽带账号和密码" class="headerlink" title="3. 查询宽带账号和密码"></a>3. 查询宽带账号和密码</h3><blockquote>
<p>由于路由器现在是使用拨号上网, 所以还需要找他运营商拿到宽带的账户和密码, 这些都是必要条件</p>
</blockquote>
<h3 id="4-设备网线连接"><a href="#4-设备网线连接" class="headerlink" title="4. 设备网线连接"></a>4. 设备网线连接</h3><blockquote>
<p>我们使用网线连接 <strong>光猫的网口</strong> 和 <strong>路由器WAN口</strong>, 主机的网线则联通路由器的LAN口, ( WAN口是连接外部网络, LAN口是连接内部网络, 家里的电脑网线都可以用LAN接口连接, 并且<strong>此时我们电脑是没有网络的</strong> )</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">光猫网口  --&gt; 路由器WAN口</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">路由器LAN口 --&gt; 电脑网口</span><br></pre></td></tr></table></figure>

<h3 id="5-设置路由器"><a href="#5-设置路由器" class="headerlink" title="5. 设置路由器"></a>5. 设置路由器</h3><blockquote>
<p>此时已经具备的条件:<br><strong>公网ip, 宽带改为桥接模式, 宽带账号和密码, 设备网线正确连接</strong>  </p>
</blockquote>
<blockquote>
<ul>
<li>开始设置路由器:  </li>
</ul>
<p><strong>我的路由器设备使用的小米路由器, 暂以小米路由器为例</strong>, 路由器网关是 192.168.31.1 , 自己的路由器网关自己搜一下, 然后输入路由器用户名密码</p>
</blockquote>
<blockquote>
<ul>
<li>上网设置<br><img src="/images/img-1.png" alt="上网设置PPPoE拨号"><br>如图, 上网方式选择<strong>PPPOE手动拨号</strong>, 然后输入宽带的账号和密码即可  <br>拨号成功应该就可以上网了~~~</li>
</ul>
</blockquote>
<h3 id="6-检查IP地址"><a href="#6-检查IP地址" class="headerlink" title="6. 检查IP地址"></a>6. 检查IP地址</h3><blockquote>
<p>百度查询自己本机的IP是否与路由器拨号成功获得的IP地址相同.<br><strong>++如果不同, 那一般都是私网ip 没有申请公网ip的.++</strong><br><img src="/images/img-2.png" alt="检查ip是否一致"></p>
</blockquote>
<h3 id="7-路由转发"><a href="#7-路由转发" class="headerlink" title="7. 路由转发"></a>7. 路由转发</h3><blockquote>
<p>一般路由器都拥有路由转发功能, 可以自己配置转发规则.  <br><img src="/images/img-3.png" alt="配置路由转发规则"></p>
</blockquote>
<blockquote>
<ul>
<li>端口转发: 映射端口, 访问外网 ip:端口, 会直接映射到内网的ip:端口<br>如: **访问外网地址 22.135.173.55:8848, 会被转发到内网 192.168.31.26:8000 **<br><img src="/images/img-4.png" alt="端口映射规则"></li>
</ul>
</blockquote>
<h3 id="8-测试"><a href="#8-测试" class="headerlink" title="8. 测试"></a>8. 测试</h3><blockquote>
<ul>
<li>我本地电脑随便开启一个服务<br><img src="/images/img-5.png"><br>部署成功, 内网ip:port  <strong>192.168.31.26:8401</strong><br><img src="/images/img-6.png" alt="启动成功啦, 内网IP访问"></li>
<li>接着使用外网ip访问, <strong>注意自己映射的端口哦</strong><br><img src="/images/img-7.png" alt="外网IP访问"><br>访问成功~~</li>
</ul>
</blockquote>
<h2 id="二-设置动态更新域名"><a href="#二-设置动态更新域名" class="headerlink" title="二. 设置动态更新域名"></a>二. 设置动态更新域名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于电信给的公网IP是动态IP, 每次关闭重启光猫都会更换公网IP地址, 所以这也是个很头疼的事情... </span><br><span class="line">个人方案解决了该情况</span><br></pre></td></tr></table></figure>
<h3 id="1-准备域名-本方案只支持腾讯云域名-对接腾讯云API"><a href="#1-准备域名-本方案只支持腾讯云域名-对接腾讯云API" class="headerlink" title="1. 准备域名 ( 本方案只支持腾讯云域名, 对接腾讯云API )"></a>1. 准备域名 ( 本方案只支持腾讯云域名, 对接腾讯云API )</h3><blockquote>
<p>我使用的方法, 使用Python写了一个脚本, 动态去更新域名, 需要准备一个腾讯云的域名。<br>提供购买链接 <a href="https://buy.cloud.tencent.com/domain?from=console">https://buy.cloud.tencent.com/domain?from=console</a></p>
</blockquote>
<h3 id="2-开通腾讯云-API-密钥"><a href="#2-开通腾讯云-API-密钥" class="headerlink" title="2. 开通腾讯云 API 密钥"></a>2. 开通腾讯云 API 密钥</h3><blockquote>
<p>API 密钥代表你的账号身份和所拥有的权限，使用腾讯云 API 可以操作您名下的所有腾讯云资源。<br>给上链接 <a href="https://console.cloud.tencent.com/cam/capi">https://console.cloud.tencent.com/cam/capi</a></p>
<ul>
<li>开通完后新建密钥( 单机即可, 自动创建 ):<br><img src="/images/img-8.png" alt="新建腾讯云 API 密钥"></li>
</ul>
</blockquote>
<h3 id="3-安装Python3"><a href="#3-安装Python3" class="headerlink" title="3. 安装Python3"></a>3. 安装Python3</h3><blockquote>
<p>由于使用的 Python 写的脚本, 需要环境拥有Python, 版本 3 及以上.<br>安装方法参考 <a href="https://www.cnblogs.com/weven/p/7252917.html">https://www.cnblogs.com/weven/p/7252917.html</a><br>安装完成后查看Python版本:<br><img src="/images/img-9.png" alt="查看Python版本"></p>
</blockquote>
<h3 id="4-献上脚本"><a href="#4-献上脚本" class="headerlink" title="4. 献上脚本"></a>4. 献上脚本</h3><blockquote>
<p><img src="/images/img-10.png" alt="upload successful"></p>
<ul>
<li>复制以下代码 保存为  <strong>xxx.py</strong> 格式就行</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">VERSION = <span class="number">1</span></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha1</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DDnsHelper</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, mid=<span class="number">0</span>, params=&#123;&#125;</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">excute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">import</span> requests</span><br><span class="line">        SecretId = <span class="string">&#x27;*需要填写*&#x27;</span></span><br><span class="line">        SecretKey = <span class="string">&#x27;*需要填写*&#x27;</span></span><br><span class="line">        runningPause = <span class="number">20</span></span><br><span class="line">        domainName = <span class="string">&#x27;pelyhome.cc&#x27;</span> <span class="comment"># *需要填写你自己的域名*</span></span><br><span class="line">        ddnsDomains = [</span><br><span class="line">            &#123;</span><br><span class="line">            	  <span class="comment"># *需要填写你自己的域名*</span></span><br><span class="line">                <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;@.pelyhome.cc&#x27;</span>, </span><br><span class="line">                <span class="string">&#x27;value&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment"># </span></span><br><span class="line">                <span class="string">&#x27;always&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">                <span class="comment"># DNS生存时间 </span></span><br><span class="line">                <span class="string">&#x27;ttl&#x27;</span>: <span class="number">600</span>, </span><br><span class="line">                <span class="comment"># 主机记录, 即域名前缀</span></span><br><span class="line">                <span class="string">&#x27;subDomain&#x27;</span>: <span class="string">&#x27;@&#x27;</span>, </span><br><span class="line">                <span class="string">&#x27;recordId&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                <span class="comment"># 记录类型</span></span><br><span class="line">                <span class="string">&#x27;recordType&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, </span><br><span class="line">                <span class="comment"># 线路类型, 指定细分解析线路</span></span><br><span class="line">                <span class="string">&#x27;recordLine&#x27;</span>: <span class="string">&#x27;默认&#x27;</span>, </span><br><span class="line">                <span class="string">&#x27;description&#x27;</span>: <span class="string">&#x27;本地提供api服务的地址&#x27;</span>,</span><br><span class="line">                <span class="comment"># 查看本地域名的接口, 这是自己写的接口, 仅仅返回一个纯粹的本地外网IP地址</span></span><br><span class="line">                <span class="string">&#x27;localDomain&#x27;</span>: <span class="string">&#x27;https://www.hosix.cn/ip&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;localValue&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">tenXunDDNS_Helper</span>():</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">                self.running = <span class="literal">True</span></span><br><span class="line">                self.action = <span class="string">&quot;&quot;</span></span><br><span class="line">                self.secretId = SecretId</span><br><span class="line">                self.nonce = <span class="number">38651</span></span><br><span class="line">                self.region = <span class="string">&#x27;ap-guangzhou&#x27;</span></span><br><span class="line">                self.secretKey = SecretKey</span><br><span class="line">                self.version = <span class="string">&#x27;2017-03-12&#x27;</span></span><br><span class="line">                self.domain = domainName</span><br><span class="line">                self.url = <span class="string">&#x27;cns.api.qcloud.com/v2/index.php&#x27;</span></span><br><span class="line">                self.httpType = <span class="string">&#x27;https://&#x27;</span></span><br><span class="line">                self.endpoint = self.httpType + self.url</span><br><span class="line">                self.ddnsDomain = ddnsDomains</span><br><span class="line">                self.runningPause = runningPause</span><br><span class="line">                self.remoteRecords = []</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">getServerIp</span>(<span class="params">self</span>):</span></span><br><span class="line">                timeStamp = <span class="built_in">int</span>(time.time())</span><br><span class="line">                params = &#123;&#125;</span><br><span class="line">                params[<span class="string">&#x27;Action&#x27;</span>] = <span class="string">&#x27;RecordList&#x27;</span></span><br><span class="line">                params[<span class="string">&#x27;domain&#x27;</span>] = self.domain</span><br><span class="line">                params[<span class="string">&#x27;Nonce&#x27;</span>] = self.nonce</span><br><span class="line">                params[<span class="string">&#x27;SecretId&#x27;</span>] = self.secretId</span><br><span class="line">                params[<span class="string">&#x27;Timestamp&#x27;</span>] = timeStamp</span><br><span class="line">                s = self.get_string_to_sign(<span class="string">&quot;GET&quot;</span>, self.url, params)</span><br><span class="line">                Signature = self.sign_str(self.secretKey, s, sha1)</span><br><span class="line">                params[<span class="string">&#x27;Signature&#x27;</span>] = Signature</span><br><span class="line">                response = requests.get(self.endpoint, params=params)</span><br><span class="line">                result = json.loads(response.text)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">int</span>(result[<span class="string">&#x27;code&#x27;</span>]) != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">&#x27;获取域名失败&#x27;</span> + <span class="string">&#x27;:&#x27;</span> + <span class="built_in">str</span>(result[<span class="string">&#x27;code&#x27;</span>]) + <span class="string">&#x27;:&#x27;</span> + result[<span class="string">&#x27;message&#x27;</span>])</span><br><span class="line">                data = result[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line"></span><br><span class="line">                self.remoteRecords = data[<span class="string">&#x27;records&#x27;</span>]</span><br><span class="line">                <span class="comment"># print(self.remoteRecords)</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">postServerIp</span>(<span class="params">self, domain</span>):</span></span><br><span class="line">                timeStamp = <span class="built_in">int</span>(time.time())</span><br><span class="line">                params = &#123;&#125;</span><br><span class="line">                params[<span class="string">&#x27;Action&#x27;</span>] = <span class="string">&#x27;RecordCreate&#x27;</span></span><br><span class="line">                params[<span class="string">&#x27;domain&#x27;</span>] = self.domain</span><br><span class="line">                params[<span class="string">&#x27;Nonce&#x27;</span>] = self.nonce</span><br><span class="line">                params[<span class="string">&#x27;SecretId&#x27;</span>] = self.secretId</span><br><span class="line">                params[<span class="string">&#x27;Timestamp&#x27;</span>] = timeStamp</span><br><span class="line">                params[<span class="string">&#x27;subDomain&#x27;</span>] = domain[<span class="string">&#x27;subDomain&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;recordType&#x27;</span>] = domain[<span class="string">&#x27;recordType&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;recordLine&#x27;</span>] = domain[<span class="string">&#x27;recordLine&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;value&#x27;</span>] = domain[<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;ttl&#x27;</span>] = domain[<span class="string">&#x27;ttl&#x27;</span>]</span><br><span class="line">                s = self.get_string_to_sign(<span class="string">&quot;GET&quot;</span>, self.url, params)</span><br><span class="line">                Signature = self.sign_str(self.secretKey, s, sha1)</span><br><span class="line">                params[<span class="string">&#x27;Signature&#x27;</span>] = Signature</span><br><span class="line">                response = requests.get(self.endpoint, params=params)</span><br><span class="line">                result = json.loads(response.text)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">int</span>(result[<span class="string">&#x27;code&#x27;</span>]) != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">&#x27;添加域名失败&#x27;</span> + <span class="string">&#x27;:&#x27;</span> + <span class="built_in">str</span>(result[<span class="string">&#x27;code&#x27;</span>]) + <span class="string">&#x27;:&#x27;</span> + result[<span class="string">&#x27;message&#x27;</span>])</span><br><span class="line">                data = result[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;添加域名成功ip:%s,本地ip:%s,域名:%s&#x27;</span> % (domain[<span class="string">&#x27;value&#x27;</span>], domain[<span class="string">&#x27;localValue&#x27;</span>], domain[<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">updateServerIp</span>(<span class="params">self, domain</span>):</span></span><br><span class="line">                timeStamp = <span class="built_in">int</span>(time.time())</span><br><span class="line">                params = &#123;&#125;</span><br><span class="line">                params[<span class="string">&#x27;Action&#x27;</span>] = <span class="string">&#x27;RecordModify&#x27;</span></span><br><span class="line">                params[<span class="string">&#x27;domain&#x27;</span>] = self.domain</span><br><span class="line">                params[<span class="string">&#x27;Nonce&#x27;</span>] = self.nonce</span><br><span class="line">                params[<span class="string">&#x27;SecretId&#x27;</span>] = self.secretId</span><br><span class="line">                params[<span class="string">&#x27;Timestamp&#x27;</span>] = timeStamp</span><br><span class="line">                params[<span class="string">&#x27;subDomain&#x27;</span>] = domain[<span class="string">&#x27;subDomain&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;recordId&#x27;</span>] = domain[<span class="string">&#x27;recordId&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;recordType&#x27;</span>] = domain[<span class="string">&#x27;recordType&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;recordLine&#x27;</span>] = domain[<span class="string">&#x27;recordLine&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;value&#x27;</span>] = domain[<span class="string">&#x27;localValue&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;ttl&#x27;</span>] = domain[<span class="string">&#x27;ttl&#x27;</span>]</span><br><span class="line">                s = self.get_string_to_sign(<span class="string">&quot;GET&quot;</span>, self.url, params)</span><br><span class="line">                Signature = self.sign_str(self.secretKey, s, sha1)</span><br><span class="line">                params[<span class="string">&#x27;Signature&#x27;</span>] = Signature</span><br><span class="line">                response = requests.get(self.endpoint, params=params)</span><br><span class="line">                result = json.loads(response.text)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">int</span>(result[<span class="string">&#x27;code&#x27;</span>]) != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">&#x27;更新域名失败&#x27;</span> + <span class="string">&#x27;:&#x27;</span> + <span class="built_in">str</span>(result[<span class="string">&#x27;code&#x27;</span>]) + <span class="string">&#x27;:&#x27;</span> + result[<span class="string">&#x27;message&#x27;</span>])</span><br><span class="line">                data = result[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;更新域名成功源ip:%s,本地ip:%s,域名:%s&#x27;</span> % (domain[<span class="string">&#x27;value&#x27;</span>], domain[<span class="string">&#x27;localValue&#x27;</span>], domain[<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">deleteServerIp</span>(<span class="params">self</span>):</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">getLocalDomain</span>(<span class="params">self, domain</span>):</span></span><br><span class="line">                res = requests.get(domain[<span class="string">&#x27;localDomain&#x27;</span>])</span><br><span class="line">                ip = res.content.decode(<span class="string">&quot;utf-8&quot;</span>).strip()</span><br><span class="line">                <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">clearDnsRecord</span>(<span class="params">self</span>):</span></span><br><span class="line">                <span class="keyword">for</span> domain <span class="keyword">in</span> self.ddnsDomain:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> domain[<span class="string">&#x27;always&#x27;</span>]:</span><br><span class="line">                        domain[<span class="string">&#x27;value&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                        domain[<span class="string">&#x27;localValue&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">                self.getServerIp()</span><br><span class="line">                <span class="keyword">for</span> domain <span class="keyword">in</span> self.ddnsDomain:</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">not</span> domain[<span class="string">&#x27;always&#x27;</span>]):</span><br><span class="line">                        <span class="comment"># 获取本地ip</span></span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            domain[<span class="string">&#x27;localValue&#x27;</span>] = self.getLocalDomain(domain)</span><br><span class="line">                        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">&quot;获取本地ip失败 不更新:%s,本地ip:%s,域名:%s&quot;</span> % (</span><br><span class="line">                            domain[<span class="string">&#x27;value&#x27;</span>], domain[<span class="string">&#x27;localValue&#x27;</span>], domain[<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    flag = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">for</span> remoteDomain <span class="keyword">in</span> self.remoteRecords:</span><br><span class="line">                        <span class="keyword">if</span> (domain[<span class="string">&#x27;subDomain&#x27;</span>] == remoteDomain[<span class="string">&#x27;name&#x27;</span>]):</span><br><span class="line">                            domain[<span class="string">&#x27;recordId&#x27;</span>] = remoteDomain[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">                            domain[<span class="string">&#x27;value&#x27;</span>] = remoteDomain[<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">                            flag = <span class="literal">True</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> flag:</span><br><span class="line">                        <span class="keyword">if</span> (domain[<span class="string">&#x27;value&#x27;</span>] == domain[<span class="string">&#x27;localValue&#x27;</span>]):</span><br><span class="line">                            <span class="keyword">pass</span></span><br><span class="line">                            <span class="comment"># print(&quot;无需更新ip:%s,本地ip:%s,域名:%s&quot; % (domain[&#x27;value&#x27;],domain[&#x27;localValue&#x27;],domain[&#x27;name&#x27;]))</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            self.updateServerIp(domain)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        domain[<span class="string">&#x27;value&#x27;</span>] = domain[<span class="string">&#x27;localValue&#x27;</span>]</span><br><span class="line">                        self.postServerIp(domain)</span><br><span class="line">                self.clearDnsRecord()</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">                start_time = <span class="built_in">int</span>(time.time())</span><br><span class="line">                <span class="keyword">while</span> self.running:</span><br><span class="line">                    next_time = <span class="built_in">int</span>(time.time()) + self.runningPause</span><br><span class="line">                    <span class="keyword">if</span> (next_time - start_time) &gt; self.runningPause:</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            self.run()</span><br><span class="line">                        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                            <span class="built_in">print</span>(e.__str__())</span><br><span class="line">                        start_time = start_time + self.runningPause</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        time.sleep(self.runningPause / <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">get_string_to_sign</span>(<span class="params">self, method, endpoint, params</span>):</span></span><br><span class="line">                s = method + endpoint + <span class="string">&quot;?&quot;</span></span><br><span class="line">                query_str = <span class="string">&quot;&amp;&quot;</span>.join(<span class="string">&quot;%s=%s&quot;</span> % (k, params[k]) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">sorted</span>(params))</span><br><span class="line">                <span class="comment"># print(s + query_str)</span></span><br><span class="line">                <span class="keyword">return</span> s + query_str</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">sign_str</span>(<span class="params">self, key, s, method</span>):</span></span><br><span class="line">                hmac_str = hmac.new(key.encode(<span class="string">&quot;utf8&quot;</span>), s.encode(<span class="string">&quot;utf8&quot;</span>), method).digest()</span><br><span class="line">                <span class="keyword">return</span> base64.b64encode(hmac_str)</span><br><span class="line"></span><br><span class="line">        t1 = tenXunDDNS_Helper()</span><br><span class="line">        t1.start()</span><br><span class="line">d = DDnsHelper()</span><br><span class="line">d.excute()</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>最后双击运行~ OK  </li>
</ul>
</blockquote>
<h3 id="5-运行原理和注意事项"><a href="#5-运行原理和注意事项" class="headerlink" title="5. 运行原理和注意事项"></a>5. 运行原理和注意事项</h3><blockquote>
<ul>
<li>原理:<br>该脚本是通过查询公网IP接口:<a href="https://www.hosix.cn/ip">https://www.hosix.cn/ip</a> 来判断公网ip是否发生了改变, 如果发生了改变, 就会调用腾讯云API去动态更新域名. 非常简单…..</li>
<li>注意事项:   </li>
</ul>
<p>1.该脚本需要持续运行, 如果是Linux系统, 直接挂后台运行即可, 该脚本资源消耗不高<br>2.如果提示没requests 运行下, 打开cmd窗口<br>输入: <strong>pip install requests</strong><br><img src="/images/img-12.png" alt="pip install requests"><br>3.如运行闪退, 请检查域名等是否正确填写</p>
</blockquote>
<p>如有问题请评论或留言: <a href="mailto:&#53;&#52;&#52;&#x30;&#49;&#48;&#49;&#54;&#x35;&#64;&#113;&#113;&#x2e;&#99;&#111;&#109;">&#53;&#52;&#52;&#x30;&#49;&#48;&#49;&#54;&#x35;&#64;&#113;&#113;&#x2e;&#99;&#111;&#109;</a></p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>访问家庭内网</tag>
        <tag>动态DDNS</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程基本原理</title>
    <url>/2022/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="一、多线程的基本原理"><a href="#一、多线程的基本原理" class="headerlink" title="一、多线程的基本原理"></a>一、多线程的基本原理</h1><p>线程的start方法，实际上底层做了很多事情，具体的实现简图如下，画得不一定工整，但是能够表达大概意思就行。</p>
<p>OS调度算法有很多，比如先来先服务调度算法（FIFO）、最短优先（就是对短作业的优先调度）、时间片轮转调度等</p>
<p><img src="/images/img-127.png"></p>
<h2 id="线程的运行状态"><a href="#线程的运行状态" class="headerlink" title="线程的运行状态"></a>线程的运行状态</h2><p>先来了解线程的运行状态，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStatus</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TIME_WAITING</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ,<span class="string">&quot;timewaiting&quot;</span>).start();</span><br><span class="line">        <span class="comment">//WAITING，线程在ThreadStatus类锁上通过wait进行等待</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (ThreadStatus.class)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ThreadStatus.class.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ,<span class="string">&quot;Waiting&quot;</span>).start();</span><br><span class="line">        <span class="comment">//线程在ThreadStatus加锁后，不会释放锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> BlockedDemo(),<span class="string">&quot;BlockDemo-01&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> BlockedDemo(),<span class="string">&quot;BlockDemo-02&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockedDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BlockedDemo.class)&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>运行上述示例，打开终端命令，输入”jps”（显示当前所有Java进程pid）；根据获取到的pid， 通过 jstack pid ，可以打印指定Java进程ID的堆栈信息通过堆栈信息，可以看到线程的运行状态</strong></p>
</blockquote>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>通过上面这段代码可以看到，线程在运行过程中，会存在几种不同的状态，一般来说，在Java中，线程的状态一共是6种状态，分别是</p>
<ul>
<li>NEW：初始状态，线程被构建，但是还没有调用start方法</li>
<li>RUNNABLED：运行状态，JAVA线程把操作系统中的就绪和运行两种状态统一称为“运行中”</li>
<li>BLOCKED：阻塞状态，表示线程进入等待状态,也就是线程因为某种原因放弃了CPU使用权，阻塞也分为几种情况<ul>
<li>Ø 等待阻塞：运行的线程执行wait方法，jvm会把当前线程放入到等待队列</li>
<li>Ø 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被其他线程锁占用了，那么jvm会把当前的线程放入到锁池中</li>
<li>Ø 其他阻塞：运行的线程执行Thread.sleep或者t.join方法，或者发出了I/O请求时，JVM会把当前线程设置为阻塞状态，当sleep结束、join线程终止、io处理完毕则线程恢复</li>
</ul>
</li>
<li>WAITING: 等待状态</li>
<li>TIME_WAITING：超时等待状态，超时以后自动返回</li>
<li>TERMINATED：终止状态，表示当前线程执行完毕</li>
</ul>
<p><img src="/images/img-129.png"></p>
<h1 id="二、线程的终止"><a href="#二、线程的终止" class="headerlink" title="二、线程的终止"></a>二、线程的终止</h1><p>如何正确停止一个线程呢？这个问题要细聊，还是有很多东西可以说的。</p>
<p>我们知道Thread提供了线程的一些操作方法，比如stop、suspend等，这些方法可以终止一个线程或者挂起一个线程，但是这些方法都不建议大家使用。原因比较简单，</p>
<p>举个例子，假设一个线程中，有多个任务在执行，此时，如果调用stop方法去强行中断，那么这个时候相当于是发送一个指令告诉操作系统把这个线程结束掉，但是操作系统的这个结束动作完成不代表线程中的任务执行完成，很可能出现线程的任务执行了一般被强制中断，最终导致数据产生问题。这种行为类似于在linux系统中执行 kill -9类似，它是一种不安全的操作。</p>
<p>那么除了这种方法之外，还有什么方式可以实现线程的终止呢？要了解这个问题，我们首先需要知道，一个线程什么情况下算是终止了。</p>
<h2 id="一个线程在什么情况下是执行结束了"><a href="#一个线程在什么情况下是执行结束了" class="headerlink" title="一个线程在什么情况下是执行结束了"></a>一个线程在什么情况下是执行结束了</h2><p>我们分析一下下面这段代码，通过start（）启动一个线程之后，本质上就是执行这个线程的run方法。那么如果这个线程在run方法执行完之前，一直处于运行状态，直到run方法中的指令执行完毕，那么这个线程就会被销毁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread.run()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyThread myThread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">myThread1.start();</span><br></pre></td></tr></table></figure>

<p>在正常情况下，这个线程是不需要人为干预去结束的。如果要强制结束，只能走stop这个方法。</p>
<p>那在哪些情况下，线程的中断需要外部干预呢？</p>
<ul>
<li><em>线程中存在无限循环执行，比如while(true)循环</em></li>
<li><em>线程中存在一些阻塞的操作，比如sleep、wait、join等。</em></li>
</ul>
<h2 id="存在循环的线程"><a href="#存在循环的线程" class="headerlink" title="存在循环的线程"></a>存在循环的线程</h2><p>假设存在如下场景，在run方法中，存在一个while循环，因为这个循环的存在使得这个run方法一直无法运行结束，这种情况下，如何终止呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread.run()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyThread myThread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">myThread1.start();</span><br></pre></td></tr></table></figure>

<p>按照我们开发的思维来说，首先要解决的就是，while(true)这个循环，必须要有一个结束条件，其次是 要在其他地方能够修改这个结束条件让该线程感知到变化。假设我们把while(true)改成while(ﬂag)，这个ﬂag可以作为共享变量被外部修改，修改之后使得循环条件无法被满足，从而退出循环并且结束线程。</p>
<p>这段逻辑其实非常简单，其实就是给了线程一个退出的条件，如果没有这个条件，那么线程将会一直运行。</p>
<p>实际上，在Java提供了一个 interrupt方法，这个方法就是实现线程中断操作的，它的作用和上面讲的 这个案例的作用一样。</p>
<h2 id="interrupt方法"><a href="#interrupt方法" class="headerlink" title="interrupt方法"></a>interrupt方法</h2><p>当其他线程通过调用当前线程的interrupt方法，表示向当前线程打个招呼，告诉他可以中断线程的执行了，至于什么时候中断，取决于当前线程自己。</p>
<p>线程通过检查自身是否被中断来进行相应，可以通过isInterrupted()来判断是否被中断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                <span class="comment">//默认情况下 isInterrupted返回false、通过thread.interrupt变成了true</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Num:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        ,<span class="string">&quot;interruptDemo&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        <span class="comment">//加和不加的效果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止，因此这种终止线程的做法显得更加安全和优雅</p>
<h2 id="处于阻塞状态下的线程中断"><a href="#处于阻塞状态下的线程中断" class="headerlink" title="处于阻塞状态下的线程中断"></a>处于阻塞状态下的线程中断</h2><p>另外一种情况，就是当线程处于阻塞状态下时，我想要中断这个线程，那怎么做呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Num:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        ,<span class="string">&quot;interruptDemo&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个例子中反馈出一个问题，我们平时在线程中使用的sleep、 wait、join等操作，它都会抛出一个 InterruptedException 异常，为什么会抛出异常，是因为它在阻塞期间，必须要能够响应被其他线程发 起中断请求之后的一个响应，而这个响应是通过InterruptedException来体现的。</p>
<p><strong>但是这里需要注意的是，在这个异常中如果不做任何处理的话，我们是无法去中断线程的，因为当前的 异常只是响应了外部对于这个线程的中断命令，同时，线程的中断状态也会复位，如果需要中断，则还 需要在catch中添加下面的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="comment">//再次中断</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Num:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        ,<span class="string">&quot;interruptDemo&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，InterruptedException 异常的抛出并不意味着线程必须终止，而是提醒当前线程有中断的操作发生，至于接下来怎么处理取决于线程本身，比如</p>
<ol>
<li>直接捕获异常不做任何处理</li>
<li>将异常往外抛出</li>
<li>停止当前线程，并打印异常信息</li>
</ol>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>线程安全</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>委派模式</title>
    <url>/2022/02/23/%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一、委派模式的定义"><a href="#一、委派模式的定义" class="headerlink" title="一、委派模式的定义"></a>一、委派模式的定义</h1><p><strong>委派模式</strong>(Delegate Pattern)<br> 又叫委托模式. 它的基本作用就是负责任务的调度和任务的分配, 将任务的分配和执行分离开来. 可以看做是一种特殊情况下的静态代理的全权代理.</p>
<p><strong>不属于GOF 23种设计模式之一</strong>.</p>
<p><strong>属于行为型模式</strong>.</p>
<h1 id="二、委派模式和代理模式的区别"><a href="#二、委派模式和代理模式的区别" class="headerlink" title="二、委派模式和代理模式的区别"></a>二、委派模式和代理模式的区别</h1><ol>
<li>委派模式是行为型模式, 代理模式是结构型模式.</li>
</ol>
<ol start="2">
<li>委派模式注重的是任务派遣, 注重结果;<br><br>代理模式注重的是代码增强, 注重过程.</li>
</ol>
<ol start="3">
<li>委派模式是一种特殊的静态代理, 相当于全权代理.</li>
</ol>
<h1 id="三、SpringMVC中的委派模式"><a href="#三、SpringMVC中的委派模式" class="headerlink" title="三、SpringMVC中的委派模式"></a>三、SpringMVC中的委派模式</h1><p><img src="/images/img-85.png" alt="MVC"></p>
<p><strong>从图中可以看出dispatcherServlet更像是一个分发任务的分发者, 但其实springmvc本身就是一个大的委派.</strong></p>
<ol>
<li>web浏览器发送请求给dispatchServlet</li>
</ol>
<ol start="2">
<li>dispatchServlet委派HandlerMapping去找到url所对应的方法。</li>
</ol>
<ol start="3">
<li>通过HandlerMapping找到的方法dispatcherServlet委派处理器适配器去调用方法返回ModelAndView</li>
</ol>
<ol start="4">
<li>紧接着委派视图解析器去渲染modelAndView</li>
</ol>
<ol start="5">
<li>最终返回给web浏览器。</li>
</ol>
<p><strong>从上述流程可以看出，dispatcherServlet委派的对象不是同一类对象，而是三个大的类，HandlerMap，处理器，视图解析器。</strong></p>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p><strong>委派模式是一种设计思想，它想表达的是，尽量将工作分发给专门的对象去做</strong></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>通过任务委派能将一个大型的任务细化, 然后通过统一管理这些子任务的完成情况实现任务跟进, 能够加快任务的执行效率.</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>任务委派方式需要根据任务的复杂情况进行不同的改变, 在任务比较复杂的情况下可能需要进行多重委派, 容易造成紊乱.</p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2022/02/10/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一-类型"><a href="#一-类型" class="headerlink" title="一. 类型"></a>一. 类型</h1><p>创建型模式</p>
<h1 id="二-意图"><a href="#二-意图" class="headerlink" title="二. 意图"></a>二. 意图</h1><p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<h1 id="三-主要解决"><a href="#三-主要解决" class="headerlink" title="三. 主要解决"></a>三. 主要解决</h1><p>主要解决接口选择的问题。</p>
<h1 id="四-工厂模式多种写法"><a href="#四-工厂模式多种写法" class="headerlink" title="四. 工厂模式多种写法"></a>四. 工厂模式多种写法</h1><ol>
<li>简单工厂(静态工厂)</li>
<li>工厂方法</li>
<li>抽象工厂</li>
</ol>
]]></content>
      <categories>
        <category>摘抄笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2022/02/10/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一-类型"><a href="#一-类型" class="headerlink" title="一. 类型"></a>一. 类型</h1><p>创建型模式</p>
<h1 id="二-定义"><a href="#二-定义" class="headerlink" title="二. 定义"></a>二. 定义</h1><p>建造者模式 是将一个复杂对象的构建与他的表示分离, 使得同样的构建过程可以创建不同的表示. </p>
<p>特征: 用户只需要指定需要创建的类型就可以获得对象, 建造过程及细节不需要了解.</p>
<h1 id="三-优缺点"><a href="#三-优缺点" class="headerlink" title="三. 优缺点"></a>三. 优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>封装性好, 创建和使用分离.</p>
<p>扩展性好, 建造类之间独立、一定程度上解耦.</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>产生多余的 Builder 对象</p>
<p>产品内部发生改变, 建造者都要修改, 成本较高</p>
<h1 id="四-简单写法"><a href="#四-简单写法" class="headerlink" title="四. 简单写法"></a>四. 简单写法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String ppt;</span><br><span class="line">    <span class="keyword">private</span> String video;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String homework;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CourseBuilder&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, ppt=&#x27;&quot;</span> + ppt + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, video=&#x27;&quot;</span> + video + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, note=&#x27;&quot;</span> + note + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, homework=&#x27;&quot;</span> + homework + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseBuilder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Course course = <span class="keyword">new</span> Course();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CourseBuilder <span class="title">addName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        course.setName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> CourseBuilder <span class="title">addPPT</span><span class="params">(String ppt)</span> </span>&#123;</span><br><span class="line">        course.setPpt(ppt);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> CourseBuilder <span class="title">addVideo</span><span class="params">(String video)</span> </span>&#123;</span><br><span class="line">        course.setVideo(video);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> CourseBuilder <span class="title">addNote</span><span class="params">(String note)</span> </span>&#123;</span><br><span class="line">        course.setNote(note);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> CourseBuilder <span class="title">addHomework</span><span class="params">(String homework)</span> </span>&#123;</span><br><span class="line">        course.setHomework(homework);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Course <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> course;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CourseBuilder builder = <span class="keyword">new</span> CourseBuilder();</span><br><span class="line"></span><br><span class="line">        builder.addName(<span class="string">&quot;设计模式&quot;</span>)</span><br><span class="line">                .addPPT(<span class="string">&quot;【PPT课件】&quot;</span>)</span><br><span class="line">                .addVideo(<span class="string">&quot;【回放视频】&quot;</span>)</span><br><span class="line">                .addNote(<span class="string">&quot;【课堂笔记】&quot;</span>)</span><br><span class="line">                .addHomework(<span class="string">&quot;【课后作业】&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(builder.build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行结果</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">CourseBuilder&#123;name=&#x27;设计模式&#x27;, ppt=&#x27;【PPT课件】&#x27;, video=&#x27;【回放视频】&#x27;, note=&#x27;【课堂笔记】&#x27;, homework=&#x27;【课后作业】&#x27;&#125;</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>摘抄笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数组 - 两个数组的交集 II</title>
    <url>/2022/01/14/%E6%95%B0%E7%BB%84-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-II/</url>
    <content><![CDATA[<h1 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a>两个数组的交集 II</h1><p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p>
<p>示例 1：</p>
<p>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2,2]<br>示例 2:</p>
<p>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出：[4,9]
 </p>
<p>提示：</p>
<p>1 &lt;= nums1.length, nums2.length &lt;= 1000<br>0 &lt;= nums1[i], nums2[i] &lt;= 1000
 </p>
<p>进阶：</p>
<p>如果给定的数组已经排好序呢？你将如何优化你的算法？<br>如果 nums1 的大小比 nums2 小，哪种方法更优？<br>如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2) &#123;</span><br><span class="line">        Arrays.sort(arr1);</span><br><span class="line">        Arrays.sort(arr2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> arr1Len = arr1.length, arr2Len = arr2.length;</span><br><span class="line">        <span class="keyword">int</span> len = Math.min(arr1Len, arr2Len);</span><br><span class="line">        <span class="keyword">int</span>[] newInt = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; arr1Len &amp;&amp; j &lt; arr2Len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] == arr2[j]) &#123;</span><br><span class="line">                newInt[k++] = arr1[i];</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr1[i] &lt; arr2[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(newInt, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法小抄</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组 - 删除排序数组中的重复项</title>
    <url>/2022/01/14/%E6%95%B0%E7%BB%84-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index6] != nums[i]) &#123;</span><br><span class="line">                index ++;</span><br><span class="line">                nums[index] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法小抄</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组 - 只出现一次的数字</title>
    <url>/2022/01/14/%E6%95%B0%E7%BB%84-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:</p>
<p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p>
<p>输入: [4,1,2,1,2]<br>输出: 4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">            a = num ^ a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法小抄</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>数组 - 旋转数组</title>
    <url>/2022/01/15/%E6%95%B0%E7%BB%84-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h1><p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入：nums = [-1,-100,3,99], k = 2</span><br><span class="line">输出：[3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右轮转 1 步: [99,-1,-100,3]</span><br><span class="line">向右轮转 2 步: [3,99,-1,-100]</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。</span><br><span class="line">你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;数组旋转前: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">    rotate(arr, k);</span><br><span class="line">    System.out.println(<span class="string">&quot;数组旋&quot;</span> + k + <span class="string">&quot;个位置后: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">    执行结果</span><br><span class="line">数组旋转前: [<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line">数组旋<span class="number">3</span>个位置后: [<span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>]</span><br><span class="line">    ----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    k = k % nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] new1 = Arrays.copyOfRange(nums, nums.length-k, nums.length);</span><br><span class="line">    System.arraycopy(nums, <span class="number">0</span>, nums, k, nums.length - k);</span><br><span class="line">    System.arraycopy(new1, <span class="number">0</span>, nums, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法二</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    k = k % nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                temp = nums[j];</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[<span class="number">0</span>] = temp;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法小抄</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组 - 是否存在重复元素</title>
    <url>/2022/01/14/%E6%95%B0%E7%BB%84-%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h1><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,1]<br>输出: true<br>示例 2:</p>
<p>输入: [1,2,3,4]<br>输出: false<br>示例 3:</p>
<p>输入: [1,1,1,3,3,4,3,2,4,2]<br>输出: true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">//因为集合set中不能有重复的元素，如果有重复的</span></span><br><span class="line">            <span class="comment">//元素添加，就会添加失败</span></span><br><span class="line">            <span class="keyword">if</span> (!set.add(num))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法小抄</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组 - 移动零</title>
    <url>/2022/01/14/%E6%95%B0%E7%BB%84-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p>
<p>说明:</p>
<p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[index++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; nums.length)&#123;</span><br><span class="line">            nums[index++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法小抄</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>日志分析</title>
    <url>/2022/03/05/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、Thread-Dump日志分析"><a href="#一、Thread-Dump日志分析" class="headerlink" title="一、Thread Dump日志分析"></a>一、Thread Dump日志分析</h1><p>接下来给大家再讲点在工作中比较实用的一个内容。就是我们在使用线程的时候，如果出现问题，怎么 排查？比如说</p>
<ul>
<li>CPU占用率很高，响应很慢</li>
<li>CPU占用率不高，但响应很慢</li>
<li>线程出现死锁的情况</li>
</ul>
<h2 id="演示代码"><a href="#演示代码" class="headerlink" title="演示代码"></a>演示代码</h2><p>为了更好的体现效果，我们通过以下代码进行演示。</p>
<p>编写一个java项目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制器接口层</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/loop&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dumpWhile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> WhileThread()).start();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/dead&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dumpDeadLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread a = <span class="keyword">new</span> ThreadRunA();</span><br><span class="line">        Thread b = <span class="keyword">new</span> ThreadRunB();</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhileThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程A</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadRunA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;================A===================&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (A.A) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我要开始执行任务A。。。。&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (B.B) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在执行任务结束了A。。。。&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + B.B.hashCode() + <span class="string">&quot;:&quot;</span></span><br><span class="line">                    + A.A.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程B</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadRunB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;================B===================&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (B.B) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我要开始执行任务B。。。。&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (A.A) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在执行任务结束了B。。。。&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + B.B + <span class="string">&quot;:&quot;</span> + A.A);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -jar -Dserver.port=8088 thread-demo-0.0.1-SNAPSHOT.jar &gt; all.log &amp;</span><br><span class="line">//打成jar后运行</span><br></pre></td></tr></table></figure>

<h2 id="CPU占用率不高，但响应很慢"><a href="#CPU占用率不高，但响应很慢" class="headerlink" title="CPU占用率不高，但响应很慢"></a>CPU占用率不高，但响应很慢</h2><p>通过 curl <a href="http://127.0.0.1:8088/dead">http://127.0.0.1:8088/dead</a> 演示死锁的场景</p>
<p>查看死锁问题的操作步骤如下：</p>
<ul>
<li>通过 jps命令，查看java进程的pid</li>
<li>通过 jstack 查看线程日志</li>
</ul>
<p>如果存在死锁情况，Thread Dump 日志里面肯定会给出 Found one Java-level deadlock:信息。只要 找到这个信息就可以立马定位到问题并且去解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">	waiting to lock monitor <span class="number">0x0000000026070c88</span> (object <span class="number">0x00000007163b7d78</span>, a java.lang.Integer),</span><br><span class="line">	which is held by <span class="string">&quot;Thread-0&quot;</span></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">	waiting to lock monitor <span class="number">0x00000000260735c8</span> (object <span class="number">0x0000000716649aa8</span>, a java.lang.Integer),</span><br><span class="line">	which is held by <span class="string">&quot;Thread-1&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="CPU占用率很高，响应很慢"><a href="#CPU占用率很高，响应很慢" class="headerlink" title="CPU占用率很高，响应很慢"></a>CPU占用率很高，响应很慢</h2><p>有的时候我们会发现CPU占用率很高，系统日志也看不出问题，那么这种情况下，我们需要去看一下运 行中的线程有没有异常。</p>
<p>执行 curl <a href="http://127.0.0.1:8088/loop%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%83%85%E5%86%B5%E3%80%82">http://127.0.0.1:8088/loop这个方法，会出现一个线程死循环的情况。</a></p>
<ul>
<li><p>通过 top -c 动态显示进程及占用资源的排行榜，从而找到占用CPU最高的进程PID，得到的</p>
<p>  <strong>PID=80972</strong></p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"></span><br><span class="line">80972 root      20   0 7773456 296124  12904 S 100.2  1.8   0:38.83 java</span><br></pre></td></tr></table></figure></li>
<li><p>然后再定位到对应的线程，   top -H -p 80972 查找到该进程中最消耗CPU的线程，得到</p>
<p>  <strong>PID=81122</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND </span><br><span class="line">81122 root 20 0 7773456 258504 12932 R 99.8 1.6 5:56.34 java </span><br><span class="line">80972 root 20 0 7773456 258504 12932 S 0.0 1.6 0:00.00 java</span><br></pre></td></tr></table></figure></li>
<li><p>通过 printf “0x%x\n” 81122 命令，把对应的线程PID转化为16进制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost test]# printf &quot;0x%x\n&quot; 81122 </span><br><span class="line">0x13ce2</span><br></pre></td></tr></table></figure></li>
<li><p>截止执行这个命令 jstack 80972 | grep -A 20 0x13ce2 查看线程Dump日志，其中-A 20表示展示20行， 80972表示进程ID， 0x13ce2表示线程ID</p>
<p>  <img src="/images/img-130.png"></p>
</li>
</ul>
<p>从上述内容可以看出，是WhileThread.run方法中，执行的逻辑导致CPU占用过高。</p>
]]></content>
      <categories>
        <category>日志分析</category>
      </categories>
  </entry>
  <entry>
    <title>最大公约数</title>
    <url>/2022/02/08/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
    <content><![CDATA[<h1 id="更相减损术"><a href="#更相减损术" class="headerlink" title="更相减损术"></a>更相减损术</h1><p>更相减损术 出自中国古代 ‘九章算术’, 是一种最大公约数的算法.</p>
<p>他的原理简单: 两个正整数a和b(a&gt;b), 他们的最大公约数等于a-b的差值c和较小数b之间的最大公约数.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更相减损术</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最大公约数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getGreatestCommonDivisorV1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> big = Math.max(a, b);</span><br><span class="line">    <span class="keyword">int</span> small = Math.min(a, b);</span><br><span class="line">    <span class="keyword">return</span> getGreatestCommonDivisorV2(big - small, small);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h1 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h1><p>辗转相除法, 又名欧几里得算法, 该算法目的是求出两个正整数的最大公约数.</p>
<p>该算法基于一个定理: 两个正整数a和b(a&gt;b), 他们的最大公约数等于a除以b的余数c和b之间的最大公约数.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辗转相除法 (欧几里得算法)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最大公约数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getGreatestCommonDivisorV2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> big = Math.max(a, b);</span><br><span class="line">    <span class="keyword">int</span> small = Math.min(a, b);</span><br><span class="line">    <span class="keyword">if</span> (big % small == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getGreatestCommonDivisorV2(big % small, small);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>二叉堆、堆排序</title>
    <url>/2022/01/15/%E6%8E%92%E5%BA%8F-%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="二叉堆实现"><a href="#二叉堆实现" class="headerlink" title="二叉堆实现"></a>二叉堆实现</h1><p>以下为最小堆代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用例适用于  &#x27;最小堆&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 二叉堆 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        upAdjust(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        build(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ------------------------------------------------------------</span><br><span class="line">    打印结果</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>]</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">66</span>]</span><br><span class="line">    ------------------------------------------------------------</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上浮调整</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> childIndex = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> parentIndex = (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// temp 用于保存插入的叶子节点值, 用于最后的赋值</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[childIndex];</span><br><span class="line">        <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &lt; arr[parentIndex]) &#123;</span><br><span class="line">            <span class="comment">// 无需真正交换, 单项赋值即可</span></span><br><span class="line">            arr[childIndex] = arr[parentIndex];</span><br><span class="line">            childIndex = parentIndex;</span><br><span class="line">            parentIndex = (parentIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[childIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下沉调整</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr         要调整的堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentIndex 要 &#x27;下沉&#x27; 的父节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length      堆的有效大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// temp 用于保存插入的叶子节点值, 用于最后的赋值</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[parentIndex];</span><br><span class="line">        <span class="keyword">int</span> childIndex = parentIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line">            <span class="comment">// 如果有右节点, 且右节点小于左节点的值, 则定位到右节点</span></span><br><span class="line">            <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; arr[childIndex + <span class="number">1</span>] &lt; arr[childIndex]) &#123;</span><br><span class="line">                childIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果父节点小于子节点的值则跳出, 不需要调整</span></span><br><span class="line">            <span class="keyword">if</span> (temp &lt; arr[childIndex]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            arr[parentIndex] = arr[childIndex];</span><br><span class="line">            parentIndex = childIndex;</span><br><span class="line">            childIndex = childIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        arr[parentIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建二叉堆</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 二叉堆本质上是完全二叉树, 但是存储方式不是链式存储, 而是顺序存储, 所用数据结构为数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从最后一个非叶子节点开始, 依次做&#x27;下沉&#x27;调整</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (arr.length - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            downAdjust(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 堆排序 </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        二叉堆.build(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 最后一个元素和第一个元素交换</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line"></span><br><span class="line">            二叉堆.downAdjust(arr,<span class="number">0</span>,i);</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>排序结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法小抄</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>数组</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法模式</title>
    <url>/2022/02/23/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一、定义-只能通过继承来实现-使用覆盖实现微调"><a href="#一、定义-只能通过继承来实现-使用覆盖实现微调" class="headerlink" title="一、定义(只能通过继承来实现, 使用覆盖实现微调)"></a>一、定义(只能通过继承来实现, 使用覆盖实现微调)</h1><p><strong>模板方法模式</strong>(Template Method Pattern) 通常又叫模板模式, 是指定义一个算法的骨架, 并允许子类成为其中的一个或者多个步骤提供实现.</p>
<p>模板方法使得子类可以在不改变算法结构的情况下, 重新定义算法的某些步骤.</p>
<p><strong>属于行为型设计模式.</strong></p>
<h1 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h1><ol>
<li><p>一次性实现一个算法不变的部分, 并将可变的行为留给子类来实现.</p>
</li>
<li><p>各子类中公共的行为被提取出来并集中到一个公共的父类中, 从而避免代码重复.</p>
</li>
</ol>
<h1 id="三、Java代码简单写法"><a href="#三、Java代码简单写法" class="headerlink" title="三、Java代码简单写法"></a>三、Java代码简单写法</h1><p>使用三个类简单表述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 程抽象类, 用于统一课程的特性, 设置了一个钩子方法用于是否&#x27;检查作业&#x27;步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbastractCourse</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">createCourse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、发布预习资料</span></span><br><span class="line">        postPreResoucse();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、制作课件</span></span><br><span class="line">        createPPT();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、直播授课</span></span><br><span class="line">        liveVideo();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4、上传课后资料</span></span><br><span class="line">        postResource();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5、布置作业</span></span><br><span class="line">        postHomework();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6、检查作业, 我们可以交给子类实现, 可能每个课程检查作业方式不一样</span></span><br><span class="line">        <span class="comment">//(也可能不需要检查作业), 我们可以交给用户自己来决定是否检查作业 </span></span><br><span class="line">        <span class="keyword">if</span>(needCheckHomework())&#123;</span><br><span class="line">            checkHomework();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">checkHomework</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//钩子方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needCheckHomework</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  <span class="keyword">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postHomework</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;布置作业&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postResource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;上传课后资料&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">liveVideo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;直播授课&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">createPPT</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;制作课件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postPreResoucse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发布预习资料&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2. Java课程实现类, 该类我们可以自定义决定是否可以&#x27;检查作业&#x27;的步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCourse</span> <span class="keyword">extends</span> <span class="title">AbastractCourse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> needCheckHomework = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNeedCheckHomework</span><span class="params">(<span class="keyword">boolean</span> needCheckHomework)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.needCheckHomework = needCheckHomework;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needCheckHomework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.needCheckHomework;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkHomework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;检查Java作业&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3. ython课程实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonCourse</span> <span class="keyword">extends</span> <span class="title">AbastractCourse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkHomework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;检查Python作业&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========Java课程=========&quot;</span>);</span><br><span class="line">        JavaCourse java = <span class="keyword">new</span> JavaCourse();</span><br><span class="line">        <span class="comment">// 设置java需要检查作业</span></span><br><span class="line">        java.setNeedCheckHomework(<span class="keyword">true</span>);</span><br><span class="line">        java.createCourse();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=========Python课程=========&quot;</span>);</span><br><span class="line">        PythonCourse python = <span class="keyword">new</span> PythonCourse();</span><br><span class="line">        python.createCourse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------</span><br><span class="line"></span><br><span class="line">=========Java课程=========</span><br><span class="line">发布预习资料</span><br><span class="line">制作课件</span><br><span class="line">直播授课</span><br><span class="line">上传课后资料</span><br><span class="line">布置作业</span><br><span class="line">检查Java作业</span><br><span class="line">=========Python课程=========</span><br><span class="line">发布预习资料</span><br><span class="line">制作课件</span><br><span class="line">直播授课</span><br><span class="line">上传课后资料</span><br><span class="line">布置作业</span><br><span class="line"></span><br><span class="line">---------------------------------------------</span><br></pre></td></tr></table></figure>

<h1 id="四、优点"><a href="#四、优点" class="headerlink" title="四、优点"></a>四、优点</h1><ol>
<li><p>利用模板方法将相同处理逻辑的代码放到抽象父类中, 可以提高代码的复用性, 也符合开闭原则. </p>
</li>
<li><p>将不同代码放到不同子类中, 通过对子类的扩展增加新的行为, 提高代码的扩展性.</p>
</li>
</ol>
<h1 id="五、缺点"><a href="#五、缺点" class="headerlink" title="五、缺点"></a>五、缺点</h1><ol>
<li><p>类数目的增加, 每一个抽象类都需要一个子类来实现, 这样导致类的个数增加.</p>
</li>
<li><p>类数量的增加, 间接的增加了系统实现的复杂度.</p>
</li>
<li><p>继承关系自身缺点, 如果父类添加新的抽象方法, 所有子类都需要改一遍.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>摘抄笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2022/02/23/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><p><strong>策略模式</strong>(Strategy Pattern) 又叫<strong>政策模式</strong>(Policy Pattern), 他是将定义的算法家族、分别封装起来, 让他们之间可以相互替换, 从而让算法的变化不会影响到使用算法的用户.</p>
<p>可以避免多重的 <strong>if…else…<strong>和</strong>switch</strong>语句</p>
<p><strong>属于行为型设计模式</strong></p>
<h1 id="二、意图："><a href="#二、意图：" class="headerlink" title="二、意图："></a>二、意图：</h1><p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
<h1 id="三、主要解决："><a href="#三、主要解决：" class="headerlink" title="三、主要解决："></a>三、主要解决：</h1><p>在有多种算法相似的情况下，使用 if…else、switch 等所带来的复杂和难以维护。</p>
<h1 id="四、适用场景"><a href="#四、适用场景" class="headerlink" title="四、适用场景"></a>四、适用场景</h1><ol>
<li><p>假如系统中有很多类, 而他们的区别仅仅在于他们的行为不同.</p>
</li>
<li><p>一个系统需要动态的在几种算法中选择一种.</p>
</li>
<li><p>需要屏蔽算法规则.</p>
</li>
</ol>
<h1 id="五、Java代码简单案例"><a href="#五、Java代码简单案例" class="headerlink" title="五、Java代码简单案例"></a>五、Java代码简单案例</h1><p>案例采用于生活中的支付场景. 生活中有 支付宝, 微信, 银联, 京东支付等..</p>
<h2 id="1-定义支付抽象类和实现类"><a href="#1-定义支付抽象类和实现类" class="headerlink" title="1. 定义支付抽象类和实现类"></a>1. 定义支付抽象类和实现类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 支付抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Payment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通用逻辑放到抽象类里面实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MsgResult <span class="title">pay</span><span class="params">(String uid, <span class="keyword">double</span> amount)</span></span>&#123;</span><br><span class="line">        <span class="comment">//余额是否足够</span></span><br><span class="line">        <span class="keyword">if</span>(queryBalance(uid) &lt; amount)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MsgResult(<span class="number">500</span>,<span class="string">&quot;支付失败&quot;</span>,<span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MsgResult(<span class="number">200</span>,<span class="string">&quot;支付成功&quot;</span>,<span class="string">&quot;支付金额&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由各自实现类自行实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">queryBalance</span><span class="params">(String uid)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支付宝支付实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliPay</span> <span class="keyword">extends</span> <span class="title">Payment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;支付宝&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支付宝查询余额方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">queryBalance</span><span class="params">(String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">900</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 京东支付实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDPay</span> <span class="keyword">extends</span> <span class="title">Payment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;京东白条&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 京东支付查询余额方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">queryBalance</span><span class="params">(String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 银联支付实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionPay</span> <span class="keyword">extends</span> <span class="title">Payment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;银联支付&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 银联支付查询余额方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">queryBalance</span><span class="params">(String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">120</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 微信支付实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatPay</span> <span class="keyword">extends</span> <span class="title">Payment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;微信支付&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 微信支付查询余额方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">queryBalance</span><span class="params">(String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">263</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-定义支付策略类"><a href="#2-定义支付策略类" class="headerlink" title="2. 定义支付策略类"></a>2. 定义支付策略类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2. 定义支付策略类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> String ALI_PAY = <span class="string">&quot;AliPay&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> String JD_PAY = <span class="string">&quot;JdPay&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> String WECHAT_PAY = <span class="string">&quot;WechatPay&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> String UNION_PAY = <span class="string">&quot;UnionPay&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> String DEFAULT_PAY = ALI_PAY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Payment&gt; strategy = <span class="keyword">new</span> HashMap&lt;String,Payment&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        strategy.put(ALI_PAY,<span class="keyword">new</span> AliPay());</span><br><span class="line">        strategy.put(JD_PAY,<span class="keyword">new</span> JDPay());</span><br><span class="line">        strategy.put(WECHAT_PAY,<span class="keyword">new</span> WechatPay());</span><br><span class="line">        strategy.put(UNION_PAY,<span class="keyword">new</span> UnionPay());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Payment <span class="title">get</span><span class="params">(String payKey)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!strategy.containsKey(payKey))&#123;</span><br><span class="line">            <span class="keyword">return</span> strategy.get(DEFAULT_PAY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strategy.get(payKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-定义支付结果类"><a href="#3-定义支付结果类" class="headerlink" title="3. 定义支付结果类"></a>3. 定义支付结果类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3. 支付结果类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgResult</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MsgResult</span><span class="params">(<span class="keyword">int</span> code, String msg, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MsgResult&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;code=&quot;</span> + code +</span><br><span class="line">                <span class="string">&quot;, data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, msg=&#x27;&quot;</span> + msg + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-定义订单交易类"><a href="#4-定义订单交易类" class="headerlink" title="4. 定义订单交易类"></a>4. 定义订单交易类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4. 订单交易类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String uid, String orderId, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MsgResult <span class="title">pay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pay(PayStrategy.DEFAULT_PAY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MsgResult <span class="title">pay</span><span class="params">(String payKey)</span></span>&#123;</span><br><span class="line">        Payment payment = PayStrategy.get(payKey);</span><br><span class="line">        System.out.println(<span class="string">&quot;欢迎使用&quot;</span> + payment.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;本次交易金额为&quot;</span> + amount + <span class="string">&quot;，开始扣款&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> payment.pay(uid,amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-测试类"><a href="#5-测试类" class="headerlink" title="5. 测试类"></a>5. 测试类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> Order(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2020031401000323&quot;</span>,<span class="number">500</span>);</span><br><span class="line">        System.out.println(order.pay());</span><br><span class="line"></span><br><span class="line">        order = <span class="keyword">new</span> Order(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;2020031401000324&quot;</span>,<span class="number">121.5</span>);</span><br><span class="line">        System.out.println(order.pay(PayStrategy.UNION_PAY));</span><br><span class="line"></span><br><span class="line">        order = <span class="keyword">new</span> Order(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;2020031401000324&quot;</span>,<span class="number">200</span>);</span><br><span class="line">        System.out.println(order.pay(PayStrategy.WECHAT_PAY));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span><br><span class="line">欢迎使用支付宝</span><br><span class="line">本次交易金额为500.0，开始扣款</span><br><span class="line">MsgResult&#123;code=200, data=支付金额500.0, msg=&#x27;支付成功&#x27;&#125;</span><br><span class="line"></span><br><span class="line">欢迎使用银联支付</span><br><span class="line">本次交易金额为121.5，开始扣款</span><br><span class="line">MsgResult&#123;code=500, data=余额不足, msg=&#x27;支付失败&#x27;&#125;</span><br><span class="line"></span><br><span class="line">欢迎使用微信支付</span><br><span class="line">本次交易金额为200.0，开始扣款</span><br><span class="line">MsgResult&#123;code=200, data=支付金额200.0, msg=&#x27;支付成功&#x27;&#125;</span><br><span class="line">-------------------------------------------------------</span><br></pre></td></tr></table></figure>


<h1 id="六、策略模式优点"><a href="#六、策略模式优点" class="headerlink" title="六、策略模式优点"></a>六、策略模式优点</h1><ol>
<li><p>策略模式符合开闭原则. </p>
</li>
<li><p>避免使用多重条件转移语句, 如 if…else..等</p>
</li>
<li><p>使用策略模式可以提高算法的保密性和安全性.</p>
</li>
</ol>
<h1 id="七、策略模式缺点"><a href="#七、策略模式缺点" class="headerlink" title="七、策略模式缺点"></a>七、策略模式缺点</h1><ol>
<li>客户端必须知道所有的策略, 并且自行决定使用哪一个策略.</li>
<li>代码中会产生非常多的策略类, 增加维护难度.</li>
</ol>
]]></content>
      <categories>
        <category>摘抄笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全可见性问题</title>
    <url>/2022/03/04/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="一、线程安全-可见性、有序性"><a href="#一、线程安全-可见性、有序性" class="headerlink" title="一、线程安全 - 可见性、有序性"></a>一、线程安全 - 可见性、有序性</h1><p>这个案例比较简单，就是t1线程中用到了stop这个属性，接在在main线程中修改了 stop 这个属性的值来使得t1线程结束，但是t1线程并没有按照期望的结果执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Boolean stop=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        );</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;begin start thread&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        stop=<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、volatile解决可见性问题"><a href="#二、volatile解决可见性问题" class="headerlink" title="二、volatile解决可见性问题"></a>二、volatile解决可见性问题</h1><p><strong>有volatile变量修饰的共享变量进行写操作的时候会使用CPU提供的Lock前缀指令。在CPU级别的功能如下：</strong></p>
<ol>
<li><strong>将当前处理器缓存行的数据写回到系统内存</strong></li>
<li><strong>这个写回内存的操作会告知在其他CPU你们拿到的变量是无效的下一次使用时候要重新共享内存拿。</strong></li>
</ol>
<p><strong>而volatile实现可见性问题的本质就是使用lock指令实现了内存屏障</strong></p>
<p>在上面的程序中，可以增加 volatile这个关键字来解决，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Boolean stop=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        );</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;begin start thread&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        stop=<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、为了提升处理性能所做的优化"><a href="#三、为了提升处理性能所做的优化" class="headerlink" title="三、为了提升处理性能所做的优化"></a>三、为了提升处理性能所做的优化</h1><p>在整个计算机的发展历程中，除了CPU、内存以及I/O设备不断迭代升级来提升计算机处理性能之外， 还有一个非常核心的矛盾点，就是这三者在处理速度的差异。  <strong>CPU的计算速度是非常快的，其次是内  存、最后是IO设备（比如磁盘），也就是CPU的计算速度远远高于内存以及磁盘设备的I/O速度</strong>。</p>
<p>如下图所示，计算机是利用CPU进行数据运算的，但是CPU只能对内存中的数据进行运算，对于磁盘中 的数据，必须要先读取到内存，CPU才能进行运算，也就是CPU和内存之间无法避免的出现了IO操作。</p>
<p>而cpu的运算速度远远高于内存的IO速度，比如在一台2.4GHz的cpu上，每秒能处理2.4x109次，每次 处理的数据量，如果是64位操作系统，那么意味着每次能处理64位数据量。</p>
<p><img src="/images/img-144.png"></p>
<p>虽然CPU从单核升级到多核甚至到超线程技术在最大化的提高CPU的处理性能，但是仅仅提升CPU性能 是不够的，如果内存和磁盘的处理性能没有跟上，就意味着整体的计算效率取决于最慢的设备，为了平 衡这三者之间的速度差异，最大化的利用CPU。</p>
<p>所以在硬件层面、操作系统层面、编译器层面做出了很 多的优化</p>
<ol>
<li>CPU增加了高速缓存</li>
<li>操作系统增加了进程、线程。通过CPU的时间片切换最大化的提升CPU的使用率</li>
<li>编译器的指令优化，更合理的去利用好CPU的高速缓存</li>
</ol>
<p>每一种优化，都会带来相应的问题，而这些问题是导致线程安全性问题的根源，那接下来我们逐步去了 解这些优化的本质和带来的问题。</p>
<h1 id="四、CPU层面的缓存"><a href="#四、CPU层面的缓存" class="headerlink" title="四、CPU层面的缓存"></a>四、CPU层面的缓存</h1><p>CPU在做计算时，和内存的IO操作是无法避免的，而这个IO过程相对于CPU的计算速度来说是非常耗时，基于这样一个问题，所以在CPU层面设计了高速缓存，这个缓存行可以缓存存储在内存中的数据，CPU每次会先从缓存行中读取需要运算的数据，如果缓存行中不存在该数据，才会从内存中加载，通过 这样一个机制可以减少CPU和内存的交互开销从而提升CPU的利用率。</p>
<p><strong>对于主流的x86平台，cpu的缓存行（cache）分为L1、 L2、 L3总共3级。</strong></p>
<p><img src="/images/img-145.png"></p>
<h1 id="五、缓存一致性问题"><a href="#五、缓存一致性问题" class="headerlink" title="五、缓存一致性问题"></a>五、缓存一致性问题</h1><p>CPU高速缓存的出现，虽然提升了CPU的利用率，但是同时也带来了另外一个问题–缓存一致性问题，这个一致性问题体现在。</p>
<p>在多线程环境中，当多个线程并行执行加载同一块内存数据时，由于每个CPU都有自己独立的L1、 L2缓存，所以每个CPU的这部分缓存空间都会缓存到相同的数据，并且每个CPU执行相关指令时，彼此之间不可见，就会导致缓存的一致性问题，据图流程如下图所示：</p>
<p><img src="/images/img-146.png"></p>
<h1 id="六、缓存一致性协议"><a href="#六、缓存一致性协议" class="headerlink" title="六、缓存一致性协议"></a>六、缓存一致性协议</h1><p>为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，常见的协议有MSI，MESI，MOSI等。最常见的就是MESI协议。接下来给大家简单讲解一下MESI。</p>
<p>MESI表示缓存行的四种状态，分别是</p>
<ol>
<li>M(Modify[ ˈ mɒdɪfaɪ]) 表示共享数据只缓存在当前CPU缓存中，并且是被修改状态，也就是缓存的 数据和主内存中的数据不一致\</li>
<li>E(Exclusive[ɪkˈskluːsɪv]) 表示缓存的独占状态，数据只缓存在当前CPU缓存中，并且没有被修改</li>
<li>S(Shared[ʃerd]) 表示数据可能被多个CPU缓存，并且各个缓存中的数据和主内存数据一致</li>
<li>I(Invalid[ ˈɪnvəlɪd]) 表示缓存已经失效</li>
</ol>
<p>在CPU的缓存行中，每一个Cache一定会处于以下三种状态之一</p>
<ul>
<li>Shared</li>
<li>Exclusive</li>
<li>Invalid</li>
</ul>
<p><img src="/images/img-147.png"><br><img src="/images/img-148.png"><br><img src="/images/img-149.png"></p>
<h1 id="七、指令重排序代码"><a href="#七、指令重排序代码" class="headerlink" title="七、指令重排序代码"></a>七、指令重排序代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            x=<span class="number">0</span>;</span><br><span class="line">            y=<span class="number">0</span>;</span><br><span class="line">            a=<span class="number">0</span>;</span><br><span class="line">            b=<span class="number">0</span>;</span><br><span class="line">            Thread t1=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                a=<span class="number">1</span>;</span><br><span class="line">                x=b;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                x=b;</span><br><span class="line">                a=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            );</span><br><span class="line">            Thread t2=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                b=<span class="number">1</span>;</span><br><span class="line">                y=a;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                y=a;</span><br><span class="line">                b=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            );</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 可能的结果：</span></span><br><span class="line"><span class="comment">             *  1和1</span></span><br><span class="line"><span class="comment">             *  0和1</span></span><br><span class="line"><span class="comment">             *  1和0</span></span><br><span class="line"><span class="comment">             *  ----</span></span><br><span class="line"><span class="comment">             *  0和0 </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">            String result=<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;次(&quot;</span>+x+<span class="string">&quot;,&quot;</span>+y+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、伪共享代码"><a href="#八、伪共享代码" class="headerlink" title="八、伪共享代码"></a>八、伪共享代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheLineExample</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> ITERATIONS = <span class="number">500L</span> * <span class="number">1000L</span> * <span class="number">100L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> arrayIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ValueNoPadding[] longs;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheLineExample</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arrayIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arrayIndex = arrayIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            runTest(i);</span><br><span class="line">            System.out.println(i + <span class="string">&quot; Threads, duration = &quot;</span> +</span><br><span class="line">            (System.currentTimeMillis() - start));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">(<span class="keyword">int</span> NUM_THREADS)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[NUM_THREADS];</span><br><span class="line">        longs = <span class="keyword">new</span> ValueNoPadding[NUM_THREADS];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; longs.length; i++) &#123;</span><br><span class="line">            longs[i] = <span class="keyword">new</span> ValueNoPadding();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> CacheLineExample(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = ITERATIONS + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != --i) &#123;</span><br><span class="line">            longs[arrayIndex].value = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValuePadding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7; </span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>; </span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p9, p10, p11, p12, p13, p14; </span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">long</span> p15;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Contended</span> <span class="comment">//实现对齐填充</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueNoPadding</span> </span>&#123;</span><br><span class="line">        <span class="comment">// protected long p1, p2, p3, p4, p5, p6, p7;</span></span><br><span class="line">        <span class="comment">//8字节</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">// protected long p9, p10, p11, p12, p13, p14, p15;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="九、内存屏障"><a href="#九、内存屏障" class="headerlink" title="九、内存屏障"></a>九、内存屏障</h1><p>CPU在性能优化道路上导致的顺序一致性问题，在CPU层面无法被解决，原因是CPU只是一个运算工具，它只接收指令并且执行指令，并不清楚当前执行的整个逻辑中是否存在不能优化的问题，也就是说硬件层面也无法优化这种顺序一致性带来的可见性问题。</p>
<p>因此，在CPU层面提供了<strong>写屏障、读屏障、全屏障</strong>这样的指令，在x86架构中，这三种指令分别是<strong>SFENCE、LFENCE、MFENCE</strong>指令，</p>
<ul>
<li>sfence：也就是save fence，写屏障指令。在sfence指令前的写操作必须在sfence指令后的写操作前完成。</li>
<li>lfence：也就是load fence，读屏障指令。在lfence指令前的读操作必须在lfence指令后的读操作<br>前完成。</li>
<li>mfence：也就是modify/mix，混合屏障指令，在mfence前得读写操作必须在mfence指令后的读写操作前完成。</li>
</ul>
<p>在Linux系统中，将这三种指令分别封装成了, smp_wmb-写屏障 、smp_rmb-读屏障、smp_mb-读写屏障 三个方法</p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>线程安全</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序</title>
    <url>/2022/01/15/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>当数列最大和最小差距过大时, 并不适用计数排序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如给出20个随机整数, 范围在0-1亿之间, 这时如果使用计数排序, </span><br><span class="line">需要创建长度为1亿的数组. 不但严重浪费空间, 而且时间复杂度也会随之升高.</span><br></pre></td></tr></table></figure>
<p><strong>当数列元素不是整数时, 不适用计数排序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果数列中的元素都是小树, 如25.213, 或是0.0000000001这样的数字, </span><br><span class="line">则无法创建对应的统计数组. 这样显然无法进行计数排序.</span><br></pre></td></tr></table></figure>

<p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] resultArr = countSort(arr);</span><br><span class="line">    System.out.println(<span class="string">&quot;数组一排序: &quot;</span> + Arrays.toString(resultArr));</span><br><span class="line"></span><br><span class="line">    arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">80</span>, <span class="number">89</span>, <span class="number">87</span>, <span class="number">82</span>, <span class="number">81</span>, <span class="number">88</span>, <span class="number">85</span>, <span class="number">84</span>, <span class="number">83</span>, <span class="number">86</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] resultArr2 = countSort(arr);</span><br><span class="line">    System.out.println(<span class="string">&quot;数组二排序: &quot;</span> + Arrays.toString(resultArr2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">数组一排序: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">数组二排序: [<span class="number">80</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">84</span>, <span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>]</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 得到数列最大/最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        max = Math.max(nums[i], max);</span><br><span class="line">        min = Math.min(nums[i], min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据数列最大值和最小值确定计数数组长度</span></span><br><span class="line">    <span class="keyword">int</span>[] countArr = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 遍历数列, 填充统计长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        countArr[num - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历统计数组, 输出结果 </span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] sortArr = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; countArr[i]; j++) &#123;</span><br><span class="line">            sortArr[index++] = i + min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法小抄</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2022/02/23/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><p><strong>责任链模式</strong>(Chain of Responseiblibity Pattrern) 是将链中每一个节点看做是一个对象, 每个节点处理的请求均不同, 且内部自动维护一个下一节点对象. 当一个请求从链式的首端发出时, 会沿着链的路径依次传递给每一个节点对象, 直至有对象处理这个请求为止. </p>
<p><strong>属于行为型设计模式</strong></p>
<h1 id="二、适用场景"><a href="#二、适用场景" class="headerlink" title="二、适用场景"></a>二、适用场景</h1><ol>
<li><p>多个对象可以处理同一请求, 但具体由哪个对象处理则在运行时动态决定.</p>
</li>
<li><p>在不明确指定接收者的情况下, 向多个对象中的一个提交一个请求.</p>
</li>
<li><p>可动态指定一组对象处理请求.</p>
</li>
</ol>
<h1 id="三、java代码简单案例"><a href="#三、java代码简单案例" class="headerlink" title="三、java代码简单案例"></a>三、java代码简单案例</h1><p>此处使用用户登录及认证做一个简单案例</p>
<h2 id="使用责任链模式之前"><a href="#使用责任链模式之前" class="headerlink" title="使用责任链模式之前"></a>使用责任链模式之前</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String loginName;</span><br><span class="line">    <span class="keyword">private</span> String loginPass;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String loginName, String loginPass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loginName = loginName;</span><br><span class="line">        <span class="keyword">this</span>.loginPass = loginPass;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Member&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;loginName=&#x27;&quot;</span> + loginName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, loginPass=&#x27;&quot;</span> + loginPass + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, roleName=&#x27;&quot;</span> + roleName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户业务实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String loginName,String loginPass)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(loginName) ||</span><br><span class="line">                StringUtils.isEmpty(loginPass))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名和密码为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名和密码不为空，可以往下执行&quot;</span>);</span><br><span class="line"></span><br><span class="line">        User user = checkExists(loginName,loginPass);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == user)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;管理员&quot;</span>.equals(user.getRoleName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您不是管理员，没有操作权限&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;允许操作&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> User <span class="title">checkExists</span><span class="params">(String loginName, String loginPass)</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(loginName,loginPass);</span><br><span class="line">        user.setRoleName(<span class="string">&quot;管理员&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService service = <span class="keyword">new</span> UserService();</span><br><span class="line">        service.login(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;666&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>以上, 在实现用户登录业务逻辑的时候, 各种校验于代码中… 可能还会有其他的业务校验, 就会造成代码长度过大, 非常复杂</strong>.</p>
<h2 id="使用责任链模式之后"><a href="#使用责任链模式之后" class="headerlink" title="使用责任链模式之后"></a>使用责任链模式之后</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务处理接口, 结合了建造者模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler&lt;T&gt; next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">(Handler next)</span></span>&#123; <span class="keyword">this</span>.next = next;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doHandler</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Handler&lt;T&gt; head;</span><br><span class="line">        <span class="keyword">private</span> Handler&lt;T&gt; tail;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder&lt;T&gt; <span class="title">addHandler</span><span class="params">(Handler handler)</span></span>&#123;</span><br><span class="line">            <span class="comment">//do &#123;</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.head = <span class="keyword">this</span>.tail = handler;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.tail.next(handler);</span><br><span class="line">                <span class="keyword">this</span>.tail = handler;</span><br><span class="line">            <span class="comment">//&#125;while (false);//真正框架中，如果是双向链表，会判断是否已经到了尾部</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Handler&lt;T&gt; <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handler实现类, 该Handler用于处理登录成功后的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandler</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录成功！准备跳转首页...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 登录成功后的业务逻辑......</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != next) &#123;</span><br><span class="line">            next.doHandler(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 权限认证Handler实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandler</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;管理员&quot;</span>.equals(user.getRoleName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您不是管理员，没有操作权限&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;允许操作&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != next) &#123;</span><br><span class="line">            next.doHandler(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户名密码校验</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHandler</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(user.getLoginName()) ||</span><br><span class="line">                StringUtils.isEmpty(user.getLoginPass()))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名和密码为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名和密码不为空，可以往下执行&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != next) &#123;</span><br><span class="line">            next.doHandler(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户Service层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String loginName,String loginPass)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Handler.Builder builder = <span class="keyword">new</span> Handler.Builder();</span><br><span class="line"></span><br><span class="line">        builder.addHandler(<span class="keyword">new</span> ValidateHandler())</span><br><span class="line">                .addHandler(<span class="keyword">new</span> LoginHandler())</span><br><span class="line">                .addHandler(<span class="keyword">new</span> AuthHandler());</span><br><span class="line"></span><br><span class="line">        User user = <span class="keyword">new</span> User(loginName, loginPass);</span><br><span class="line">        user.setRoleName(<span class="string">&quot;管理员&quot;</span>);</span><br><span class="line">        builder.build().doHandler(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用过Netty的人，肯定见过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line">        userService.login(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;666&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------------------------------------</span><br><span class="line">用户名和密码不为空，可以往下执行</span><br><span class="line">登录成功！</span><br><span class="line">允许操作</span><br><span class="line">------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h1 id="四、优点"><a href="#四、优点" class="headerlink" title="四、优点"></a>四、优点</h1><ol>
<li><p>将请求与处理解耦.</p>
</li>
<li><p>请求矗立着(节点对象) 只需关注自己感兴趣的请求进行处理即可, 对不感兴趣的请求, 直接转发给下一级节点对象.</p>
</li>
<li><p>具备链式传递处理请求功能, 请求发送者无需知晓链路结构, 只需等待请求处理结果.</p>
</li>
<li><p>链路结构灵活, 可以通过改变链路结构动态地新增或删减责任.</p>
</li>
<li><p>易于扩展新的请求处理类(节点), 符合开闭原则.</p>
</li>
</ol>
<h1 id="五、缺点"><a href="#五、缺点" class="headerlink" title="五、缺点"></a>五、缺点</h1><ol>
<li><p>责任链太长或者处理时间过长, 会影响整体性能,</p>
</li>
<li><p>如果节点对象存在循环引用时, 会造成死循环, 导致系统崩溃.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>摘抄笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 缓存模块</title>
    <url>/2021/08/10/MyBatis-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p><strong>MyBatis作为一个强大的持久层框架，缓存是其必不可少的功能之一，Mybatis中的缓存分为一级缓存<br>和二级缓存。但本质上是一样的，都是使用Cache接口实现的。缓存位于 org.apache.ibatis.cache包<br>下。</strong></p>
<p><img src="/images/img-90.png" alt="目录结构"></p>
<p><strong>通过结构我们能够发现Cache其实使用到了装饰器模式来实现缓存的处理。首先来看看Cache中的基础类的API</strong></p>
<blockquote>
<p>// 煎饼加鸡蛋加香肠 “装饰者模式（Decorator Pattern）是指在不改变原有对象的基础之上，将功能附加到对象上，提供了比 继承更有弹性的替代方案（扩展原有对象的功能）。”</p>
</blockquote>
<p><img src="/images/img-91.png"></p>
<h1 id="1-Cache-接口"><a href="#1-Cache-接口" class="headerlink" title="1. Cache 接口"></a>1. Cache 接口</h1><p>Cache接口是缓存模块中最核心的接口，它定义了所有缓存的基本行为，Cache接口的定义如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 缓存对象的 ID</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> The identifier of this cache */</span></span><br><span class="line">	<span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 向缓存中添加数据，一般情况下 key是CacheKey  value是查询结果</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key Can be any object but usually it is a &#123;<span class="doctag">@link</span> CacheKey&#125;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> value The result of a select. */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据指定的key，在缓存中查找对应的结果对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key The key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> The object stored in the cache. */</span></span><br><span class="line">	<span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * As of 3.3.0 this method is only called during a rollback</span></span><br><span class="line"><span class="comment">	 * for any previous value that was missing in the cache.</span></span><br><span class="line"><span class="comment">	 * This lets any blocking cache to release the lock that</span></span><br><span class="line"><span class="comment">	 * may have previously put on the key.</span></span><br><span class="line"><span class="comment">	 * A blocking cache puts a lock when a value is null</span></span><br><span class="line"><span class="comment">	 * and releases it when the value is back again.</span></span><br><span class="line"><span class="comment">	 * This way other threads will wait</span></span><br><span class="line"><span class="comment">	 * available instead of hitting the</span></span><br><span class="line"><span class="comment">	 *   删除key对应的缓存数据 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key The key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> Not used</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Clears this cache instance.</span></span><br><span class="line"><span class="comment">	 * 清空缓存</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Optional. This method</span></span><br><span class="line"><span class="comment">	 * 缓存的个数。</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> The number of */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">* Optional. As of 3.2.6</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* Any locking needed by</span></span><br><span class="line"><span class="comment">provider.</span></span><br><span class="line"><span class="comment">*  获取读写锁</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> A ReadWriteLock */</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cache接口的实现类很多，但是大部分都是装饰器，只有PerpetualCache提供了Cache接口的基本实现。</p>
<p><img src="/images/img-92.png"></p>
<h1 id="2-PerpetualCache"><a href="#2-PerpetualCache" class="headerlink" title="2. PerpetualCache"></a>2. PerpetualCache</h1><p>PerpetualCache在缓存模块中扮演了ConcreteComponent的角色，其实现比较简单，底层使用 HashMap记录缓存项，具体的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在装饰器模式用 用来被装饰的对象</span></span><br><span class="line"><span class="comment"> * 缓存中的  基本缓存处理的实现</span></span><br><span class="line"><span class="comment"> * 其实就是一个 HashMap 的基本操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String id; <span class="comment">// Cache 对象的唯一标识</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于记录缓存的Map对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map &lt; Object, Object &gt; cache = <span class="keyword">new</span> HashMap &lt; &gt; ();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PerpetualCache</span><span class="params">(String id)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cache.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cache.put(key, value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cache.get(key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cache.remove(key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cache.clear();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(getId() == <span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Cache instances require an ID.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span> == o)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Cache))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Cache otherCache = (Cache) o;</span><br><span class="line">		<span class="comment">// 只关心ID</span></span><br><span class="line">		<span class="keyword">return</span> getId().equals(otherCache.getId());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(getId() == <span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Cache instances require an ID.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 只关心ID</span></span><br><span class="line">		<span class="keyword">return</span> getId().hashCode();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们可以来看看cache.decorators包下提供的装饰器。他们都实现了Cache接口。这些装饰器 都在PerpetualCache的基础上提供了一些额外的功能，通过多个组合实现一些特殊的需求。</p>
<h1 id="3-BlockingCache"><a href="#3-BlockingCache" class="headerlink" title="3. BlockingCache"></a>3. BlockingCache</h1><p>通过名称我们能看出来是一个阻塞同步的缓存，它保证只有一个线程到缓存中查找指定的key对应的 数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingCache</span> <span class="keyword">implements</span> <span class="title">Cache</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> timeout; <span class="comment">// 阻塞超时时长</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Cache delegate; <span class="comment">// 被装饰的底层 Cache 对象 // 每个key 都有对象的 ReentrantLock 对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap &lt; Object, ReentrantLock &gt; locks;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BlockingCache</span><span class="params">(Cache delegate)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 被装饰的 Cache 对象</span></span><br><span class="line">		<span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">		<span class="keyword">this</span>.locks = <span class="keyword">new</span> ConcurrentHashMap &lt; &gt; ();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> delegate.getId();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> delegate.getSize();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 执行 被装饰的 Cache 中的方法</span></span><br><span class="line">			delegate.putObject(key, value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 释放锁</span></span><br><span class="line">			releaseLock(key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		acquireLock(key); <span class="comment">// 获取锁</span></span><br><span class="line">		Object value = delegate.getObject(key); <span class="comment">// 获取缓存数据</span></span><br><span class="line">		<span class="keyword">if</span>(value != <span class="keyword">null</span>)</span><br><span class="line">		&#123; <span class="comment">// 有数据就释放掉锁，否则继续持有锁</span></span><br><span class="line">			releaseLock(key);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// despite of its name, this method is called only to release locks</span></span><br><span class="line">		releaseLock(key);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		delegate.clear();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> ReentrantLock <span class="title">getLockForKey</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> locks.computeIfAbsent(key, k - &gt; <span class="keyword">new</span> ReentrantLock());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acquireLock</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			Lock lock = getLockForKey(key);</span><br><span class="line">			<span class="keyword">if</span>(timeout &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">try</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">boolean</span> acquired = lock.tryLock(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">					<span class="keyword">if</span>(!acquired)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Couldn&#x27;t get a lock in &quot;</span> + timeout + <span class="string">&quot; for</span></span><br><span class="line"><span class="string">							the key &quot;</span> +  key + <span class="string">&quot;</span></span><br><span class="line"><span class="string">							at the cache &quot;</span> + delegate.getId());</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Got interrupted while trying to acquire lock</span></span><br><span class="line"><span class="string">							for key &quot;</span> + key, e);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						lock.lock();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">				</span>&#123;</span><br><span class="line">					ReentrantLock lock = locks.get(key);</span><br><span class="line">					<span class="keyword">if</span>(lock.isHeldByCurrentThread())</span><br><span class="line">					&#123;</span><br><span class="line">						lock.unlock();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimeout</span><span class="params">()</span></span></span><br><span class="line"><span class="function">				</span>&#123;</span><br><span class="line">					<span class="keyword">return</span> timeout;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(<span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">				</span>&#123;</span><br><span class="line">					<span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingCache</span> <span class="keyword">implements</span> <span class="title">Cache</span></span></span><br><span class="line"><span class="class">			</span>&#123;</span><br><span class="line">				<span class="keyword">private</span> <span class="keyword">long</span> timeout; <span class="comment">// 阻塞超时时长</span></span><br><span class="line">				<span class="keyword">private</span> <span class="keyword">final</span> Cache delegate; <span class="comment">// 被装饰的底层 Cache 对象 // 每个key 都有对象的 ReentrantLock 对象</span></span><br><span class="line">				<span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap &lt; Object, ReentrantLock &gt; locks;</span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="title">BlockingCache</span><span class="params">(Cache delegate)</span></span></span><br><span class="line"><span class="function">				</span>&#123;</span><br><span class="line">					<span class="comment">// 被装饰的 Cache 对象</span></span><br><span class="line">					<span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">					<span class="keyword">this</span>.locks = <span class="keyword">new</span> ConcurrentHashMap &lt; &gt; ();</span><br><span class="line">				&#125;</span><br><span class="line">                </span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">				</span>&#123;</span><br><span class="line">					<span class="keyword">return</span> delegate.getId();</span><br><span class="line">				&#125;</span><br><span class="line">                </span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">				</span>&#123;</span><br><span class="line">					<span class="keyword">return</span> delegate.getSize();</span><br><span class="line">				&#125;</span><br><span class="line">                </span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span></span><br><span class="line"><span class="function">				</span>&#123;</span><br><span class="line">					<span class="keyword">try</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">// 执行 被装饰的 Cache 中的方法</span></span><br><span class="line">						delegate.putObject(key, value);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">finally</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">// 释放锁</span></span><br><span class="line">						releaseLock(key);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">                </span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">				</span>&#123;</span><br><span class="line">					acquireLock(key); <span class="comment">// 获取锁</span></span><br><span class="line">					Object value = delegate.getObject(key); <span class="comment">// 获取缓存数据</span></span><br><span class="line">					<span class="keyword">if</span>(value != <span class="keyword">null</span>)</span><br><span class="line">					&#123; <span class="comment">// 有数据就释放掉锁，否则继续持有锁</span></span><br><span class="line">						releaseLock(key);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> value;</span><br><span class="line">				&#125;</span><br><span class="line">                </span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">				</span>&#123;</span><br><span class="line">					<span class="comment">// despite of its name, this method is called only to release locks</span></span><br><span class="line">					releaseLock(key);</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">                </span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">				</span>&#123;</span><br><span class="line">					delegate.clear();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="function"><span class="keyword">private</span> ReentrantLock <span class="title">getLockForKey</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">				</span>&#123;</span><br><span class="line">					<span class="keyword">return</span> locks.computeIfAbsent(key, k - &gt; <span class="keyword">new</span> ReentrantLock());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acquireLock</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">					</span>&#123;</span><br><span class="line">						Lock lock = getLockForKey(key);</span><br><span class="line">						<span class="keyword">if</span>(timeout &gt; <span class="number">0</span>)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">try</span></span><br><span class="line">							&#123;</span><br><span class="line">								<span class="keyword">boolean</span> acquired = lock.tryLock(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">								<span class="keyword">if</span>(!acquired)</span><br><span class="line">								&#123;</span><br><span class="line">									<span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Couldn&#x27;t get a lock in &quot;</span> + timeout + <span class="string">&quot; for</span></span><br><span class="line"><span class="string">										the key &quot;</span> +  key + <span class="string">&quot;</span></span><br><span class="line"><span class="string">										at the cache &quot;</span> + delegate.getId());</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">								&#123;</span><br><span class="line">									<span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Got interrupted while trying to acquire lock</span></span><br><span class="line"><span class="string">										for key &quot;</span> + key, e);</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">else</span></span><br><span class="line">								&#123;</span><br><span class="line">									lock.lock();</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">							</span>&#123;</span><br><span class="line">								ReentrantLock lock = locks.get(key);</span><br><span class="line">								<span class="keyword">if</span>(lock.isHeldByCurrentThread())</span><br><span class="line">								&#123;</span><br><span class="line">									lock.unlock();</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimeout</span><span class="params">()</span></span></span><br><span class="line"><span class="function">							</span>&#123;</span><br><span class="line">								<span class="keyword">return</span> timeout;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(<span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">							</span>&#123;</span><br><span class="line">								<span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码我们能够发现，  BlockingCache本质上就是在我们操作缓存数据的前后通过ReentrantLock对象来实现了加锁和解锁操作。其他的具体实现类，大家可以自行查阅</p>
<table>
<thead>
<tr>
<th>缓存实现类</th>
<th>描述</th>
<th>作用</th>
<th>装饰条件</th>
</tr>
</thead>
<tbody><tr>
<td>基本缓存</td>
<td>缓存基本实现类</td>
<td>默认是PerpetualCache ， 也可以 自定义比如RedisCache、EhCache等 ，具备基本功能的缓存类</td>
<td>无</td>
</tr>
<tr>
<td>LruCache</td>
<td>LRU策略的缓存</td>
<td>当缓存到达上限时候 ， 删除最近最少使用的缓存 （ Least Recently Use）</td>
<td>eviction=”LRU” （默认）</td>
</tr>
<tr>
<td>FifoCache</td>
<td>FIFO策略的缓存</td>
<td>当缓存到达上限时候 ，删除最先入队的缓存</td>
<td>eviction=”FIFO”</td>
</tr>
<tr>
<td>SoftCacheWeakCache</td>
<td>带清理策略的缓存</td>
<td>通过JVM的软引用和弱引用来实现 缓存，当JVM内存不足时，会自动清理掉这些缓存，基于SoftReference和WeakReference</td>
<td>eviction=”SOFT”eviction=”WEAK”</td>
</tr>
<tr>
<td>LoggingCache</td>
<td>带日志功能的缓存</td>
<td>比如：输出缓存命中率</td>
<td>基本</td>
</tr>
<tr>
<td>SynchronizedCache</td>
<td>同步缓存</td>
<td>基于synchronized关键字实现，解决并发问题</td>
<td>基本</td>
</tr>
<tr>
<td>BlockingCache</td>
<td>阻塞缓存</td>
<td>通过在get/put方式中加锁，保证只有一个线程操作缓存，基于Java重入锁实现</td>
<td>blocking=true</td>
</tr>
<tr>
<td>SerializedCache</td>
<td>支持序列化的缓存</td>
<td>将对象序列化以后存到缓存中，取出时反序列化</td>
<td>readOnly=false （默认）</td>
</tr>
<tr>
<td>ScheduledCache</td>
<td>定时调度的缓存</td>
<td>在进行 get/put/remove/getSize    等操作前，判断缓存时间是否超过了设置的最长缓存时间（默认是一小时），如果是则清空缓存– 即每隔一段时间清空一次缓存</td>
<td>flush nterval不为空</td>
</tr>
<tr>
<td>TransactionalCache</td>
<td>事务缓存</td>
<td>在二级缓存中使用，可一次存入多个缓存，移除多个缓存</td>
<td>在TransactionalCacheManager 中用Map维护对应关系</td>
</tr>
</tbody></table>
<h1 id="4-缓存的应用"><a href="#4-缓存的应用" class="headerlink" title="4. 缓存的应用"></a>4. 缓存的应用</h1><h2 id="4-1-缓存对应的初始化"><a href="#4-1-缓存对应的初始化" class="headerlink" title="4.1 缓存对应的初始化"></a>4.1 缓存对应的初始化</h2><p>在Configuration初始化的时候会为我们的各种Cache实现注册对应的别名</p>
<p><img src="/images/img-102.png"></p>
<p>在解析settings标签的时候，设置的默认值有如下</p>
<p><img src="/images/img-103.png"></p>
<p>cacheEnabled默认为true，localCacheScope默认为 SESSION</p>
<p>在解析映射文件的时候会解析我们相关的cache标签</p>
<p><img src="/images/img-104.png"></p>
<p>然后解析映射文件的cache标签后会在Configuration对象中添加对应的数据在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheElement</span><span class="params">(XNode context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 只有 cache 标签不为空才解析</span></span><br><span class="line">	<span class="keyword">if</span>(context != <span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		String type = context.getStringAttribute(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;PERPETUAL&quot;</span>);</span><br><span class="line">		Class &lt;? extends Cache &gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">		String eviction = context.getStringAttribute(<span class="string">&quot;eviction&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line">		Class &lt;? extends Cache &gt; evictionClass =</span><br><span class="line">			typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">		Long flushInterval = context.getLongAttribute(<span class="string">&quot;flushInterval&quot;</span>);</span><br><span class="line">		Integer size = context.getIntAttribute(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">		<span class="keyword">boolean</span> readWrite = !context.getBooleanAttribute(<span class="string">&quot;readOnly&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">boolean</span> blocking = context.getBooleanAttribute(<span class="string">&quot;blocking&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">		Properties props = context.getChildrenAsProperties();</span><br><span class="line">		builderAssistant.useNewCache(typeClass, evictionClass, flushInterval,</span><br><span class="line">			size, readWrite, blocking, props);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续</p>
<p><img src="/images/img-105.png"></p>
<p>然后我们可以发现 如果存储 cache 标签，那么对应的 Cache对象会被保存在 currentCache 属性中。</p>
<p><img src="/images/img-106.png"></p>
<p>进而在 Cache 对象 保存在了 MapperStatement 对象的 cache 属性中。</p>
<p>然后我们再看看openSession的时候又做了哪些操作，在创建对应的执行器的时候会有缓存的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">	executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">	Executor executor;</span><br><span class="line">	<span class="keyword">if</span>(ExecutorType.BATCH == executorType)</span><br><span class="line">	&#123;</span><br><span class="line">		executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ExecutorType.REUSE == executorType)</span><br><span class="line">	&#123;</span><br><span class="line">		executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 默认 SimpleExecutor</span></span><br><span class="line">		executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 二级缓存开关，settings 中的 cacheEnabled 默认是 true</span></span><br><span class="line">	<span class="keyword">if</span>(cacheEnabled)</span><br><span class="line">	&#123;</span><br><span class="line">		executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 植入插件的逻辑，至此，四大对象已经全部拦截完毕</span></span><br><span class="line">	executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">	<span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是如果 cacheEnabled 为 true 就会通过 CachingExecutor 来装饰executor 对象，然后就是在 执行SQL操作的时候会涉及到缓存的具体使用。这个就分为一级缓存和二级缓存，这个我们来分别介绍</p>
<h2 id="4-2-一级缓存"><a href="#4-2-一级缓存" class="headerlink" title="4.2 一级缓存"></a>4.2 一级缓存</h2><p>一级缓存也叫本地缓存（Local Cache）， MyBatis的一级缓存是在会话（SqlSession）层面进行缓 存的。  MyBatis的一级缓存是默认开启的，不需要任何的配置（如果要关闭，  localCacheScope设置为   STATEMENT）。在BaseExecutor对象的query方法中有关闭一级缓存的逻辑</p>
<p><img src="/images/img-107.png"></p>
<p>然后我们需要考虑下在一级缓存中的 PerpetualCache 对象在哪创建的，因为一级缓存是Session级  别的缓存，肯定需要在Session范围呢创建，其实PerpetualCache的实例化是在BaseExecutor的构造方法中创建的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">BaseExecutor</span><span class="params">(Configuration configuration, Transaction transaction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.transaction = transaction;</span><br><span class="line">  <span class="keyword">this</span>.deferredLoads = <span class="keyword">new</span> ConcurrentLinkedQueue &lt; &gt; ();</span><br><span class="line">  <span class="keyword">this</span>.localCache = <span class="keyword">new</span> PerpetualCache(<span class="string">&quot;LocalCache&quot;</span>);</span><br><span class="line">  <span class="keyword">this</span>.localOutputParameterCache = <span class="keyword">new</span> PerpetualCache(<span class="string">&quot;LocalOutputParameterCache&quot;</span>);</span><br><span class="line">  <span class="keyword">this</span>.closed = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">  <span class="keyword">this</span>.wrapper = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/img-108.png"></p>
<p>一级缓存的具体实现也是在BaseExecutor的query方法中来实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt; E &gt; List &lt; E &gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) <span class="keyword">throws</span> SQLException</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 异常体系之 ErrorContext</span></span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span>(closed)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// flushCache=&quot;true&quot;时，即使是查询，也清空一级缓存</span></span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List &lt; E &gt; list;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 防止递归查询重复处理缓存</span></span><br><span class="line">    queryStack++;</span><br><span class="line">    <span class="comment">// 查询一级缓存</span></span><br><span class="line">    <span class="comment">// ResultHandler 和 ResultSetHandler的区别</span></span><br><span class="line">    list = resultHandler == <span class="keyword">null</span> ? (List &lt; E &gt; ) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(list != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 真正的查询流程</span></span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span></span><br><span class="line">  &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(queryStack == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(DeferredLoad deferredLoad: deferredLoads)</span><br><span class="line">    &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #601</span></span><br><span class="line">    deferredLoads.clear();</span><br><span class="line">    <span class="keyword">if</span>(configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// issue #482</span></span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一级缓存的验证：</p>
<p>同一个Session中的多个相同操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 1.获取配置文件</span></span><br><span class="line">  InputStream in = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">  <span class="comment">// 2.加载解析配置文件并获取SqlSessionFactory对象</span></span><br><span class="line">  SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build( in );</span><br><span class="line">  <span class="comment">// 3.根据SqlSessionFactory对象获取SqlSession对象</span></span><br><span class="line">  SqlSession sqlSession = factory.openSession();</span><br><span class="line">  <span class="comment">// 4.通过SqlSession中提供的 API方法来操作数据库</span></span><br><span class="line">  List &lt; User &gt; list =</span><br><span class="line">    sqlSession.selectList(<span class="string">&quot;com.gupaoedu.mapper.UserMapper.selectUserList&quot;</span>);</span><br><span class="line">  System.out.println(list.size());</span><br><span class="line">  <span class="comment">// 一级缓存测试</span></span><br><span class="line">  System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">  list =</span><br><span class="line">    sqlSession.selectList(<span class="string">&quot;com.gupaoedu.mapper.UserMapper.selectUserList&quot;</span>);</span><br><span class="line">  System.out.println(list.size());</span><br><span class="line">  <span class="comment">// 5.关闭会话</span></span><br><span class="line">  sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Setting autocommit to false on JDBC Connection</span><br><span class="line">[com.mysql.cj.jdbc.ConnectionImpl@477b4cdf]</span><br><span class="line">==&gt;  Preparing: select * from t_user                           ==&gt; Parameters:                                                &lt;==    Columns: id, user_name, real_name, password, age, d_id</span><br><span class="line">&lt;==        Row: 1, zhangsan, 张三 , 123456, 18, null</span><br><span class="line">&lt;==        Row: 2, lisi, 李四 , 11111, 19, null</span><br><span class="line">&lt;==        Row: 3, wangwu, 王五 , 111, 22, 1001</span><br><span class="line">&lt;==        Row: 4, wangwu, 王五 , 111, 22, 1001</span><br><span class="line">&lt;==        Row: 5, wangwu, 王五 , 111, 22, 1001</span><br><span class="line">&lt;==        Row: 6, wangwu, 王五 , 111, 22, 1001</span><br><span class="line">&lt;==        Row: 7, wangwu, 王五 , 111, 22, 1001</span><br><span class="line">&lt;==        Row: 8, aaa, bbbb, null, null, null</span><br><span class="line">&lt;==        Row: 9, aaa, bbbb, null, null, null</span><br><span class="line">&lt;==        Row: 10, aaa, bbbb, null, null, null</span><br><span class="line">&lt;==        Row: 11, aaa, bbbb, null, null, null</span><br><span class="line">&lt;==        Row: 12, aaa, bbbb, null, null, null</span><br><span class="line">&lt;==        Row: 666, hibernate, 持久层框架 , null, null, null</span><br><span class="line">&lt;==      Total: 13</span><br><span class="line">13</span><br><span class="line">---------</span><br><span class="line">13</span><br></pre></td></tr></table></figure>
<p>可以看到第二次查询没有经过数据库操作</p>
<p>不同Session的相同操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Setting autocommit to false on JDBC Connection</span><br><span class="line">[com.mysql.cj.jdbc.ConnectionImpl@477b4cdf]</span><br><span class="line">==&gt;  Preparing: select * from t_user                           ==&gt; Parameters:                                                &lt;==    Columns: id, user_name, real_name, password, age, d_id</span><br><span class="line">&lt;==        Row: 1, zhangsan, 张三 , 123456, 18, null</span><br><span class="line">&lt;==        Row: 2, lisi, 李四 , 11111, 19, null</span><br><span class="line">&lt;==        Row: 3, wangwu, 王五 , 111, 22, 1001</span><br><span class="line">&lt;==        Row: 4, wangwu, 王五 , 111, 22, 1001</span><br><span class="line">&lt;==        Row: 5, wangwu, 王五 , 111, 22, 1001</span><br><span class="line">&lt;==        Row: 6, wangwu, 王五 , 111, 22, 1001</span><br><span class="line">&lt;==        Row: 7, wangwu, 王五 , 111, 22, 1001</span><br><span class="line">&lt;==        Row: 8, aaa, bbbb, null, null, null</span><br><span class="line">&lt;==        Row: 9, aaa, bbbb, null, null, null</span><br><span class="line">&lt;==        Row: 10, aaa, bbbb, null, null, null</span><br><span class="line">&lt;==        Row: 11, aaa, bbbb, null, null, null</span><br><span class="line">&lt;==        Row: 12, aaa, bbbb, null, null, null</span><br><span class="line">&lt;==        Row: 666, hibernate, 持久层框架 , null, null, null</span><br><span class="line">&lt;==      Total: 13</span><br><span class="line">13</span><br><span class="line">Resetting autocommit to true on JDBC Connection</span><br><span class="line">[com.mysql.cj.jdbc.ConnectionImpl@477b4cdf]</span><br><span class="line">Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@477b4cdf] Returned connection 1199262943 to pool.</span><br><span class="line">---------</span><br><span class="line">Opening JDBC Connection</span><br><span class="line">Checked out connection 1199262943 from pool.</span><br><span class="line">Setting autocommit to false on JDBC Connection</span><br><span class="line">[com.mysql.cj.jdbc.ConnectionImpl@477b4cdf]</span><br><span class="line">==&gt;  Preparing: select * from t_user</span><br><span class="line">==&gt; Parameters:</span><br><span class="line">&lt;==	Columns: id, user_name, real_name, password, age, d_id</span><br><span class="line">&lt;==	Row: 1, zhangsan, 张三 , 123456, 18, null</span><br><span class="line">&lt;==	Row: 2, lisi, 李四 , 11111, 19, null</span><br><span class="line">&lt;==	Row: 3, wangwu, 王五 , 111, 22, 1001</span><br><span class="line">&lt;==	Row: 4, wangwu, 王五 , 111, 22, 1001</span><br><span class="line">&lt;==	Row: 5, wangwu, 王五 , 111, 22, 1001</span><br><span class="line">&lt;==	Row: 6, wangwu, 王五 , 111, 22, 1001</span><br><span class="line">&lt;==	Row: 7, wangwu, 王五 , 111, 22, 1001</span><br><span class="line">&lt;==	Row: 8, aaa, bbbb, null, null, null</span><br><span class="line">&lt;==	Row: 9, aaa, bbbb, null, null, null</span><br><span class="line">&lt;==	Row: 10, aaa, bbbb, null, null, null</span><br><span class="line">&lt;==	Row: 11, aaa, bbbb, null, null, null</span><br><span class="line">&lt;==	Row: 12, aaa, bbbb, null, null, null</span><br><span class="line">&lt;==	Row: 666, hibernate, 持久层框架 , null, null, null </span><br><span class="line">&lt;==	Total: 13</span><br><span class="line">Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@477b4cdf] </span><br><span class="line">Closing JDBC Connection </span><br><span class="line">[com.mysql.cj.jdbc.ConnectionImpl@477b4cdf] Returned connection 1199262943 to pool.</span><br><span class="line">--------- </span><br><span class="line">Opening JDBC Connection Checked out connection 1199262943 from pool.</span><br><span class="line">Setting autocommit to false on JDBC Connection </span><br><span class="line">[com.mysql.cj.jdbc.ConnectionImpl@477b4cdf] </span><br><span class="line">==&gt; Preparing: select * from t_user </span><br><span class="line">==&gt; Parameters:</span><br><span class="line">&lt;== Columns: id, user_name, real_name, password, age, d_id </span><br><span class="line">&lt;== Row: 1, zhangsan, 张三, 123456, 18, null </span><br><span class="line">&lt;== Row: 2, lisi, 李四, 11111, 19, null </span><br><span class="line">&lt;== Row: 3, wangwu, 王五, 111, 22, 1001 </span><br><span class="line">&lt;== Row: 4, wangwu, 王五, 111, 22, 1001 </span><br><span class="line">&lt;== Row: 5, wangwu, 王五, 111, 22, 1001 </span><br><span class="line">&lt;== Row: 6, wangwu, 王五, 111, 22, 1001 </span><br><span class="line">&lt;== Row: 7, wangwu, 王五, 111, 22, 1001 </span><br><span class="line">&lt;== Row: 8, aaa, bbbb, null, null, null </span><br><span class="line">&lt;== Row: 9, aaa, bbbb, null, null, null </span><br><span class="line">&lt;== Row: 10, aaa, bbbb, null, null, null </span><br><span class="line">&lt;== Row: 11, aaa, bbbb, null, null, null </span><br><span class="line">&lt;== Row: 12, aaa, bbbb, null, null, null </span><br><span class="line">&lt;== Row: 666, hibernate, 持久层框架, null, null, null </span><br><span class="line">&lt;== Total: 13 </span><br><span class="line">13</span><br><span class="line">Resetting autocommit to true on JDBC Connection </span><br><span class="line">[com.mysql.cj.jdbc.ConnectionImpl@477b4cdf] </span><br><span class="line">Closing JDBC Connection </span><br><span class="line">[com.mysql.cj.jdbc.ConnectionImpl@477b4cdf] </span><br><span class="line">Returned connection 1199262943 to pool.</span><br></pre></td></tr></table></figure>
<p>通过输出我们能够发现，不同的Session中的相同操作，一级缓存是没有起作用的。</p>
<h2 id="4-3-二级缓存"><a href="#4-3-二级缓存" class="headerlink" title="4.3 二级缓存"></a>4.3 二级缓存</h2><p>二级缓存是用来解决一级缓存不能跨会话共享的问题的，范围是namespace级别的，可以被多个SqlSession共享（只要是同一个接口里面的相同方法，都可以共享），生命周期和应用同步。</p>
<p>二级缓存的设置，首先是settings中的cacheEnabled要设置为true，当然默认的就是为true，这个步骤决定了在创建Executor对象的时候是否通过CachingExecutor来装饰。</p>
<p><img src="/images/img-110.png"></p>
<p>那么设置了cacheEnabled标签为true是否就意味着 二级缓存是否一定可用呢？当然不是，我们还需要在 对应的映射文件中添加 cache 标签才行。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声明这个namespace使用二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">size</span>=<span class="string">&quot;1024&quot;</span>  &lt;!—最多缓存对象个数，默认<span class="attr">1024--</span>&gt;</span></span><br><span class="line">	eviction=&quot;LRU&quot; &lt;!— 回收策略--&gt;</span><br><span class="line">	flushInterval=&quot;120000&quot; &lt;!— 自动刷新时间 ms，未配置时只有调用时刷新--&gt;</span><br><span class="line">	readOnly=&quot;false&quot;/&gt; &lt;!—默认是false（安全） ，改为true可读写时，对象必须支持序列化 --&gt;</span><br></pre></td></tr></table></figure>

<p><strong>cache属性详解：</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>缓存实现类</td>
<td>需要实现Cache接口，默认是PerpetualCache，可以使用第三方缓存</td>
</tr>
<tr>
<td>size</td>
<td>最多缓存对象个数</td>
<td>默认1024</td>
</tr>
<tr>
<td>eviction</td>
<td>回收策略（缓存淘汰算法）</td>
<td>LRU – 最近最少使用的：移除最长时间不被使用的对象（默认）。FIFO– 先进先出：按对象进入缓存的顺序来移除它们。SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</td>
</tr>
<tr>
<td>flushInterval</td>
<td>定时自动清空缓存间隔</td>
<td>自动刷新时间，单位 ms，未配置时只有调用时刷新</td>
</tr>
<tr>
<td>readOnly</td>
<td>是否只读</td>
<td>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。false：读写缓存；会返回缓存对象的拷贝（通过序列化），不会共享。这会慢一些，但是安全，因此默认是 false。改为false可读写时，对象必须支持序列化。</td>
</tr>
<tr>
<td>blocking</td>
<td>启用阻塞缓存</td>
<td>通过在get/put方式中加锁，保证只有一个线程操作缓存，基于Java重入锁实现</td>
</tr>
</tbody></table>
<p><strong>再来看下cache标签在源码中的体现，创建cacheKey</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 获取SQL</span></span><br><span class="line">  BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">  <span class="comment">// 创建CacheKey：什么样的SQL是同一条SQL？ &gt;&gt;</span></span><br><span class="line">  CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">  <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createCacheKey自行进去查看</p>
<p><img src="/images/img-111.png"></p>
<p><img src="/images/img-112.png"></p>
<p>而这看到的和我们前面在缓存初始化时看到的 cache 标签解析操作是对应上的。所以我们要开启二级缓<br>存两个条件都要满足</p>
<p><img src="/images/img-113.png"></p>
<p><img src="/images/img-114.png"></p>
<p><strong>这样的设置表示当前的映射文件中的相关查询操作都会触发二级缓存，但如果某些个别方法我们不希望走二级缓存怎么办呢？</strong></p>
<p><strong>我们可以在标签中添加一个 useCache=false 来实现的设置不使用二级缓存</strong></p>
<p><img src="/images/img-115.png"></p>
<p>还有就是当我们执行的对应的DML操作，在MyBatis中会清空对应的二级缓存和一级缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="comment">// 增删改查的标签上有属性： flushCache=&quot;true&quot; （select语句默认是false）</span></span><br><span class="line">  <span class="comment">// 一级二级缓存都会被清理</span></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    tcm.clear(cache);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在解析映射文件的时候DML操作flushCacheRequired为true</p>
<p><img src="/images/img-116.png"></p>
<h2 id="4-4-第三方缓存"><a href="#4-4-第三方缓存" class="headerlink" title="4.4 第三方缓存"></a>4.4 第三方缓存</h2><p>在实际开发的时候我们一般也很少使用MyBatis自带的二级缓存，这时我们会使用第三方的缓存工具Ehcache获取Redis来实现,那么他们是如何来实现的呢？</p>
<p><a href="https://github.com/mybatis/redis-cache">https://github.com/mybatis/redis-cache</a></p>
<p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-beta2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后加上Cache标签的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.redis.RedisCache&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">&quot;512&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后添加redis的属性文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">host=192.168.100.120</span><br><span class="line">port=6379</span><br><span class="line">connectionTimeout=5000</span><br><span class="line">soTimeout=5000</span><br><span class="line">database=0</span><br></pre></td></tr></table></figure>
<p>测试效果</p>
<p><img src="/images/img-117.png"></p>
<p>数据存储到了Redis中</p>
<p><img src="/images/img-118.png"></p>
<p>然后大家也可以自行分析下第三方的Cache是如何替换掉PerpetualCache的，因为PerpetualCache是基于HashMap处理的，而RedisCache是基于Redis来存储缓存数据的。</p>
<p>提示</p>
<p><img src="/images/img-119.png"></p>
<p><img src="/images/img-120.png"></p>
<p>缓存模块大概就介绍到此。</p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 插件的使用及原理</title>
    <url>/2021/08/20/MyBatis%E6%8F%92%E4%BB%B6%E5%85%B3%E9%94%AE%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="MyBatis插件关键对象"><a href="#MyBatis插件关键对象" class="headerlink" title="MyBatis插件关键对象"></a>MyBatis插件关键对象</h1><hr>
<blockquote>
<p><strong>Interceptor</strong> 接口：自定义拦截器（实现类）</p>
</blockquote>
<blockquote>
<p><strong>InterceptorChain</strong>：存放插件的容器</p>
</blockquote>
<blockquote>
<p><strong>Plugin</strong>：h对象；提供创建代理类的方法</p>
</blockquote>
<blockquote>
<p><strong>Invocation</strong>：对被代理对象的封装</p>
</blockquote>
<h1 id="1-自定义插件"><a href="#1-自定义插件" class="headerlink" title="1. 自定义插件"></a>1. 自定义插件</h1><p>mybatis插件（准确的说应该是around拦截器，因为接口名是interceptor，而且invocation.proceed要自己调用，配置中叫插件）功能非常强大，<strong>可以让我们无侵入式的对SQL的执行进行干涉，从SQL语句重写、参数注入、结果集返回等每个主要环节，典型的包括权限控制检查与注入、只读库映射、K/V翻译、动态改写SQL。</strong></p>
<p>MyBatis 默认支持对<strong>4大对象</strong>（<strong>Executor，StatementHandler，ParameterHandler，ResultSetHandler</strong>）上的方法执行拦截，具体支持的方法为：</p>
<ul>
<li><p><strong>Executor</strong> (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)，主要用于sql重写。</p>
</li>
<li><p><strong>ParameterHandler</strong> (getParameterObject, setParameters)，用于参数处理。</p>
</li>
<li><p><strong>ResultSetHandler</strong> (handleResultSets, handleOutputParameters)，用于结果集二次处理。</p>
</li>
<li><p><strong>StatementHandler</strong> (prepare, parameterize, batch, update, query)，用于jdbc层的控制。</p>
</li>
</ul>
<p>大多数情况下仅在Executor做插件比如SQL重写、结果集脱敏，ResultSetHandler和StatementHandler仅在高级场景中使用，而且某些场景中非常有价值。</p>
<p><strong>四大对象的在sql执行过程中的调用链如下：</strong></p>
<p><img src="/images/img-70.png"></p>
<p>具体的方法定义可以参见每个类方法的签名，这里就不详细展开了。这四个类被创建后不是直接返回，而是创执行了interceptorChain.pluginAll(parameterHandler)才返回。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Configuration 中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    <span class="keyword">return</span> parameterHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newExecutor(transaction, defaultExecutorType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType ** <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType ** <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH ** executorType) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE ** executorType) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-1-编写Interceptor的实现类"><a href="#1-1-编写Interceptor的实现类" class="headerlink" title="1-1 编写Interceptor的实现类"></a>1-1 编写Interceptor的实现类</h2><hr>
<h3 id="Executor拦截器"><a href="#Executor拦截器" class="headerlink" title="Executor拦截器"></a>Executor拦截器</h3><h4 id="案例1"><a href="#案例1" class="headerlink" title="案例1:"></a>案例1:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">    // @Signature(type = Executor.class, method = /* org.apache.ibatis.executor.Executor中定义的方法,参数也要对应 */&quot;update&quot;, args = &#123; MappedStatement.class, Object.class&#125;),</span></span><br><span class="line"><span class="meta">    @Signature(</span></span><br><span class="line"><span class="meta">        type = Executor.class, method = &quot;query&quot;, </span></span><br><span class="line"><span class="meta">        args = &#123; MappedStatement.class, Object.class,RowBounds.class, ResultHandler.class &#125;</span></span><br><span class="line"><span class="meta">    ) </span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectPruningColumnPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ColumnPruning&gt; enablePruning = <span class="keyword">new</span> ThreadLocal&lt;ColumnPruning&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> ColumnPruning <span class="title">initialValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Logger logger = LoggerFactory.getLogger(SelectPruningColumnPlugin.class);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> MAPPED_STATEMENT_INDEX = <span class="number">0</span>;<span class="comment">// 这是对应上面的args的序号</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> PARAMETER_INDEX = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ROWBOUNDS_INDEX = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> RESULT_HANDLER_INDEX = <span class="number">3</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enablePruning.get() != <span class="keyword">null</span> &amp;&amp; enablePruning.get().isEnablePruning()) &#123;</span><br><span class="line">            Object[] queryArgs = invocation.getArgs();</span><br><span class="line">            MappedStatement mappedStatement = (MappedStatement) queryArgs[MAPPED_STATEMENT_INDEX];</span><br><span class="line">            Object parameter = queryArgs[PARAMETER_INDEX];</span><br><span class="line">            BoundSql boundSql = mappedStatement.getBoundSql(parameter);</span><br><span class="line">            String sql = boundSql.getSql();<span class="comment">// 获取到SQL ，进行调整</span></span><br><span class="line">            String name = mappedStatement.getId();</span><br><span class="line">            logger.debug(<span class="string">&quot;拦截的方法名是:&quot;</span> + name + <span class="string">&quot;,sql是&quot;</span> + sql + <span class="string">&quot;,参数是&quot;</span> + JsonUtils.toJson(parameter));</span><br><span class="line">            String execSql = pruningColumn(enablePruning.get().getReserveColumns(), sql);</span><br><span class="line">            logger.debug(<span class="string">&quot;修改后的sql是:&quot;</span> + execSql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新new一个查询语句对像</span></span><br><span class="line">            BoundSql newBoundSql = <span class="keyword">new</span> BoundSql(mappedStatement.getConfiguration(), execSql, boundSql.getParameterMappings(), boundSql.getParameterObject());</span><br><span class="line">            <span class="comment">// 把新的查询放到statement里</span></span><br><span class="line">            MappedStatement newMs = copyFromMappedStatement(mappedStatement, <span class="keyword">new</span> BoundSqlSqlSource(newBoundSql));</span><br><span class="line">            <span class="keyword">for</span> (ParameterMapping mapping : boundSql.getParameterMappings()) &#123;</span><br><span class="line">                String prop = mapping.getProperty();</span><br><span class="line">                <span class="keyword">if</span> (boundSql.hasAdditionalParameter(prop)) &#123;</span><br><span class="line">                    newBoundSql.setAdditionalParameter(prop, boundSql.getAdditionalParameter(prop));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queryArgs[MAPPED_STATEMENT_INDEX] = newMs;</span><br><span class="line">            <span class="comment">// 因为涉及分页查询PageHelper插件，所以不能设置为null，需要业务上下文执行完成后设置为null</span></span><br><span class="line"><span class="comment">//            enablePruning.set(null);</span></span><br><span class="line">        &#125;</span><br><span class="line">        Object result = invocation.proceed();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="案例2-带反射"><a href="#案例2-带反射" class="headerlink" title="案例2: 带反射"></a>案例2: 带反射</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">        @Signature(</span></span><br><span class="line"><span class="meta">            type = Executor.class,method = &quot;query&quot;,</span></span><br><span class="line"><span class="meta">            args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPageInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;将逻辑分页改为物理分页&quot;</span>);</span><br><span class="line">        Object[] args = invocation.getArgs();</span><br><span class="line">        MappedStatement ms = (MappedStatement) args[<span class="number">0</span>]; <span class="comment">// MappedStatement</span></span><br><span class="line">        BoundSql boundSql = ms.getBoundSql(args[<span class="number">1</span>]); <span class="comment">// Object parameter</span></span><br><span class="line">        RowBounds rb = (RowBounds) args[<span class="number">2</span>]; <span class="comment">// RowBounds</span></span><br><span class="line">        <span class="comment">// RowBounds为空，无需分页</span></span><br><span class="line">        <span class="keyword">if</span> (rb ** RowBounds.DEFAULT) &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原 RowBounds 参数设为 RowBounds.DEFAULT，关闭 MyBatis 内置的分页机制</span></span><br><span class="line">        <span class="comment">//args[2] = RowBounds.DEFAULT;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在SQL后加上limit语句</span></span><br><span class="line">        String sql = boundSql.getSql();</span><br><span class="line">        String limit = String.format(<span class="string">&quot;LIMIT %d,%d&quot;</span>, rb.getOffset(), rb.getLimit());</span><br><span class="line">        sql = sql + <span class="string">&quot; &quot;</span> + limit;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义sqlSource</span></span><br><span class="line">        SqlSource sqlSource = <span class="keyword">new</span> StaticSqlSource(ms.getConfiguration(), sql, boundSql.getParameterMappings());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改原来的sqlSource</span></span><br><span class="line">        Field field = MappedStatement.class.getDeclaredField(<span class="string">&quot;sqlSource&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(ms, sqlSource);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行被拦截方法</span></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ResultSetHandler拦截器"><a href="#ResultSetHandler拦截器" class="headerlink" title="ResultSetHandler拦截器"></a>ResultSetHandler拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">    @Signature(</span></span><br><span class="line"><span class="meta">        type = ResultSetHandler.class, </span></span><br><span class="line"><span class="meta">        method = &quot;handleResultSets&quot;, </span></span><br><span class="line"><span class="meta">        args = &#123; Statement.class&#125;</span></span><br><span class="line"><span class="meta">    ) </span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptMapPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object target = invocation.getTarget();</span><br><span class="line">        Statement stmt = (Statement) invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (target <span class="keyword">instanceof</span> DefaultResultSetHandler) &#123;</span><br><span class="line">            DefaultResultSetHandler resultSetHandler = (DefaultResultSetHandler) target;</span><br><span class="line">            Class clz = resultSetHandler.getMappedStatement().getResultMaps().get(<span class="number">0</span>).getType();</span><br><span class="line">            <span class="keyword">if</span> (clz ** OptMap.class) &#123;</span><br><span class="line">                List&lt;Object&gt; resultList = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">                OptMap optMap = <span class="keyword">new</span> OptMap();</span><br><span class="line">                resultList.add(optMap);</span><br><span class="line">                resultSet2OptMap(resultSetHandler.getConfiguration(),resultSetHandler,optMap,stmt.getResultSet());</span><br><span class="line">                <span class="keyword">return</span> resultList;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有进行拦截处理，则执行默认逻辑</span></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册插件"><a href="#注册插件" class="headerlink" title="注册插件"></a>注册插件</h3><p>最后将插件配置到mybatis-config.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml  注册插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.dpl.mybatis.plugin.SelectPruningColumnPlugin&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="2-插件实现原理"><a href="#2-插件实现原理" class="headerlink" title="2. 插件实现原理"></a>2. 插件实现原理</h1><h2 id="2-1-初始化操作"><a href="#2-1-初始化操作" class="headerlink" title="2-1. 初始化操作"></a>2-1. 初始化操作</h2><p>首先我们来看下在全局配置文件加载解析的时候做了什么操作。</p>
<p><img src="/images/img-121.png"></p>
<p>进入方法内部可以看到具体的解析操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">               <span class="comment">// 获取&lt;plugin&gt; 节点的 interceptor 属性的值</span></span><br><span class="line">               String interceptor = child.getStringAttribute(<span class="string">&quot;interceptor&quot;</span>);</span><br><span class="line">               <span class="comment">// 获取&lt;plugin&gt; 下的所有的properties子节点</span></span><br><span class="line">               Properties properties = child.getChildrenAsProperties();</span><br><span class="line">               <span class="comment">// 获取 Interceptor 对象</span></span><br><span class="line">               Interceptor interceptorInstance = (Interceptor)</span><br><span class="line">                       resolveClass(interceptor).getDeclaredConstructor().newInstance();</span><br><span class="line">               <span class="comment">// 设置 interceptor的 属性</span></span><br><span class="line">               interceptorInstance.setProperties(properties);</span><br><span class="line">               <span class="comment">// Configuration中记录 Interceptor</span></span><br><span class="line">               configuration.addInterceptor(interceptorInstance);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>该方法用来解析全局配置文件中的plugins标签，然后对应的创建Interceptor对象，并且封装对应的属性信息。最后调用了Configuration对象中的方法。</p>
<p>configuration.addInterceptor(interceptorInstance)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">       interceptorChain.addInterceptor(interceptor);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过这个代码我们发现我们自定义的拦截器最终是保存在了 InterceptorChain 这个对象中。而 InterceptorChain 的定义为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 保存所有的 Interceptor  也就我所有的插件是保存在 Interceptors 这个List集合中的</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      <span class="comment">// 获取拦截器链中的所有拦截器 target = interceptor.plugin(target); // 创建对应的拦截器的代理对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-如何创建代理对象"><a href="#2-2-如何创建代理对象" class="headerlink" title="2.2 如何创建代理对象"></a>2.2 如何创建代理对象</h2><p>在解析的时候创建了对应的Interceptor对象，并保存在了InterceptorChain中，那么这个拦截器是如何和对应的目标对象进行关联的呢？</p>
<p>首先拦截器可以拦截的对象是<mark>Executor</mark>,<mark>ParameterHandler</mark>,<mark>ResultSetHandler</mark>,<mark>StatementHandler</mark>. 那么我们来看下这四个对象在创建的时候又什么要注意的</p>
<h3 id="2-2-1-Executor"><a href="#2-2-1-Executor" class="headerlink" title="2.2.1 Executor"></a>2.2.1 Executor</h3><p><img src="/images/img-122.png" alt="upload successful"></p>
<p>我们可以看到Executor在装饰完二级缓存后会通过 <strong>pluginAll</strong> 来创建 Executor 的代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">    <span class="comment">// 获取拦截器链中的所有拦截器 target = interceptor.plugin(target); // 创建对应的拦截器的代理对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入plugin方法中，我们会进入到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 决定是否触发 intercept()方法</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后进入到MyBatis给我们提供的Plugin工具类的实现 wrap方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建目标对象的代理对象</span></span><br><span class="line"><span class="comment">*    目标对象 Executor  ParameterHandler  ResultSetHandler StatementHandler</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> interceptor 拦截器</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取用户自定义 Interceptor中@Signature注解的信息</span></span><br><span class="line">  <span class="comment">// getSignatureMap 负责处理@Signature 注解</span></span><br><span class="line">  Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">  <span class="comment">// 获取目标类型</span></span><br><span class="line">  Class&lt;?&gt; type = target.getClass();</span><br><span class="line">  <span class="comment">// 获取目标类型 实现的所有的接口</span></span><br><span class="line">  Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">  <span class="comment">// 如果目标类型有实现的接口 就创建代理对象</span></span><br><span class="line">  <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">    type.getClassLoader(),</span><br><span class="line">      interfaces,</span><br><span class="line">    <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则原封不动的返回目标对象</span></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Plugin中的各个方法的作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">  <span class="comment">// 目标对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Interceptor interceptor;</span><br><span class="line">  <span class="comment">// 拦截器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;</span><br><span class="line">  <span class="comment">// 记录 @Signature 注解的 信息</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Plugin</span><span class="params">(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  Set&lt;Method&gt;&gt; signatureMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    <span class="keyword">this</span>.interceptor = interceptor;</span><br><span class="line">    <span class="keyword">this</span>.signatureMap = signatureMap;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建目标对象的代理对象</span></span><br><span class="line"><span class="comment">*    目标对象 Executor  ParameterHandler  ResultSetHandler StatementHandler</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> interceptor 拦截器</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取用户自定义 Interceptor中@Signature注解的信息</span></span><br><span class="line">    <span class="comment">// getSignatureMap 负责处理@Signature 注解</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    <span class="comment">// 获取目标类型</span></span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    <span class="comment">// 获取目标类型 实现的所有的接口</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="comment">// 如果目标类型有实现的接口 就创建代理对象</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">      type.getClassLoader(),</span><br><span class="line">      interfaces,</span><br><span class="line">      <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则原封不动的返回目标对象</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 代理对象方法被调用时执行的代码</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Throwable */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取当前方法所在类或接口中，可被当前Interceptor拦截的方法</span></span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">      <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">        <span class="comment">// 当前调用的方法需要被拦截 执行拦截操作</span></span><br><span class="line">        <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 不需要拦截 则调用 目标对象中的方法</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;</span><br><span class="line">    Intercepts interceptsAnnotation =</span><br><span class="line">    interceptor.getClass().getAnnotation(Intercepts.class);</span><br><span class="line">    <span class="comment">// issue #251</span></span><br><span class="line">    <span class="keyword">if</span> (interceptsAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">&quot;No @Intercepts annotation was found in interceptor &quot;</span> + interceptor.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    Signature[] sigs = interceptsAnnotation.value();</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Signature sig : sigs) &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.computeIfAbsent(sig.type(), k -&gt; <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Method method = sig.type().getMethod(sig.method(), sig.args());</span><br><span class="line">        methods.add(method);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">&quot;Could not find method on &quot;</span> + sig.type() + <span class="string">&quot;</span></span><br><span class="line"><span class="string">named &quot;</span> + sig.method() + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signatureMap;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; interfaces = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (type != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; c : type.getInterfaces()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signatureMap.containsKey(c)) &#123;</span><br><span class="line">          interfaces.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      type = type.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> interfaces.toArray(<span class="keyword">new</span> Class&lt;?&gt;[interfaces.size()]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-StatementHandler"><a href="#2-2-2-StatementHandler" class="headerlink" title="2.2.2 StatementHandler"></a>2.2.2 StatementHandler</h3><p>在获取StatementHandler的方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, rowBounds, ResultHandler resultHandler, BoundSql</span></span></span><br><span class="line"><span class="params"><span class="function">Statement stmt = <span class="keyword">null</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">Object parameter, RowBounds     boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 注意，已经来到SQL处理的关键对象 StatementHandler &gt;&gt;</span></span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 获取一个 Statement对象</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 用完就关闭</span></span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进入newStatementHandler方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler      resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">  statementHandler = (StatementHandler)</span><br><span class="line">  interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到statementHandler的代理对象</p>
<p>2.2.3 ParameterHandler<br>在上面步骤的RoutingStatementHandler方法中，我们来看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// StatementType 是怎么来的？ 增删改查标签中的 statementType=&quot;PREPARED&quot;，默认值 PREPARED</span></span><br><span class="line">    <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> STATEMENT:</span><br><span class="line">              delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PREPARED:</span><br><span class="line">        <span class="comment">// 创建 StatementHandler 的时候做了什么？  &gt;&gt;</span></span><br><span class="line">        delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CALLABLE:</span><br><span class="line">        delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Unknown statement type: &quot;</span> +</span><br><span class="line">        ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们随便选择一个分支进入，比如PreparedStatementHandler</p>
<p><img src="/images/img-123.png" alt="upload successful"></p>
<p>在newParameterHandler的步骤我们可以发现代理对象的创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ParameterHandler parameterHandler =</span><br><span class="line">    mappedStatement.getLang().createParameterHandler(mappedStatement,</span><br><span class="line">    parameterObject, boundSql);</span><br><span class="line">    <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">    parameterHandler = (ParameterHandler)</span><br><span class="line">    interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    <span class="keyword">return</span> parameterHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-ResultSetHandler"><a href="#2-2-4-ResultSetHandler" class="headerlink" title="2.2.4 ResultSetHandler"></a>2.2.4 ResultSetHandler</h3><p>在上面的newResultSetHandler()方法中，也可以看到ResultSetHander的代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="params"><span class="function">ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">    resultSetHandler = (ResultSetHandler)</span><br><span class="line">    interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-执行流程"><a href="#2-3-执行流程" class="headerlink" title="2.3 执行流程"></a>2.3 执行流程</h2><p>以Executor的query方法为例，当查询请求到来的时候，Executor的代理对象是如何处理拦截请求的呢？我们来看下。当请求到了executor.query方法的时候</p>
<p><img src="/images/img-124.png" alt="upload successful"></p>
<p>然后会执行Plugin的invoke方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 代理对象方法被调用时执行的代码</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Throwable */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前方法所在类或接口中，可被当前Interceptor拦截的方法</span></span><br><span class="line">        Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">        <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">            <span class="comment">// 当前调用的方法需要被拦截 执行拦截操作</span></span><br><span class="line">            <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不需要拦截 则调用 目标对象中的方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后进入interceptor.intercept 会进入我们自定义的 FirstInterceptor对象中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 执行拦截逻辑的方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Throwable */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;FirtInterceptor  拦截之前 ....&quot;</span>);</span><br><span class="line">    Object obj = invocation.proceed();</span><br><span class="line">    <span class="comment">// 执行目标方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;FirtInterceptor  拦截之后 ....&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是自定义的拦截器执行的完整流程</p>
<h2 id="2-4-多拦截器"><a href="#2-4-多拦截器" class="headerlink" title="2.4 多拦截器"></a>2.4 多拦截器</h2><h3 id="插件执行顺序"><a href="#插件执行顺序" class="headerlink" title="插件执行顺序"></a>插件执行顺序</h3><p>见 <a href="https://pdyun.cc/2021/08/20/MyBatis-%E6%8F%92%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">MyBatis 插件的执行顺序</a></p>
<h3 id="插件执行流程"><a href="#插件执行流程" class="headerlink" title="插件执行流程"></a>插件执行流程</h3><p>如果我们有多个自定义的拦截器，那么他的执行流程是怎么样的呢？比如我们创建了两个 Interceptor 都是用来拦截 Executor 的query方法，一个是用来执行逻辑A 一个是用来执行逻辑B的。</p>
<p>单个拦截器的执行流程</p>
<p><img src="/images/img-125.png"></p>
<p>如果说对象被代理了多次，这里会继续调用下一个插件的逻辑，再走一次Plugin的invoke()方法。这里我们需要关注一下有多个插件的时候的运行顺序。</p>
<p>配置的顺序和执行的顺序是相反的。InterceptorChain的List是按照插件从上往下的顺序解析、添加的。</p>
<p>而创建代理的时候也是按照list的顺序代理。执行的时候当然是从最后代理的对象开始。</p>
<p><img src="/images/img-126.png"></p>
<p>这个我们可以通过实际的案例来得到验证，最后来总结下Interceptor的相关对象的作用</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Interceptor</td>
<td>自定义插件需要实现接口，实现4个方法</td>
</tr>
<tr>
<td>InterceptChain</td>
<td>配置的插件解析后会保存在Configuration的InterceptChain中</td>
</tr>
<tr>
<td>Plugin</td>
<td>触发管理类，还可以用来创建代理对象</td>
</tr>
<tr>
<td>Invocation</td>
<td>对被代理类进行包装，可以调用proceed()调用到被拦截的方法</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 相关面试答疑</title>
    <url>/2021/08/20/MyBatis-%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E7%AD%94%E7%96%91/</url>
    <content><![CDATA[<h1 id="一、配置解析过程"><a href="#一、配置解析过程" class="headerlink" title="一、配置解析过程"></a>一、配置解析过程</h1><ul>
<li><p>解析 MyBatis 配置文件<br>首先通过创建 SqlSessionFactoryBuilder 对象的 build() 方法来创建 SqlSessionFactory对象, 其中用 XMLConfigBuilder 读取并解析 MyBatis 配置文件读取各个标签的属性封装成 Configuration 对象. </p>
<p>在解析 mapper.xml 的时候, 主要做了两个事情: </p>
<ul>
<li>(1) 将 mapper.xml 文件中的 ‘增删改查’ 语句封装成 MappedStatment 对象; </li>
<li>(2) 将 mapper 接口文件 与 MapperProxyFactory**[用于后面创建mapper代理对象]** 对象相关联; </li>
</ul>
<p>最后返回一个默认的 <strong>DefaultSqlSessionFactory</strong> 对象.</p>
</li>
</ul>
<h1 id="二、SqlSession-的创建过程"><a href="#二、SqlSession-的创建过程" class="headerlink" title="二、SqlSession 的创建过程"></a>二、SqlSession 的创建过程</h1><ul>
<li>SqlSession 的实现类是什么?</li>
</ul>
<p><strong>默认是 DefaultSqlSession.</strong> </p>
<ul>
<li>其他还创建了什么对象?<br>创建 SqlSession 时还通过事务工厂创建了 <strong>事务对象</strong>、<strong>Executor对象</strong>( <strong>SIMPLE/REUSE/BATCH</strong> 默认为<strong>SIMPLE</strong>, 当二级缓存开关打开时, 会封装成 <strong>CachingExecutor</strong> )<ul>
<li><strong>SimpleExecutor</strong>:<br>默认的执行器,  根据对应的sql直接执行即可, 不会做一些额外的操作. </li>
<li><strong>BatchExecutor</strong>:<br>通过批量操作来优化性能的执行器.</li>
<li><strong>ReuseExecutor</strong>:<br>可重用的执行器, 重用对象是Statement, 该执行器会缓存同一个sql的Statement, 省去Statement的重新创建, 优化性能.</li>
</ul>
</li>
</ul>
<h1 id="三、Mapper-对象"><a href="#三、Mapper-对象" class="headerlink" title="三、Mapper 对象"></a>三、Mapper 对象</h1><ol>
<li><p>Mapper 对象是什么对象?<br>mapper 对象是一个JDK动态代理对象. </p>
</li>
<li><p>为什么要从 SqlSession 里面去获取?</p>
</li>
<li><p>为什么传进去一个接口, 然后还要用接口类型来接收?<br>底层使用了JDK的动态代理, 给接口创建了一个代理对象.</p>
</li>
</ol>
<h1 id="四、执行-SQL"><a href="#四、执行-SQL" class="headerlink" title="四、执行 SQL"></a>四、执行 SQL</h1><ol>
<li>为什么 Mybatis 的动态代理不需要实现类?</li>
<li>接口没有实现类, 调用的是什么方法?</li>
<li>接口方法怎么找到要执行的 SQL ?</li>
<li>方法参数是怎么转换成 SQL 参数的?</li>
<li>结果集怎么转换成对象?</li>
</ol>
<h1 id="五、Mybatis-核心对象"><a href="#五、Mybatis-核心对象" class="headerlink" title="五、Mybatis 核心对象"></a>五、Mybatis 核心对象</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Configuration </span><br><span class="line">SqlSession </span><br><span class="line">Executor </span><br><span class="line">MapperProxy </span><br><span class="line">StatementHandler </span><br><span class="line">ParameterHandler </span><br><span class="line">ResultSetHandler </span><br><span class="line">MappedStatement </span><br><span class="line">MapperMethod </span><br><span class="line">SqlSource </span><br><span class="line">BoundSql</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>面试答疑</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 源码加中文注释</title>
    <url>/2021/08/20/MyBatis-%E6%BA%90%E7%A0%81%E5%8A%A0%E4%B8%AD%E6%96%87%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<h1 id="MyBatis如何给源码加中文注释？"><a href="#MyBatis如何给源码加中文注释？" class="headerlink" title="MyBatis如何给源码加中文注释？"></a>MyBatis如何给源码加中文注释？</h1><p>我们在看框架源码的时候，如果没有注释，看起来会比较吃力。所以如果能够一边看源码一边自己加中文注释，下次阅读的时候就会轻松很多。</p>
<p>问题是：通过maven下载的jar，查看源码，实际上看到的是经过反编译的class文件，是不能够修改的（提示：file is read only）。</p>
<p>如果把当前maven下载的jar包强行关联到自己下载的源码，又有可能会出现字节码跟源码文件不一致的情况（提示：Library source does not match the bytecode for class），导致debug的时候无法进入代码。</p>
<p>如果要保证源码和字节码一致，最好的办法当然是在本地把下载的源码编译生成jar包，上传到本地maven仓库，再引用这个jar。</p>
<p>以MyBatis为例，如果我们要给MyBatis源码加上中文注释（以IDEA操作为例）：</p>
<h2 id="1-配置Maven"><a href="#1-配置Maven" class="headerlink" title="1. 配置Maven"></a>1. 配置Maven</h2><p>因为需要用Maven打包编译源代码，所以第一步是检查Maven的配置。</p>
<p>第一个是环境变量，需要在系统变量中添加MAVEN_HOME，配置Maven主路径，例如“E:\dev\apache-maven-3.5.4”，确保mvn命令可以使用。</p>
<p>第二个是检查Maven的配置。Maven运行时，默认会使用conf目录下的settings.xml配置，例如：E:\dev\apache-maven-3.5.4\conf\settings.xml。</p>
<p>为了保证下载速度，建议配置成国内的aliyun中央仓库（此处需要自行搜索）。</p>
<p>并且，settings.xml中的localRepository应该和IDEA中打开的项目设置中的Local repository保持一致（例如：E:\repository）。否则项目引入依赖时，无法读取到编译后的jar包。</p>
<p><img src="/images/img-156.png"></p>
<h2 id="2-下载编译MyBatis源码"><a href="#2-下载编译MyBatis源码" class="headerlink" title="2. 下载编译MyBatis源码"></a>2. 下载编译MyBatis源码</h2><p>因为MyBatis源码编译依赖parent项目的源码，所以第一步是编译parent项目。<br>先从git clone两个工程的项目（截止2020年4月，最新版本是3.5.4）。</p>
<p>以在E盘根目录下载为例。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/mybatis/parent</span><br><span class="line">git clone https://github.com/mybatis/mybatis-3</span><br></pre></td></tr></table></figure>

<p>打开mybatis-3中的pom.xml文件，查看parent的版本号，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>确定parent版本是31（记住这个数字）。<br>把mybatis版本号改成自定义的版本号，避免跟官方版本号冲突（加上了-snapshot）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4-snapshot<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>进入parent目录，切换项目分支（不能在默认的master分支中编译），工程名后面的数字就是前面看到的parent版本号。</p>
<p>开始编译parent项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd parent</span><br><span class="line">git checkout mybatis-parent-31</span><br><span class="line">mvn install</span><br></pre></td></tr></table></figure>

<p><img src="/images/img-157.png"></p>
<p>接下来编译mybatis工程，进入mybatis-3目录，切换到最新3.5.4分支（不能在默认的master分支中编译）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ../mybatis-3</span><br><span class="line">git checkout mybatis-3.5.4</span><br><span class="line">mvn clean</span><br><span class="line">mvn install -DskipTests=true -Dmaven.test.skip=true -Dlicense.skip=true</span><br></pre></td></tr></table></figure>

<p><img src="/images/img-158.png"></p>
<p>编译完毕，本地仓库就会出现一个编译后的jar包，例如：E:\repository\org\mybatis\mybatis\3.5.4-snapshot\mybatis-3.5.4-snapshot.jar</p>
<p>在我们的项目中就可以引入这个jar包了（version是自定义的version）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4-snapshot<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-关联jar包到源码"><a href="#3-关联jar包到源码" class="headerlink" title="3. 关联jar包到源码"></a>3. 关联jar包到源码</h2><p>本地编译的jar包已经有了，接下来是把jar包和源码关联起来。</p>
<p>Project Structure —— Libries —— Maven: org.mybatis:mybatis:3.5.4-snapshot —— 在原来的Sources上面点+（加号） —— 选择到下载的源码路径，例如：E:\mybatis-3\src\main\java，点击OK</p>
<p><img src="/images/img-159.png"></p>
<p>关联好之后，开始打断点debug，就会进入到本地的源码，可以给本地的源码加上注释了。</p>
<p><img src="/images/img-160.png"></p>
<h2 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h2><p>1、如果之前打开过类的字节码文件，本地可能有缓存，一样会有“Library source does not match the bytecode for class”的提示。</p>
<pre><code>解决办法：File —— Invalidate Caches and Restart（IDEA会重启）。
</code></pre>
<p>2、如果添加注释导致了debug的当前行跟实际行不一致，再把mybatis3工程编译一次即可。</p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2022/03/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>转载自：<a href="https://blog.csdn.net/mu_wind/article/details/113806680">https://blog.csdn.net/mu_wind/article/details/113806680</a></p>
<h1 id="初识线程池"><a href="#初识线程池" class="headerlink" title="初识线程池"></a>初识线程池</h1><p>我们知道，线程的创建和销毁都需要映射到操作系统，因此其代价是比较高昂的。出于避免频繁创建、销毁线程以及方便线程管理的需要，线程池应运而生。</p>
<h2 id="线程池优势"><a href="#线程池优势" class="headerlink" title="线程池优势"></a>线程池优势</h2><ul>
<li>降低资源消耗：线程池通常会维护一些线程（数量为 corePoolSize），这些线程被重复使用来执行不同的任务，任务完成后不会销毁。在待处理任务量很大的时候，通过对线程资源的复用，避免了线程的频繁创建与销毁，从而降低了系统资源消耗。</li>
<li>提高响应速度：由于线程池维护了一批 alive 状态的线程，当任务到达时，不需要再创建线程，而是直接由这些线程去执行任务，从而减少了任务的等待时间。</li>
<li>提高线程的可管理性：使用线程池可以对线程进行统一的分配，调优和监控。</li>
</ul>
<h2 id="线程池设计思路"><a href="#线程池设计思路" class="headerlink" title="线程池设计思路"></a>线程池设计思路</h2><p>有句话叫做艺术来源于生活，编程语言也是如此，很多设计思想能映射到日常生活中，比如面向对象思想、封装、继承，等等。今天我们要说的线程池，它同样可以在现实世界找到对应的实体——工厂。<br>先假想一个工厂的生产流程：<br><img src="/images/img-161.png"></p>
<p>工厂中有固定的一批工人，称为正式工人，工厂接收的订单由这些工人去完成。当订单增加，正式工人已经忙不过来了，工厂会将生产原料暂时堆积在仓库中，等有空闲的工人时再处理（因为工人空闲了也不会主动处理仓库中的生产任务，所以需要调度员实时调度）。仓库堆积满了后，订单还在增加怎么办？工厂只能临时扩招一批工人来应对生产高峰，而这批工人高峰结束后是要清退的，所以称为临时工。当时临时工也以招满后（受限于工位限制，临时工数量有上限），后面的订单只能忍痛拒绝了。</p>
<p>我们做如下一番映射：</p>
<ul>
<li>工厂——线程池</li>
<li>订单——任务（Runnable）</li>
<li>正式工人——核心线程</li>
<li>临时工——普通线程</li>
<li>仓库——任务队列</li>
<li>调度员——getTask()<blockquote>
<p>getTask()是一个方法，将任务队列中的任务调度给空闲线程，在解读线程池有详细介绍  </p>
</blockquote>
</li>
</ul>
<p>映射后，形成线程池流程图如下，两者是不是有异曲同工之妙？<br><img src="/images/img-162.png"></p>
<p>这样，线程池的工作原理或者说流程就很好理解了，提炼成一个简图：<br><img src="/images/img-163.png"></p>
<h1 id="深入线程池"><a href="#深入线程池" class="headerlink" title="深入线程池"></a>深入线程池</h1><p>那么接下来，问题来了，线程池是具体如何实现这套工作机制的呢？从Java线程池Executor框架体系可以看出：线程池的真正实现类是ThreadPoolExecutor，因此我们接下来重点研究这个类。<br><img src="/images/img-164.png"></p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>研究一个类，先从它的构造方法开始。ThreadPoolExecutor提供了4个有参构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解释一下构造方法中涉及到的参数：</p>
<ul>
<li>corePoolSize（必需）：核心线程数。即池中一直保持存活的线程数，即使这些线程处于空闲。但是将allowCoreThreadTimeOut参数设置为true后，核心线程处于空闲一段时间以上，也会被回收。</li>
<li>maximumPoolSize（必需）：池中允许的最大线程数。当核心线程全部繁忙且任务队列打满之后，线程池会临时追加线程，直到总线程数达到maximumPoolSize这个上限。</li>
<li>keepAliveTime（必需）：线程空闲超时时间。当非核心线程处于空闲状态的时间超过这个时间后，该线程将被回收。将allowCoreThreadTimeOut参数设置为true后，核心线程也会被回收。</li>
<li>unit（必需）：keepAliveTime参数的时间单位。有：TimeUnit.DAYS（天）、TimeUnit.HOURS（小时）、TimeUnit.MINUTES（分钟）、TimeUnit.SECONDS（秒）、TimeUnit.MILLISECONDS（毫秒）、TimeUnit.MICROSECONDS（微秒）、TimeUnit.NANOSECONDS（纳秒）</li>
<li>workQueue（必需）：任务队列，采用阻塞队列实现。当核心线程全部繁忙时，后续由execute方法提交的Runnable将存放在任务队列中，等待被线程处理。</li>
<li>threadFactory（可选）：线程工厂。指定线程池创建线程的方式。</li>
<li>handler（可选）：拒绝策略。当线程池中线程数达到maximumPoolSize且workQueue打满时，后续提交的任务将被拒绝，handler可以指定用什么方式拒绝任务。  </li>
</ul>
<p>放到一起再看一下：<br><img src="/images/img-165.png"></p>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>使用ThreadPoolExecutor需要指定一个实现了BlockingQueue接口的任务等待队列。在ThreadPoolExecutor线程池的API文档中，一共推荐了三种等待队列，它们是：SynchronousQueue、LinkedBlockingQueue和ArrayBlockingQueue；</p>
<ol>
<li>SynchronousQueue：同步队列。这是一个内部没有任何容量的阻塞队列，任何一次插入操作的元素都要等待相对的删除/读取操作，否则进行插入操作的线程就要一直等待，反之亦然。</li>
<li>LinkedBlockingQueue：无界队列（严格来说并非无界，上限是Integer.MAX_VALUE），基于链表结构。使用无界队列后，当核心线程都繁忙时，后续任务可以无限加入队列，因此线程池中线程数不会超过核心线程数。这种队列可以提高线程池吞吐量，但代价是牺牲内存空间，甚至会导致内存溢出。另外，使用它时可以指定容量，这样它也就是一种有界队列了。</li>
<li>ArrayBlockingQueue：有界队列，基于数组实现。在线程池初始化时，指定队列的容量，后续无法再调整。这种有界队列有利于防止资源耗尽，但可能更难调整和控制。  </li>
</ol>
<p>另外，Java还提供了另外4种队列：</p>
<ol>
<li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列。存放在PriorityBlockingQueue中的元素必须实现Comparable接口，这样才能通过实现compareTo()方法进行排序。优先级最高的元素将始终排在队列的头部；PriorityBlockingQueue不会保证优先级一样的元素的排序，也不保证当前队列中除了优先级最高的元素以外的元素，随时处于正确排序的位置。</li>
<li>DelayQueue：延迟队列。基于二叉堆实现，同时具备：无界队列、阻塞队列、优先队列的特征。DelayQueue延迟队列中存放的对象，必须是实现Delayed接口的类对象。通过执行时延从队列中提取任务，时间没到任务取不出来。更多内容请见DelayQueue。</li>
<li>LinkedBlockingDeque：双端队列。基于链表实现，既可以从尾部插入/取出元素，还可以从头部插入元素/取出元素。</li>
<li>LinkedTransferQueue：由链表结构组成的无界阻塞队列。这个队列比较特别的时，采用一种预占模式，意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为null的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素。</li>
</ol>
<h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>线程池有一个重要的机制：拒绝策略。当线程池workQueue已满且无法再创建新线程池时，就要拒绝后续任务了。拒绝策略需要实现RejectedExecutionHandler接口，不过Executors框架已经为我们实现了4种拒绝策略：</p>
<ol>
<li>AbortPolicy（默认）：丢弃任务并抛出RejectedExecutionException异常。</li>
<li>CallerRunsPolicy：直接运行这个任务的run方法，但并非是由线程池的线程处理，而是交由任务的调用线程处理。</li>
<li>DiscardPolicy：直接丢弃任务，不抛出任何异常。</li>
<li>DiscardOldestPolicy：将当前处于等待队列列头的等待任务强行取出，然后再试图将当前被拒绝的任务提交到线程池执行。  </li>
</ol>
<p>线程工厂指定创建线程的方式，这个参数不是必选项，Executors类已经为我们非常贴心地提供了一个默认的线程工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default thread factory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                              Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                      poolNumber.getAndIncrement() +</span><br><span class="line">                     <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><p>线程池有5种状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> runState;</span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>
<p><code>runState</code>表示当前线程池的状态，它是一个 volatile 变量用来保证线程之间的可见性。</p>
<p>下面的几个static final变量表示runState可能的几个取值，有以下几个状态：</p>
<ul>
<li>RUNNING：当创建线程池后，初始时，线程池处于RUNNING状态；</li>
<li>SHUTDOWN：如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</li>
<li>STOP：如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</li>
<li>TERMINATED：当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。</li>
</ul>
<h2 id="初始化-amp-容量调整-amp-关闭"><a href="#初始化-amp-容量调整-amp-关闭" class="headerlink" title="初始化&amp;容量调整&amp;关闭"></a>初始化&amp;容量调整&amp;关闭</h2><ol>
<li>线程初始化<br>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。<br>在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：  <ul>
<li>prestartCoreThread()：boolean prestartCoreThread()，初始化一个核心线程</li>
<li>prestartAllCoreThreads()：int prestartAllCoreThreads()，初始化所有核心线程，并返回初始化的线程数<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prestartCoreThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addIfUnderCorePoolSize(<span class="keyword">null</span>); <span class="comment">//注意传进去的参数是null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addIfUnderCorePoolSize(<span class="keyword">null</span>))<span class="comment">//注意传进去的参数是null</span></span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>线程池关闭<br>ThreadPoolExecutor提供了两个方法，用于线程池的关闭：  <ul>
<li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li>
<li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li>
</ul>
</li>
<li>线程池容量调整<br>ThreadPoolExecutor提供了动态调整线程池容量大小的方法：  <ul>
<li>setCorePoolSize：设置核心池大小</li>
<li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小  <blockquote>
<p>当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h1 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h1><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>通过构造方法使用ThreadPoolExecutor是线程池最直接的使用方式，下面看一个实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建线程池</span></span><br><span class="line">		ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, TimeUnit.SECONDS,</span><br><span class="line">				<span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">		<span class="comment">// 向线程池提交任务</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadPool.getCorePoolSize(); i++) &#123;</span><br><span class="line">			threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">2</span>; x++) &#123;</span><br><span class="line">						System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + x);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 关闭线程池</span></span><br><span class="line">		threadPool.shutdown(); <span class="comment">// 设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程</span></span><br><span class="line">		<span class="comment">// threadPool.shutdownNow(); // 设置线程池的状态为STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，该方法要慎用，容易造成不可控的后果</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pool-1-thread-1:0</span><br><span class="line">pool-1-thread-2:0</span><br><span class="line">pool-1-thread-3:0</span><br><span class="line">pool-1-thread-1:1</span><br><span class="line">pool-1-thread-2:1</span><br><span class="line">pool-1-thread-3:1</span><br></pre></td></tr></table></figure>
<h2 id="Executors封装线程池"><a href="#Executors封装线程池" class="headerlink" title="Executors封装线程池"></a>Executors封装线程池</h2><p>另外，Executors封装好了4种常见的功能线程池（还是那么地贴心）：</p>
<ol>
<li>FixedThreadPool<br>固定容量线程池。其特点是最大线程数就是核心线程数，意味着线程池只能创建核心线程，keepAliveTime为0，即线程执行完任务立即回收。任务队列未指定容量，代表使用默认值Integer.MAX_VALUE。适用于需要控制并发线程的场景。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用默认线程工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要自定义线程工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用示例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建线程池对象，设置核心线程和最大线程数为5</span></span><br><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 2. 创建Runnable（任务）</span></span><br><span class="line">Runnable task =<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;运行&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 3. 向线程池提交任务</span></span><br><span class="line">fixedThreadPool.execute(task);</span><br></pre></td></tr></table></figure></li>
<li>SingleThreadExecutor<br>单线程线程池。特点是线程池中只有一个线程（核心线程），线程执行完任务立即回收，使用有界阻塞队列（容量未指定，使用默认值Integer.MAX_VALUE）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为节省篇幅，省略了自定义线程工厂方式的源码</span></span><br></pre></td></tr></table></figure>
使用示例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建单线程线程池</span></span><br><span class="line">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">// 2. 创建Runnable（任务）</span></span><br><span class="line">Runnable task = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;运行&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 3. 向线程池提交任务</span></span><br><span class="line">singleThreadExecutor.execute(task);</span><br></pre></td></tr></table></figure></li>
<li>ScheduledThreadPool<br>定时线程池。指定核心线程数量，普通线程数量无限，线程执行完任务立即回收，任务队列为延时阻塞队列。这是一个比较特别的线程池，适用于执行定时或周期性的任务。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了 ThreadPoolExecutor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数，省略了自定义线程工厂的构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          	<span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 延时执行任务</span></span><br><span class="line">	<span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                       <span class="keyword">long</span> delay,</span><br><span class="line">                                       TimeUnit unit) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 定时执行任务</span></span><br><span class="line">	<span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                  <span class="keyword">long</span> period,</span><br><span class="line">                                                  TimeUnit unit) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用示例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建定时线程池</span></span><br><span class="line">ExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 2. 创建Runnable（任务）</span></span><br><span class="line">Runnable task = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;运行&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 3. 向线程池提交任务</span></span><br><span class="line">scheduledThreadPool.schedule(task, <span class="number">2</span>, TimeUnit.SECONDS); <span class="comment">// 延迟2s后执行任务</span></span><br><span class="line">scheduledThreadPool.scheduleAtFixedRate(task,<span class="number">50</span>,<span class="number">2000</span>,TimeUnit.MILLISECONDS);<span class="comment">// 延迟50ms后、每隔2000ms执行任务</span></span><br></pre></td></tr></table></figure></li>
<li>CachedThreadPool<br>缓存线程池。没有核心线程，普通线程数量为Integer.MAX_VALUE（可以理解为无限），线程闲置60s后回收，任务队列使用SynchronousQueue这种无容量的同步队列。适用于任务量大但耗时低的场景。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">blic <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用示例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建缓存线程池</span></span><br><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 2. 创建Runnable（任务）</span></span><br><span class="line">Runnable task = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;运行&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 3. 向线程池提交任务</span></span><br><span class="line">cachedThreadPool.execute(task);</span><br></pre></td></tr></table></figure>
<h1 id="解读线程池"><a href="#解读线程池" class="headerlink" title="解读线程池"></a>解读线程池</h1>OK，相信前面内容阅读起来还算轻松愉悦吧，那么从这里开始就进入深水区了，如果后面内容能吃透，那么线程池知识就真的被你掌握了。</li>
</ol>
<p>我们知道，向线程池提交任务是用ThreadPoolExecutor的execute()方法，但在其内部，线程任务的处理其实是相当复杂的，涉及到ThreadPoolExecutor、Worker、Thread三个类的6个方法：<br><img src="/images/img-166.png"></p>
<h2 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h2><p>在ThreadPoolExecutor类中，任务提交方法的入口是execute(Runnable command)方法（submit()方法也是调用了execute()），该方法其实只在尝试做一件事：经过各种校验之后，调用 addWorker(Runnable command,boolean core)方法为线程池创建一个线程并执行任务，与之相对应，execute() 的结果有两个：</p>
<h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><ul>
<li>Runnable command：待执行的任务</li>
</ul>
<h3 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h3><ol>
<li>通过 ctl.get() 得到线程池的当前线程数，如果线程数小于corePoolSize，则调用 addWorker(commond,true)方法创建新的线程执行任务，否则执行步骤2；</li>
<li>步骤1失败，说明已经无法再创建新线程，那么考虑将任务放入阻塞队列，等待执行完任务的线程来处理。基于此，判断线程池是否处于Running状态（只有Running状态的线程池可以接受新任务），如果任务添加到任务队列成功则进入步骤3，失败则进入步骤4；</li>
<li>来到这一步需要说明任务已经加入任务队列，这时要二次校验线程池的状态，会有以下情形：<ul>
<li>线程池不再是Running状态了，需要将任务从任务队列中移除，如果移除成功则拒绝本次任务</li>
<li>线程池是Running状态，则判断线程池工作线程是否为0，是则调用 addWorker(commond,true)添加一个没有初始任务的线程（这个线程将去获取已经加入任务队列的本次任务并执行），否则进入步骤4；</li>
<li>线程池不是Running状态，但从任务队列移除任务失败（可能已被某线程获取？），进入步骤4；</li>
</ul>
</li>
<li>将线程池扩容至maximumPoolSize并调用 addWorker(commond,false)方法创建新的线程执行任务，失败则拒绝本次任务。</li>
</ol>
<h3 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h3><p><img src="/images/img-167.png"></p>
<h3 id="源码详读："><a href="#源码详读：" class="headerlink" title="源码详读："></a>源码详读：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在将来的某个时候执行给定的任务。任务可以在新线程中执行，也可以在现有的池线程中执行。</span></span><br><span class="line"><span class="comment"> * 如果由于此执行器已关闭或已达到其容量而无法提交任务以供执行，则由当前的&#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;处理该任务。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command the task to execute  待执行的任务命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1. 如果运行的线程少于corePoolSize，将尝试以给定的命令作为第一个任务启动新线程。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. 如果一个任务可以成功排队，那么我们仍然需要仔细检查两点，其一，我们是否应该添加一个线程</span></span><br><span class="line"><span class="comment">     * （因为自从上次检查至今，一些存在的线程已经死亡），其二，线程池状态此时已改变成非运行态。因此，我们重新检查状态，如果检查不通过，则移除已经入列的任务，如果检查通过且线程池线程数为0，则启动新线程。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 3. 如果无法将任务加入任务队列，则将线程池扩容到极限容量并尝试创建一个新线程，如果失败则拒绝任务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 步骤1：判断线程池当前线程数是否小于线程池大小</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 增加一个工作线程并添加任务，成功则返回，否则进行步骤2</span></span><br><span class="line">        <span class="comment">// true代表使用coreSize作为边界约束，否则使用maximumPoolSize</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 步骤2：不满足workerCountOf(c) &lt; corePoolSize或addWorker失败，进入步骤2</span></span><br><span class="line">    <span class="comment">// 校验线程池是否是Running状态且任务是否成功放入workQueue（阻塞队列）</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再次校验，如果线程池非Running且从任务队列中移除任务成功，则拒绝该任务</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果线程池工作线程数量为0，则新建一个空任务的线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果线程池不是Running状态，是加入不进去的</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 步骤3：如果线程池不是Running状态或任务入列失败，尝试扩容maxPoolSize后再次addWorker，失败则拒绝任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker()"></a>addWorker()</h2><p>addWorker(Runnable firstTask, boolean core) 方法，顾名思义，向线程池添加一个带有任务的工作线程。</p>
<h3 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h3><ul>
<li>Runnable firstTask：新创建的线程应该首先运行的任务（如果没有，则为空）。</li>
<li>boolean core：该参数决定了线程池容量的约束条件，即当前线程数量以何值为极限值。参数为 true 则使用corePollSize 作为约束值，否则使用maximumPoolSize。</li>
</ul>
<h3 id="执行流程：-1"><a href="#执行流程：-1" class="headerlink" title="执行流程："></a>执行流程：</h3><ol>
<li>外层循环判断线程池的状态是否可以新增工作线程。这层校验基于下面两个原则：<ul>
<li>线程池为Running状态时，既可以接受新任务也可以处理任务</li>
<li>线程池为关闭状态时只能新增空任务的工作线程（worker）处理任务队列（workQueue）中的任务不能接受新任务</li>
</ul>
</li>
<li>内层循环向线程池添加工作线程并返回是否添加成功的结果。<ul>
<li>首先校验线程数是否已经超限制，是则返回false，否则进入下一步</li>
<li>通过CAS使工作线程数+1，成功则进入步骤3，失败则再次校验线程池是否是运行状态，是则继续内层循环，不是则返回外层循环</li>
</ul>
</li>
<li>核心线程数量+1成功的后续操作：添加到工作线程集合，并启动工作线程<ul>
<li>首先获取锁之后，再次校验线程池状态（具体校验规则见代码注解），通过则进入下一步，未通过则添加线程失败</li>
<li>线程池状态校验通过后，再检查线程是否已经启动，是则抛出异常，否则尝试将线程加入线程池</li>
<li>检查线程是否启动成功，成功则返回true，失败则进入 addWorkerFailed 方法</li>
</ul>
</li>
</ol>
<h3 id="流程图：-1"><a href="#流程图：-1" class="headerlink" title="流程图："></a>流程图：</h3><p><img src="/images/img-168.png"></p>
<h3 id="源码详读：-1"><a href="#源码详读：-1" class="headerlink" title="源码详读："></a>源码详读：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外层循环：判断线程池状态</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 1.线程池为非Running状态（Running状态则既可以新增核心线程也可以接受任务）</span></span><br><span class="line"><span class="comment">         * 2.线程为shutdown状态且firstTask为空且队列不为空</span></span><br><span class="line"><span class="comment">         * 3.满足条件1且条件2不满足，则返回false</span></span><br><span class="line"><span class="comment">         * 4.条件2解读：线程池为shutdown状态时且任务队列不为空时，可以新增空任务的线程来处理队列中的任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 内层循环：线程池添加核心线程并返回是否添加成功的结果</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 校验线程池已有线程数量是否超限：</span></span><br><span class="line">            <span class="comment">// 1.线程池最大上限CAPACITY </span></span><br><span class="line">            <span class="comment">// 2.corePoolSize或maximumPoolSize（取决于入参core）</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize)) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 通过CAS操作使工作线程数+1，跳出外层循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) </span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 线程+1失败，重读ctl</span></span><br><span class="line">            c = ctl.get();   <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 如果此时线程池状态不再是running，则重新进行外层循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// 其他 CAS 失败是因为工作线程数量改变了，继续内层循环尝试CAS对线程数+1</span></span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心线程数量+1成功的后续操作：添加到工作线程集合，并启动工作线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 下面代码需要加锁：线程池主锁</span></span><br><span class="line">            mainLock.lock(); </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 持锁期间重新检查，线程工厂创建线程失败或获取锁之前关闭的情况发生时，退出</span></span><br><span class="line">                <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 再次检验线程池是否是running状态或线程池shutdown但线程任务为空</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 线程已经启动，则抛出非法线程状态异常</span></span><br><span class="line">                    <span class="comment">// 为什么会存在这种状态呢？未解决</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w); <span class="comment">//加入线程池</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">// 如果当前工作线程数超过线程池曾经出现过的最大线程数，刷新后者值</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s; </span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123; <span class="comment">// 工作线程添加成功，启动该线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//线程启动失败，则进入addWorkerFailed</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted) </span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h2><p>Worker类是内部类，既实现了Runnable，又继承了AbstractQueuedSynchronizer（以下简称AQS），所以其既是一个可执行的任务，又可以达到锁的效果。<br>Worker类主要维护正在运行任务的线程的中断控制状态，以及其他次要的记录。这个类适时地继承了AbstractQueuedSynchronizer类，以简化获取和释放锁（该锁作用于每个任务执行代码）的过程。这样可以防止去中断正在运行中的任务，只会中断在等待从任务队列中获取任务的线程。<br>我们实现了一个简单的不可重入互斥锁，而不是使用可重入锁，因为我们不希望工作任务在调用setCorePoolSize之类的池控制方法时能够重新获取锁。另外，为了在线程真正开始运行任务之前禁止中断，我们将锁状态初始化为负值，并在启动时清除它（在runWorker中）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread; </span><br><span class="line">     </span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 通过构造函数初始化，</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">//设置AQS的同步状态</span></span><br><span class="line">        <span class="comment">// state：锁状态，-1为初始值，0为unlock状态，1为lock状态</span></span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker  在调用runWorker前，禁止中断</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 线程工厂创建一个线程</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>); <span class="comment">//runWorker()是ThreadPoolExecutor的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state. 0代表“没被锁定”状态</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state. 1代表“锁定”状态</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁的方法</span></span><br><span class="line"><span class="comment">     * 重写AQS的tryAcquire()，AQS本来就是让子类来实现的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断原值为0，且重置为1，所以state为-1时，锁无法获取。</span></span><br><span class="line">        <span class="comment">// 每次都是0-&gt;1，保证了锁的不可重入性</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 设置exclusiveOwnerThread=当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread()); </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试释放锁</span></span><br><span class="line"><span class="comment">     * 不是state-1，而是置为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>); </span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中断（如果运行）</span></span><br><span class="line"><span class="comment">     * shutdownNow时会循环对worker线程执行</span></span><br><span class="line"><span class="comment">     * 且不需要获取worker锁，即使在worker运行时也可以中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="comment">//如果state&gt;=0、t!=null、且t没有被中断</span></span><br><span class="line">        <span class="comment">//new Worker()时state==-1，说明不能中断</span></span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker()"></a>runWorker()</h2><p>可以说，runWorker(Worker w) 是线程池中真正处理任务的方法，前面的execute() 和 addWorker() 都是在为该方法做准备和铺垫。</p>
<h3 id="参数说明：-2"><a href="#参数说明：-2" class="headerlink" title="参数说明："></a>参数说明：</h3><ul>
<li>Worker w：封装的Worker，携带了工作线程的诸多要素，包括Runnable（待处理任务）、lock（锁）、completedTasks（记录线程池已完成任务数）</li>
</ul>
<h3 id="执行流程：-2"><a href="#执行流程：-2" class="headerlink" title="执行流程："></a>执行流程：</h3><ol>
<li>判断当前任务或者从任务队列中获取的任务是否不为空，都为空则进入步骤2，否则进入步骤3</li>
<li>任务为空，则将completedAbruptly置为false（即线程不是突然终止），并执行processWorkerExit(w,completedAbruptly)方法进入线程退出程序</li>
<li>任务不为空，则进入循环，并加锁</li>
<li>判断是否为线程添加中断标识，以下两个条件满足其一则添加中断标识：<ul>
<li>线程池状态&gt;=STOP,即STOP或TERMINATED</li>
<li>一开始判断线程池状态&lt;STOP，接下来检查发现Thread.interrupted()为true，即线程已经被中断，再次检查线程池状态是否&gt;=STOP（以消除该瞬间shutdown方法生效，使线程池处于STOP或TERMINATED）</li>
</ul>
</li>
<li>执行前置方法 beforeExecute(wt, task)（该方法为空方法，由子类实现）后执行task.run() 方法执行任务（执行不成功抛出相应异常）</li>
<li>执行后置方法 afterExecute(task, thrown)（该方法为空方法，由子类实现）后将线程池已完成的任务数+1，并释放锁。</li>
<li>再次进行循环条件判断。</li>
</ol>
<h3 id="流程图：-2"><a href="#流程图：-2" class="headerlink" title="流程图："></a>流程图：</h3><p><img src="/images/img-169.png"></p>
<h3 id="源码详读：-2"><a href="#源码详读：-2" class="headerlink" title="源码详读："></a>源码详读：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// new Worker()是state==-1，此处是调用Worker类的tryRelease()方法，将state置为0，而interruptIfStarted()中只有state&gt;=0才允许调用中断</span></span><br><span class="line">    w.unlock(); </span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 线程退出的原因，true是任务导致，false是线程正常退出</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当前任务和从任务队列中获取的任务都为空，方停止循环</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//上锁可以防止在shutdown()时终止正在运行的worker，而不是应对并发</span></span><br><span class="line">            w.lock(); </span><br><span class="line">             </span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 判断1：确保只有在线程处于stop状态且wt未中断时，wt才会被设置中断标识</span></span><br><span class="line"><span class="comment">             * 条件1：线程池状态&gt;=STOP,即STOP或TERMINATED</span></span><br><span class="line"><span class="comment">             * 条件2：一开始判断线程池状态&lt;STOP，接下来检查发现Thread.interrupted()为true，即线程已经被中断，再次检查线程池状态是否&gt;=STOP（以消除该瞬间shutdown方法生效，使线程池处于STOP或TERMINATED），</span></span><br><span class="line"><span class="comment">             * 条件1与条件2任意满意一个，且wt不是中断状态，则中断wt，否则进入下一步</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt(); <span class="comment">//当前线程调用interrupt()中断</span></span><br><span class="line">             </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行前（空方法，由子类重写实现）</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                 </span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//执行后（空方法，由子类重写实现）</span></span><br><span class="line">                    afterExecute(task, thrown); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>; </span><br><span class="line">                w.completedTasks++; <span class="comment">//完成任务数+1</span></span><br><span class="line">                w.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//处理worker的退出</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="getTask"><a href="#getTask" class="headerlink" title="getTask()"></a>getTask()</h2><p>由函数调用关系图可知，在ThreadPoolExecutor类的实现中，Runnable getTask() 方法是为void runWorker(Worker w)方法服务的，它的作用就是在任务队列（workQueue）中获取 task（Runnable）。</p>
<h3 id="参数说明：-3"><a href="#参数说明：-3" class="headerlink" title="参数说明："></a>参数说明：</h3><p>无参数</p>
<h3 id="执行流程：-3"><a href="#执行流程：-3" class="headerlink" title="执行流程："></a>执行流程：</h3><ol>
<li>将timedOut（上次获取任务是否超时）置为false（首次执行方法，无上次，自然为false），进入一个无限循环</li>
<li>如果线程池为Shutdown状态且任务队列为空（线程池shutdown状态可以处理任务队列中的任务，不再接受新任务，这个是重点）或者线程池为STOP或TERMINATED状态，则意味着线程池不必再获取任务了，当前工作线程数量-1并返回null，否则进入步骤3</li>
<li>如果线程池数量超限制或者时间超限且（任务队列为空或当前线程数&gt;1），则进入步骤4，否则进入步骤5。</li>
<li>移除工作线程，成功则返回null，不成功则进入下轮循环。</li>
<li>尝试用poll() 或者 take()（具体用哪个取决于timed的值）获取任务，如果任务不为空，则返回该任务。如果为空，则将timeOut 置为 true进入下一轮循环。如果获取任务过程发生异常，则将 timeOut置为 false 后进入下一轮循环。</li>
</ol>
<h3 id="流程图：-3"><a href="#流程图：-3" class="headerlink" title="流程图："></a>流程图：</h3><p><img src="/images/img-170.png"></p>
<h3 id="源码详读：-3"><a href="#源码详读：-3" class="headerlink" title="源码详读："></a>源码详读：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最新一次poll是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 条件1：线程池状态SHUTDOWN、STOP、TERMINATED状态</span></span><br><span class="line"><span class="comment">         * 条件2：线程池STOP、TERMINATED状态或workQueue为空</span></span><br><span class="line"><span class="comment">         * 条件1与条件2同时为true，则workerCount-1，并且返回null</span></span><br><span class="line"><span class="comment">         * 注：条件2是考虑到SHUTDOWN状态的线程池不会接受任务，但仍会处理任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下列两个条件满足任意一个，则给当前正在尝试获取任务的工作线程设置阻塞时间限制（超时会被销毁？不太确定这点），否则线程可以一直保持活跃状态</span></span><br><span class="line"><span class="comment">         * 1.allowCoreThreadTimeOut：当前线程是否以keepAliveTime为超时时限等待任务</span></span><br><span class="line"><span class="comment">         * 2.当前线程数量已经超越了核心线程数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 两个条件全部为true，则通过CAS使工作线程数-1，即剔除工作线程</span></span><br><span class="line">        <span class="comment">// 条件1：工作线程数大于maximumPoolSize，或（工作线程阻塞时间受限且上次在任务队列拉取任务超时）</span></span><br><span class="line">        <span class="comment">// 条件2：wc &gt; 1或任务队列为空</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// 移除工作线程，成功则返回null，不成功则进入下轮循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 执行到这里，说明已经经过前面重重校验，开始真正获取task了</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果工作线程阻塞时间受限，则使用poll(),否则使用take()</span></span><br><span class="line">            <span class="comment">// poll()设定阻塞时间，而take()无时间限制，直到拿到结果为止</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="comment">// r不为空，则返回该Runnable</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 没能获取到Runable，则将最近获取任务是否超时设置为true</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 响应中断，进入下一次循环前将最近获取任务超时状态置为false</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit()"></a>processWorkerExit()</h2><p>processWorkerExit(Worker w, boolean completedAbruptly)执行线程退出的方法</p>
<h3 id="参数说明：-4"><a href="#参数说明：-4" class="headerlink" title="参数说明："></a>参数说明：</h3><ul>
<li>Worker w：要结束的工作线程。</li>
<li>boolean completedAbruptly： 是否突然完成（异常导致），如果工作线程因为用户异常死亡，则completedAbruptly参数为 true。</li>
</ul>
<h3 id="执行流程：-4"><a href="#执行流程：-4" class="headerlink" title="执行流程："></a>执行流程：</h3><ol>
<li>如果 completedAbruptly 为 true，即工作线程因为异常突然死亡，则执行工作线程-1操作。</li>
<li>主线程获取锁后，线程池已经完成的任务数追加 w（当前工作线程） 完成的任务数，并从worker的set集合中移除当前worker。</li>
<li>根据线程池状态进行判断是否执行tryTerminate()结束线程池。</li>
<li>是否需要增加工作线程，如果线程池还没有完全终止，仍需要保持一定数量的线程。<ul>
<li>如果当前线程是突然终止的，调用addWorker()创建工作线程</li>
<li>当前线程不是突然终止，但当前工作线程数量小于线程池需要维护的线程数量，则创建工作线程。需要维护的线程数量为corePoolSize（取决于成员变量 allowCoreThreadTimeOut是否为 false）或1。</li>
</ul>
</li>
</ol>
<h3 id="源码详读：-4"><a href="#源码详读：-4" class="headerlink" title="源码详读："></a>源码详读：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs cleanup and bookkeeping for a dying worker. Called</span></span><br><span class="line"><span class="comment"> * only from worker threads. Unless completedAbruptly is set,</span></span><br><span class="line"><span class="comment"> * assumes that workerCount has already been adjusted to account</span></span><br><span class="line"><span class="comment"> * for exit.  This method removes thread from worker set, and</span></span><br><span class="line"><span class="comment"> * possibly terminates the pool or replaces the worker if either</span></span><br><span class="line"><span class="comment"> * it exited due to user task exception or if fewer than</span></span><br><span class="line"><span class="comment"> * corePoolSize workers are running or queue is non-empty but</span></span><br><span class="line"><span class="comment"> * there are no workers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completedAbruptly if the worker died due to user exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.工作线程-1操作</span></span><br><span class="line"><span class="comment">     * 1）如果completedAbruptly 为true，说明工作线程发生异常，那么将正在工作的线程数量-1</span></span><br><span class="line"><span class="comment">     * 2）如果completedAbruptly 为false，说明工作线程无任务可以执行，由getTask()执行worker-1操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.从线程set集合中移除工作线程，该过程需要加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将该worker已完成的任务数追加到线程池已完成的任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// HashSet&lt;Worker&gt;中移除该worker</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 3.根据线程池状态进行判断是否结束线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4.是否需要增加工作线程</span></span><br><span class="line"><span class="comment">     * 线程池状态是running 或 shutdown</span></span><br><span class="line"><span class="comment">     * 如果当前线程是突然终止的，addWorker()</span></span><br><span class="line"><span class="comment">     * 如果当前线程不是突然终止的，但当前线程数量 &lt; 要维护的线程数量，addWorker()</span></span><br><span class="line"><span class="comment">     * 故如果调用线程池shutdown()，直到workQueue为空前，线程池都会维持corePoolSize个线程，然后再逐渐销毁这corePoolSize个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
</search>
