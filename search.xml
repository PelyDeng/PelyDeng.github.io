<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MyBatis 运行时序图</title>
    <url>/2021/08/10/MyBatis-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%8F%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="架构分层"><a href="#架构分层" class="headerlink" title="架构分层"></a>架构分层</h3><p><img src="/images/pasted-4.png" alt="架构分层"></p>
<span id="more"></span>

<h4 id="1-创建会话工厂类"><a href="#1-创建会话工厂类" class="headerlink" title="1. 创建会话工厂类"></a>1. 创建会话工厂类</h4><p><img src="/images/pasted-5.png" alt="创建会话过程"></p>
<h4 id="2-创建会话"><a href="#2-创建会话" class="headerlink" title="2. 创建会话"></a>2. 创建会话</h4><p><img src="/images/pasted-6.png" alt="创建会话过程"></p>
<h4 id="3-获取代理对象"><a href="#3-获取代理对象" class="headerlink" title="3. 获取代理对象"></a>3. 获取代理对象</h4><p><img src="/images/pasted-7.png" alt="获取代理对象过程"></p>
<h4 id="4-调用代理对象方法-执行SQL"><a href="#4-调用代理对象方法-执行SQL" class="headerlink" title="4. 调用代理对象方法, 执行SQL"></a>4. 调用代理对象方法, 执行SQL</h4><p><img src="/images/pasted-8.png" alt="调用代理对象方法, 执行SQL过程"></p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 启动流程简述</title>
    <url>/2021/08/20/Spring-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>beanDefinitionMap  -&gt; 用来存储 BeanDefinition(Bean 的配置信息)<br>factoryBeanObjectCache  -&gt;  用来存储原生 Bean 对象的Map, 指反射创建出的实际对象<br>factoryBeanInstanceCache  -&gt;  用来存储 BeanWrapper 的Map, 指原生 Bean 的包装类  </p>
</blockquote>
<h3 id="Spring-启动流程简述"><a href="#Spring-启动流程简述" class="headerlink" title="Spring 启动流程简述"></a>Spring 启动流程简述</h3><h4 id="一-配置阶段"><a href="#一-配置阶段" class="headerlink" title="一. 配置阶段"></a>一. 配置阶段</h4><ul>
<li>web.xml<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DispatcherServlet 路径</span><br><span class="line">设定 init-param ( contextConfigLocation = classPath:application.xml )</span><br><span class="line">设定 url-pattern ( /* )</span><br><span class="line">配置 Annotation 等</span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>

<ul>
<li>appication.xml<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置 包扫描路径、Bean定义、视图解析配置等......</span><br></pre></td></tr></table></figure></li>
<li>……</li>
</ul>
<h4 id="二-初始化阶段"><a href="#二-初始化阶段" class="headerlink" title="二. 初始化阶段"></a>二. 初始化阶段</h4><ul>
<li><p>Servlet.init()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring 是 servlet 编程模型, 容器启动时会调用 servlet 的 init() 方法, </span><br><span class="line">在该方法中会读取配置进行 IoC 容器及 MVC 组件的初始化.</span><br></pre></td></tr></table></figure></li>
<li><p>IoC 部分 (定位、加载、注册) </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化 IoC 容器</span><br><span class="line"> 1. 通过 web.xml 的配置定位 application .xml配置文件. </span><br><span class="line"> 2. 使用 BeanDefinitionReader 读取配置文件, 扫描类并封装成 BeanDefinition</span><br><span class="line"> 3. 创建 BeanFatory, 将 *beanDefinition 注册到 DefalutListableBeanFactory 的 beanDefinitionMap 中</span><br></pre></td></tr></table></figure></li>
<li><p>DI 、 AOP 部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. 初始化非延迟加载的 bean</span><br><span class="line">0). 标记 bean 为创建中      </span><br><span class="line">1). 通过反射 new 出 bean 对象, 封装成 BeanWrapper 对象      </span><br><span class="line">2). 如果 bean 为单例且支持循环依赖则生成三级缓存 singletonFactories, 可提前暴露 bean      </span><br><span class="line">3). 填充bean属性，解决属性依赖      </span><br><span class="line">4). 初始化bean的各个Aware接口(各个Aware接口能让bean获取到部分属性: ApplicationContextAware-能获取到ApplicationContex; BeanFactoryAware 能获取到 BeanFactory) 并执行各类 bean 的后处理器, 执行初始化方法, 如果有 AOP 配置需要生成 AOP 代理对象 </span><br><span class="line">5). 如果存在循环依赖，解决之 – 这里有点问题，这一步是如果之前解决了aop循环依赖，则缓存中放置了提前生成的代理对象，然后使用原始bean继续执行初始化，所以需要再返回最终bean前，把原始bean置换为代理对象返回。      </span><br><span class="line">6). 此时 bean 已经可以使用, 将 bean 放入一级缓存 singletonObjects , 移除创建中标记以及二三级缓存</span><br></pre></td></tr></table></figure></li>
<li><p>MVC 部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. 初始化 MVC 九大组件</span><br><span class="line">// 1). 初始化文件上传解析器</span><br><span class="line">initMultipartResolver(context);</span><br><span class="line">// 2). 初始化本地语言环境</span><br><span class="line">initLocaleResolver(context);</span><br><span class="line">// 3). 初始化模板处理器</span><br><span class="line">initThemeResolver(context);</span><br><span class="line">// 4). 初始化 HandlerMapping 组件</span><br><span class="line">initHandlerMappings(context);</span><br><span class="line">// 5). 初始化参数适配器</span><br><span class="line">initHandlerAdapters(context);</span><br><span class="line">// 6). 初始化异常拦截器</span><br><span class="line">initHandlerExceptionResolvers(context);</span><br><span class="line">// 7). 初始化视图预处理器</span><br><span class="line">initRequestToViewNameTranslator(context);</span><br><span class="line">// 8). 初始化视图解析器</span><br><span class="line">initViewResolvers(context);</span><br><span class="line">// 9). 初始化 FlashMap 管理器</span><br><span class="line">( 为了解决请求转发和重定向过程中参数的丢失问题: redirect-&gt;重定向, request 参数会丢失 ; forward-&gt;转发, 自动将 request 参数系诶带到下一个请求 )</span><br><span class="line">initFlashMapManager(context);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="三-运行阶段"><a href="#三-运行阶段" class="headerlink" title="三. 运行阶段"></a>三. 运行阶段</h4><blockquote>
<ol>
<li>从页面点击按钮或者 url 访问资源请求会先到 DispatcherServlet 的 doDispatch() 方法, 该方法会从 HandlerMapping 中通过 url 去匹配对应的控制器及方法  </li>
<li>通过参数解析器解析参数并反射执行方法, 返回一个 ModelAndView  </li>
<li>通过视图解析器解析 ModelAndView, 决定返回页面或者输出数据  </li>
<li>前端根据对应结果来展示</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 基础认知与技术架构</title>
    <url>/2021/08/19/Spring-%E5%9F%BA%E7%A1%80%E8%AE%A4%E7%9F%A5%E4%B8%8E%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><blockquote>
<p>Spring 是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。 </p>
</blockquote>
<blockquote>
<p>Spring最根本的使命是解决企业级应用开发的复杂性，即简化Java开发。</p>
</blockquote>
<h3 id="1-Spring-简化开发的四个基本策略"><a href="#1-Spring-简化开发的四个基本策略" class="headerlink" title="1. Spring 简化开发的四个基本策略"></a>1. Spring 简化开发的四个基本策略</h3><blockquote>
<ol>
<li>基于POJO 的轻量级和最小侵入性编程.</li>
<li>通过依赖注入和面向接口松耦合.</li>
<li>基于切面和惯性进行声明式编程.</li>
<li>通过切面和模板减少样版式代码.</li>
</ol>
</blockquote>
<span id="more"></span>

<h3 id="2-Spring-中的编程思想"><a href="#2-Spring-中的编程思想" class="headerlink" title="2. Spring 中的编程思想"></a>2. Spring 中的编程思想</h3><table>
<thead>
<tr>
<th>Spring思想</th>
<th>应用场景 (特点)</th>
<th>一句话归纳</th>
</tr>
</thead>
<tbody><tr>
<td><strong>OOP</strong></td>
<td>Object Oriented Programming (面向对象编程) 用程序归纳总结生活中一切事物</td>
<td>封装、继承、多态.</td>
</tr>
<tr>
<td><strong>BOP</strong></td>
<td>Bean Oriented Programming (面向Bean编程) 面向Bean (普通Java类) 设计程序, 解放程序员.</td>
<td>一切从Bean开始.</td>
</tr>
<tr>
<td><strong>AOP</strong></td>
<td>Aspect Oriented Programming (面向切面编程) 找出多个类中有一定规律的代码, 开发时拆开, 应运行时再合并. 面向切面编程, 及面向规则编程.</td>
<td>解耦, 专人做专事.</td>
</tr>
<tr>
<td><strong>IoC</strong></td>
<td>Inversion of Control (控制反转) 将new对象的动作交给Spring管理, 并由Spring保存已创建的对象 (IOC容器).</td>
<td>转交控制权(即控制权反转).</td>
</tr>
<tr>
<td><strong>DI/D</strong>L</td>
<td>Dependency Injection (依赖注入) 或者Dependency Lookup (依赖查找) , Spring不仅保存自己创建的对象, 而且保存对象与对象之间的关系. 注入即赋值, 主要三种方式 — 构造方法、set方法、直接赋值.</td>
<td>自动赋值.</td>
</tr>
</tbody></table>
<h3 id="3-Spring-注解编程演化"><a href="#3-Spring-注解编程演化" class="headerlink" title="3. Spring 注解编程演化"></a>3. Spring 注解编程演化</h3><p> V1.X | V2.0 | V2.5 | V3.X | V4.X | V5.X<br>—|—|—|—|—|—|—<br> <strong>注解驱动启蒙时代</strong> | <strong>注解驱动过渡时代</strong> | <strong>引入新的骨架式Annotation</strong> | <strong>注解驱动黄金时代</strong> | <strong>注解驱动完善时代</strong> | <strong>注解驱动成熟时代</strong></p>
<h3 id="4-Spring-模块结构"><a href="#4-Spring-模块结构" class="headerlink" title="4. Spring 模块结构"></a>4. Spring 模块结构</h3><blockquote>
<p>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access/Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中。 </p>
</blockquote>
<p><img src="/images/img-13.png" alt="Spring 模块结构"></p>
<h3 id="5-Spring-系统架构模块功能介绍"><a href="#5-Spring-系统架构模块功能介绍" class="headerlink" title="5. Spring 系统架构模块功能介绍"></a>5. Spring 系统架构模块功能介绍</h3><h4 id="Spring-核心模块"><a href="#Spring-核心模块" class="headerlink" title="Spring 核心模块"></a>Spring 核心模块</h4><table>
<thead>
<tr>
<th>模块名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-core</strong></td>
<td>IoC控制反转与DI依赖注入的最基本实现</td>
</tr>
<tr>
<td><strong>spring-beans</strong></td>
<td>Bean工厂与Bean的装配</td>
</tr>
<tr>
<td><strong>spring-context</strong></td>
<td>定义基础的Spring的Context上下文即IoC容器</td>
</tr>
<tr>
<td><strong>spring-context-support</strong></td>
<td>对Spring IoC的扩展支持, 以及IoC子容器</td>
</tr>
<tr>
<td><strong>spring-context-indexer</strong></td>
<td>Spring的类管理组件和Classpath扫描</td>
</tr>
<tr>
<td><strong>spring-expression</strong></td>
<td>Spring表达式语言</td>
</tr>
</tbody></table>
<hr>
<h5 id="Spring-面向切面编程模块"><a href="#Spring-面向切面编程模块" class="headerlink" title="Spring 面向切面编程模块"></a>Spring 面向切面编程模块</h5><table>
<thead>
<tr>
<th>模块名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-aop</strong></td>
<td>面向切面编程的引用模块, 整合Asm, CGLib、JDKProxy</td>
</tr>
<tr>
<td><strong>spring-aspects</strong></td>
<td>继承AspectJ, AOP应用框架</td>
</tr>
<tr>
<td><strong>spring-instrument</strong></td>
<td>动态Class Loading模块</td>
</tr>
</tbody></table>
<hr>
<h5 id="Spring-数据访问与继承模块"><a href="#Spring-数据访问与继承模块" class="headerlink" title="Spring 数据访问与继承模块"></a>Spring 数据访问与继承模块</h5><table>
<thead>
<tr>
<th>模块名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-jdbc</strong></td>
<td>Spring 提供的JDBC抽象框架的组要实现模块, 用于简化 Spring JDBC 操作</td>
</tr>
<tr>
<td><strong>spring-tx</strong></td>
<td>Spring JDBC 事务控制实现模块</td>
</tr>
<tr>
<td><strong>spring-orm</strong></td>
<td>主要继承 Hibernate, Java Persitence API (JPA) 和 Java Data Object (JDO)</td>
</tr>
<tr>
<td><strong>spring-oxm</strong></td>
<td>将Java对象映射成XML数据, 或者将XML数据映射成Java对象</td>
</tr>
<tr>
<td><strong>spring-jms</strong></td>
<td>Java Messaging Service 能够发送和接收信息</td>
</tr>
</tbody></table>
<hr>
<h5 id="Spring-Web-模块"><a href="#Spring-Web-模块" class="headerlink" title="Spring Web 模块"></a>Spring Web 模块</h5><table>
<thead>
<tr>
<th>模块名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-web</strong></td>
<td>提供了最基础Web支持, 主要建立于核心容器之上, 通过 Servlet 或者 Listeners 来初始化 IoC 容器</td>
</tr>
<tr>
<td><strong>spring-webmvc</strong></td>
<td>实现了 Spring-MVC (model-view-controller) 的 Web 应用</td>
</tr>
<tr>
<td><strong>spring-websokect</strong></td>
<td>主要是与 Web 前端的全双工通讯的协议</td>
</tr>
<tr>
<td><strong>spring-webflux</strong></td>
<td>一个新的非阻塞函数式 Reactive Web 框架, 可以用来建立异步的. 非阻塞, 事件驱动的服务</td>
</tr>
</tbody></table>
<hr>
<h5 id="Spring-通信报文-模块"><a href="#Spring-通信报文-模块" class="headerlink" title="Spring 通信报文 模块"></a>Spring 通信报文 模块</h5><table>
<thead>
<tr>
<th>模块名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-messaging</strong></td>
<td>从 Spring4 开始新加入的一个模块, 主要职责是为 Spring 框架继承一些基础的报文传输应用</td>
</tr>
</tbody></table>
<hr>
<h5 id="Spring-集成测试-模块"><a href="#Spring-集成测试-模块" class="headerlink" title="Spring 集成测试 模块"></a>Spring 集成测试 模块</h5><table>
<thead>
<tr>
<th>模块名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-test</strong></td>
<td>主要为测试提供支持的</td>
</tr>
</tbody></table>
<hr>
<h5 id="Spring-集成兼容-模块"><a href="#Spring-集成兼容-模块" class="headerlink" title="Spring 集成兼容 模块"></a>Spring 集成兼容 模块</h5><table>
<thead>
<tr>
<th>模块名称</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>spring-framwork-bom</strong></td>
<td>Bill of Materials. 解除 Spring 的不同模块依赖版本不同问题</td>
</tr>
</tbody></table>
<h3 id="6-Spring-模块之依赖关系图"><a href="#6-Spring-模块之依赖关系图" class="headerlink" title="6. Spring 模块之依赖关系图"></a>6. Spring 模块之依赖关系图</h3><p><img src="/images/img-14.png" alt="模块依赖关系"></p>
<h3 id="7-版本命名规则"><a href="#7-版本命名规则" class="headerlink" title="7. 版本命名规则"></a>7. 版本命名规则</h3><h4 id="Spring-版本命名规则"><a href="#Spring-版本命名规则" class="headerlink" title="Spring 版本命名规则"></a>Spring 版本命名规则</h4><blockquote>
<p><img src="/images/img-15.png" alt="Spring 版本命名规则"></p>
</blockquote>
<h4 id="其他常见软件版本命名规则"><a href="#其他常见软件版本命名规则" class="headerlink" title="其他常见软件版本命名规则"></a>其他常见软件版本命名规则</h4><blockquote>
<p><img src="/images/img-16.png" alt="upload successful"></p>
</blockquote>
<h4 id="语义化版本命名通用规则"><a href="#语义化版本命名通用规则" class="headerlink" title="语义化版本命名通用规则"></a>语义化版本命名通用规则</h4><blockquote>
<p><img src="/images/img-17.png" alt="upload successful"></p>
</blockquote>
<h4 id="商业软件中常见的修饰词"><a href="#商业软件中常见的修饰词" class="headerlink" title="商业软件中常见的修饰词"></a>商业软件中常见的修饰词</h4><blockquote>
<p><img src="/images/img-18.png" alt="upload successful"></p>
</blockquote>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/08/06/newpapername/</url>
    <content><![CDATA[<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</div>]]></content>
  </entry>
  <entry>
    <title>外网访问家庭网络小记</title>
    <url>/2021/08/14/%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%E5%AE%B6%E5%BA%AD%E7%BD%91%E7%BB%9C%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="记录一次家庭内网使用DDNS让外网访问-同时动态更新域名"><a href="#记录一次家庭内网使用DDNS让外网访问-同时动态更新域名" class="headerlink" title="记录一次家庭内网使用DDNS让外网访问, 同时动态更新域名"></a>记录一次家庭内网使用DDNS让外网访问, 同时动态更新域名</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此篇文章献给&#x27;懒人&#x27;同学~  </span><br><span class="line">相信很多同学在自己家里学习啥的搞些小网站小程序, 比如部署一些在线看视频丶个人网盘丶个人博客等的网站, </span><br><span class="line">但是在公司时想访问记录或查询一些资料, 但是又因为访问不了家庭网络而烦躁...  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此分享能使用任意外网<strong>访问家庭内网</strong>, 同时<strong>动态更新域名</strong>的方法.<br><em><strong>当然在此之前我使用过花生壳、公云等一些软件, 他也可以让你从外网访问家庭内网, 但是别的不说, 他限速而且收费呀… 自己搭建可以全速使用家里的带宽</strong></em><br>步骤如下: </p>
</blockquote>
<h2 id="一-外网访问"><a href="#一-外网访问" class="headerlink" title="一. 外网访问"></a>一. 外网访问</h2><span id="more"></span>
<h3 id="1-申请公网IP"><a href="#1-申请公网IP" class="headerlink" title="1. 申请公网IP"></a>1. 申请公网IP</h3><blockquote>
<p>想访问家庭网络必定需要找家里开网络的运营商, 让他们给开公网IP, 我家里使用的是电信宽带, 电话直接打 10000 号人工服务让他们帮忙开通, 理由嘛很简单( 找个借口说家里安装监控就给你开了 ) , 电信现在默认都是给的私网IP. </p>
</blockquote>
<h3 id="2-光猫改为桥接模式"><a href="#2-光猫改为桥接模式" class="headerlink" title="2. 光猫改为桥接模式"></a>2. 光猫改为桥接模式</h3><blockquote>
<p>申请完公网IP先别急着挂, 还需要让他们把宽带网络改成桥接模式, 后面我们路由器使用拨号上网</p>
</blockquote>
<h3 id="3-查询宽带账号和密码"><a href="#3-查询宽带账号和密码" class="headerlink" title="3. 查询宽带账号和密码"></a>3. 查询宽带账号和密码</h3><blockquote>
<p>由于路由器现在是使用拨号上网, 所以还需要找他运营商拿到宽带的账户和密码, 这些都是必要条件</p>
</blockquote>
<h3 id="4-设备网线连接"><a href="#4-设备网线连接" class="headerlink" title="4. 设备网线连接"></a>4. 设备网线连接</h3><blockquote>
<p>我们使用网线连接 <strong>光猫的网口</strong> 和 <strong>路由器WAN口</strong>, 主机的网线则联通路由器的LAN口, ( WAN口是连接外部网络, LAN口是连接内部网络, 家里的电脑网线都可以用LAN接口连接, 并且<strong>此时我们电脑是没有网络的</strong> )</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">光猫网口  --&gt; 路由器WAN口</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">路由器LAN口 --&gt; 电脑网口</span><br></pre></td></tr></table></figure>

<h3 id="5-设置路由器"><a href="#5-设置路由器" class="headerlink" title="5. 设置路由器"></a>5. 设置路由器</h3><blockquote>
<p>此时已经具备的条件:<br><strong>公网ip, 宽带改为桥接模式, 宽带账号和密码, 设备网线正确连接</strong>  </p>
</blockquote>
<blockquote>
<ul>
<li>开始设置路由器:  </li>
</ul>
<p><strong>我的路由器设备使用的小米路由器, 暂以小米路由器为例</strong>, 路由器网关是 192.168.31.1 , 自己的路由器网关自己搜一下, 然后输入路由器用户名密码</p>
</blockquote>
<blockquote>
<ul>
<li>上网设置<br><img src="/images/img-1.png" alt="上网设置PPPoE拨号"><br>如图, 上网方式选择<strong>PPPOE手动拨号</strong>, 然后输入宽带的账号和密码即可  <br>拨号成功应该就可以上网了~~~</li>
</ul>
</blockquote>
<h3 id="6-检查IP地址"><a href="#6-检查IP地址" class="headerlink" title="6. 检查IP地址"></a>6. 检查IP地址</h3><blockquote>
<p>百度查询自己本机的IP是否与路由器拨号成功获得的IP地址相同.<br><strong>++如果不同, 那一般都是私网ip 没有申请公网ip的.++</strong><br><img src="/images/img-2.png" alt="检查ip是否一致"></p>
</blockquote>
<h3 id="7-路由转发"><a href="#7-路由转发" class="headerlink" title="7. 路由转发"></a>7. 路由转发</h3><blockquote>
<p>一般路由器都拥有路由转发功能, 可以自己配置转发规则.  <br><img src="/images/img-3.png" alt="配置路由转发规则"></p>
</blockquote>
<blockquote>
<ul>
<li>端口转发: 映射端口, 访问外网 ip:端口, 会直接映射到内网的ip:端口<br>如: **访问外网地址 22.135.173.55:8848, 会被转发到内网 192.168.31.26:8000 **<br><img src="/images/img-4.png" alt="端口映射规则"></li>
</ul>
</blockquote>
<h3 id="8-测试"><a href="#8-测试" class="headerlink" title="8. 测试"></a>8. 测试</h3><blockquote>
<ul>
<li>我本地电脑随便开启一个服务<br><img src="/images/img-5.png"><br>部署成功, 内网ip:port  <strong>192.168.31.26:8401</strong><br><img src="/images/img-6.png" alt="启动成功啦, 内网IP访问"></li>
<li>接着使用外网ip访问, <strong>注意自己映射的端口哦</strong><br><img src="/images/img-7.png" alt="外网IP访问"><br>访问成功~~</li>
</ul>
</blockquote>
<h2 id="二-设置动态更新域名"><a href="#二-设置动态更新域名" class="headerlink" title="二. 设置动态更新域名"></a>二. 设置动态更新域名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于电信给的公网IP是动态IP, 每次关闭重启光猫都会更换公网IP地址, 所以这也是个很头疼的事情... </span><br><span class="line">个人方案解决了该情况</span><br></pre></td></tr></table></figure>
<h3 id="1-准备域名-本方案只支持腾讯云域名-对接腾讯云API"><a href="#1-准备域名-本方案只支持腾讯云域名-对接腾讯云API" class="headerlink" title="1. 准备域名 ( 本方案只支持腾讯云域名, 对接腾讯云API )"></a>1. 准备域名 ( 本方案只支持腾讯云域名, 对接腾讯云API )</h3><blockquote>
<p>我使用的方法, 使用Python写了一个脚本, 动态去更新域名, 需要准备一个腾讯云的域名。<br>提供购买链接 <a href="https://buy.cloud.tencent.com/domain?from=console">https://buy.cloud.tencent.com/domain?from=console</a></p>
</blockquote>
<h3 id="2-开通腾讯云-API-密钥"><a href="#2-开通腾讯云-API-密钥" class="headerlink" title="2. 开通腾讯云 API 密钥"></a>2. 开通腾讯云 API 密钥</h3><blockquote>
<p>API 密钥代表你的账号身份和所拥有的权限，使用腾讯云 API 可以操作您名下的所有腾讯云资源。<br>给上链接 <a href="https://console.cloud.tencent.com/cam/capi">https://console.cloud.tencent.com/cam/capi</a></p>
<ul>
<li>开通完后新建密钥( 单机即可, 自动创建 ):<br><img src="/images/img-8.png" alt="新建腾讯云 API 密钥"></li>
</ul>
</blockquote>
<h3 id="3-安装Python3"><a href="#3-安装Python3" class="headerlink" title="3. 安装Python3"></a>3. 安装Python3</h3><blockquote>
<p>由于使用的 Python 写的脚本, 需要环境拥有Python, 版本 3 及以上.<br>安装方法参考 <a href="https://www.cnblogs.com/weven/p/7252917.html">https://www.cnblogs.com/weven/p/7252917.html</a><br>安装完成后查看Python版本:<br><img src="/images/img-9.png" alt="查看Python版本"></p>
</blockquote>
<h3 id="4-献上脚本"><a href="#4-献上脚本" class="headerlink" title="4. 献上脚本"></a>4. 献上脚本</h3><blockquote>
<p><img src="/images/img-10.png" alt="upload successful"></p>
<ul>
<li>复制以下代码 保存为  <strong>xxx.py</strong> 格式就行</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">VERSION = <span class="number">1</span></span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha1</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DDnsHelper</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, mid=<span class="number">0</span>, params=&#123;&#125;</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">excute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">import</span> requests</span><br><span class="line">        SecretId = <span class="string">&#x27;*需要填写*&#x27;</span></span><br><span class="line">        SecretKey = <span class="string">&#x27;*需要填写*&#x27;</span></span><br><span class="line">        runningPause = <span class="number">20</span></span><br><span class="line">        domainName = <span class="string">&#x27;pelyhome.cc&#x27;</span> <span class="comment"># *需要填写你自己的域名*</span></span><br><span class="line">        ddnsDomains = [</span><br><span class="line">            &#123;</span><br><span class="line">            	  <span class="comment"># *需要填写你自己的域名*</span></span><br><span class="line">                <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;@.pelyhome.cc&#x27;</span>, </span><br><span class="line">                <span class="string">&#x27;value&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment"># </span></span><br><span class="line">                <span class="string">&#x27;always&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">                <span class="comment"># DNS生存时间 </span></span><br><span class="line">                <span class="string">&#x27;ttl&#x27;</span>: <span class="number">600</span>, </span><br><span class="line">                <span class="comment"># 主机记录, 即域名前缀</span></span><br><span class="line">                <span class="string">&#x27;subDomain&#x27;</span>: <span class="string">&#x27;@&#x27;</span>, </span><br><span class="line">                <span class="string">&#x27;recordId&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                <span class="comment"># 记录类型</span></span><br><span class="line">                <span class="string">&#x27;recordType&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, </span><br><span class="line">                <span class="comment"># 线路类型, 指定细分解析线路</span></span><br><span class="line">                <span class="string">&#x27;recordLine&#x27;</span>: <span class="string">&#x27;默认&#x27;</span>, </span><br><span class="line">                <span class="string">&#x27;description&#x27;</span>: <span class="string">&#x27;本地提供api服务的地址&#x27;</span>,</span><br><span class="line">                <span class="comment"># 查看本地域名的接口, 这是自己写的接口, 仅仅返回一个纯粹的本地外网IP地址</span></span><br><span class="line">                <span class="string">&#x27;localDomain&#x27;</span>: <span class="string">&#x27;https://www.hosix.cn/ip&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;localValue&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">tenXunDDNS_Helper</span>():</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">                self.running = <span class="literal">True</span></span><br><span class="line">                self.action = <span class="string">&quot;&quot;</span></span><br><span class="line">                self.secretId = SecretId</span><br><span class="line">                self.nonce = <span class="number">38651</span></span><br><span class="line">                self.region = <span class="string">&#x27;ap-guangzhou&#x27;</span></span><br><span class="line">                self.secretKey = SecretKey</span><br><span class="line">                self.version = <span class="string">&#x27;2017-03-12&#x27;</span></span><br><span class="line">                self.domain = domainName</span><br><span class="line">                self.url = <span class="string">&#x27;cns.api.qcloud.com/v2/index.php&#x27;</span></span><br><span class="line">                self.httpType = <span class="string">&#x27;https://&#x27;</span></span><br><span class="line">                self.endpoint = self.httpType + self.url</span><br><span class="line">                self.ddnsDomain = ddnsDomains</span><br><span class="line">                self.runningPause = runningPause</span><br><span class="line">                self.remoteRecords = []</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">getServerIp</span>(<span class="params">self</span>):</span></span><br><span class="line">                timeStamp = <span class="built_in">int</span>(time.time())</span><br><span class="line">                params = &#123;&#125;</span><br><span class="line">                params[<span class="string">&#x27;Action&#x27;</span>] = <span class="string">&#x27;RecordList&#x27;</span></span><br><span class="line">                params[<span class="string">&#x27;domain&#x27;</span>] = self.domain</span><br><span class="line">                params[<span class="string">&#x27;Nonce&#x27;</span>] = self.nonce</span><br><span class="line">                params[<span class="string">&#x27;SecretId&#x27;</span>] = self.secretId</span><br><span class="line">                params[<span class="string">&#x27;Timestamp&#x27;</span>] = timeStamp</span><br><span class="line">                s = self.get_string_to_sign(<span class="string">&quot;GET&quot;</span>, self.url, params)</span><br><span class="line">                Signature = self.sign_str(self.secretKey, s, sha1)</span><br><span class="line">                params[<span class="string">&#x27;Signature&#x27;</span>] = Signature</span><br><span class="line">                response = requests.get(self.endpoint, params=params)</span><br><span class="line">                result = json.loads(response.text)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">int</span>(result[<span class="string">&#x27;code&#x27;</span>]) != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">&#x27;获取域名失败&#x27;</span> + <span class="string">&#x27;:&#x27;</span> + <span class="built_in">str</span>(result[<span class="string">&#x27;code&#x27;</span>]) + <span class="string">&#x27;:&#x27;</span> + result[<span class="string">&#x27;message&#x27;</span>])</span><br><span class="line">                data = result[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line"></span><br><span class="line">                self.remoteRecords = data[<span class="string">&#x27;records&#x27;</span>]</span><br><span class="line">                <span class="comment"># print(self.remoteRecords)</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">postServerIp</span>(<span class="params">self, domain</span>):</span></span><br><span class="line">                timeStamp = <span class="built_in">int</span>(time.time())</span><br><span class="line">                params = &#123;&#125;</span><br><span class="line">                params[<span class="string">&#x27;Action&#x27;</span>] = <span class="string">&#x27;RecordCreate&#x27;</span></span><br><span class="line">                params[<span class="string">&#x27;domain&#x27;</span>] = self.domain</span><br><span class="line">                params[<span class="string">&#x27;Nonce&#x27;</span>] = self.nonce</span><br><span class="line">                params[<span class="string">&#x27;SecretId&#x27;</span>] = self.secretId</span><br><span class="line">                params[<span class="string">&#x27;Timestamp&#x27;</span>] = timeStamp</span><br><span class="line">                params[<span class="string">&#x27;subDomain&#x27;</span>] = domain[<span class="string">&#x27;subDomain&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;recordType&#x27;</span>] = domain[<span class="string">&#x27;recordType&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;recordLine&#x27;</span>] = domain[<span class="string">&#x27;recordLine&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;value&#x27;</span>] = domain[<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;ttl&#x27;</span>] = domain[<span class="string">&#x27;ttl&#x27;</span>]</span><br><span class="line">                s = self.get_string_to_sign(<span class="string">&quot;GET&quot;</span>, self.url, params)</span><br><span class="line">                Signature = self.sign_str(self.secretKey, s, sha1)</span><br><span class="line">                params[<span class="string">&#x27;Signature&#x27;</span>] = Signature</span><br><span class="line">                response = requests.get(self.endpoint, params=params)</span><br><span class="line">                result = json.loads(response.text)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">int</span>(result[<span class="string">&#x27;code&#x27;</span>]) != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">&#x27;添加域名失败&#x27;</span> + <span class="string">&#x27;:&#x27;</span> + <span class="built_in">str</span>(result[<span class="string">&#x27;code&#x27;</span>]) + <span class="string">&#x27;:&#x27;</span> + result[<span class="string">&#x27;message&#x27;</span>])</span><br><span class="line">                data = result[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;添加域名成功ip:%s,本地ip:%s,域名:%s&#x27;</span> % (domain[<span class="string">&#x27;value&#x27;</span>], domain[<span class="string">&#x27;localValue&#x27;</span>], domain[<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">updateServerIp</span>(<span class="params">self, domain</span>):</span></span><br><span class="line">                timeStamp = <span class="built_in">int</span>(time.time())</span><br><span class="line">                params = &#123;&#125;</span><br><span class="line">                params[<span class="string">&#x27;Action&#x27;</span>] = <span class="string">&#x27;RecordModify&#x27;</span></span><br><span class="line">                params[<span class="string">&#x27;domain&#x27;</span>] = self.domain</span><br><span class="line">                params[<span class="string">&#x27;Nonce&#x27;</span>] = self.nonce</span><br><span class="line">                params[<span class="string">&#x27;SecretId&#x27;</span>] = self.secretId</span><br><span class="line">                params[<span class="string">&#x27;Timestamp&#x27;</span>] = timeStamp</span><br><span class="line">                params[<span class="string">&#x27;subDomain&#x27;</span>] = domain[<span class="string">&#x27;subDomain&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;recordId&#x27;</span>] = domain[<span class="string">&#x27;recordId&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;recordType&#x27;</span>] = domain[<span class="string">&#x27;recordType&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;recordLine&#x27;</span>] = domain[<span class="string">&#x27;recordLine&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;value&#x27;</span>] = domain[<span class="string">&#x27;localValue&#x27;</span>]</span><br><span class="line">                params[<span class="string">&#x27;ttl&#x27;</span>] = domain[<span class="string">&#x27;ttl&#x27;</span>]</span><br><span class="line">                s = self.get_string_to_sign(<span class="string">&quot;GET&quot;</span>, self.url, params)</span><br><span class="line">                Signature = self.sign_str(self.secretKey, s, sha1)</span><br><span class="line">                params[<span class="string">&#x27;Signature&#x27;</span>] = Signature</span><br><span class="line">                response = requests.get(self.endpoint, params=params)</span><br><span class="line">                result = json.loads(response.text)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">int</span>(result[<span class="string">&#x27;code&#x27;</span>]) != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">&#x27;更新域名失败&#x27;</span> + <span class="string">&#x27;:&#x27;</span> + <span class="built_in">str</span>(result[<span class="string">&#x27;code&#x27;</span>]) + <span class="string">&#x27;:&#x27;</span> + result[<span class="string">&#x27;message&#x27;</span>])</span><br><span class="line">                data = result[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;更新域名成功源ip:%s,本地ip:%s,域名:%s&#x27;</span> % (domain[<span class="string">&#x27;value&#x27;</span>], domain[<span class="string">&#x27;localValue&#x27;</span>], domain[<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">deleteServerIp</span>(<span class="params">self</span>):</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">getLocalDomain</span>(<span class="params">self, domain</span>):</span></span><br><span class="line">                res = requests.get(domain[<span class="string">&#x27;localDomain&#x27;</span>])</span><br><span class="line">                ip = res.content.decode(<span class="string">&quot;utf-8&quot;</span>).strip()</span><br><span class="line">                <span class="keyword">return</span> ip</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">clearDnsRecord</span>(<span class="params">self</span>):</span></span><br><span class="line">                <span class="keyword">for</span> domain <span class="keyword">in</span> self.ddnsDomain:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> domain[<span class="string">&#x27;always&#x27;</span>]:</span><br><span class="line">                        domain[<span class="string">&#x27;value&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                        domain[<span class="string">&#x27;localValue&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">                self.getServerIp()</span><br><span class="line">                <span class="keyword">for</span> domain <span class="keyword">in</span> self.ddnsDomain:</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">not</span> domain[<span class="string">&#x27;always&#x27;</span>]):</span><br><span class="line">                        <span class="comment"># 获取本地ip</span></span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            domain[<span class="string">&#x27;localValue&#x27;</span>] = self.getLocalDomain(domain)</span><br><span class="line">                        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">&quot;获取本地ip失败 不更新:%s,本地ip:%s,域名:%s&quot;</span> % (</span><br><span class="line">                            domain[<span class="string">&#x27;value&#x27;</span>], domain[<span class="string">&#x27;localValue&#x27;</span>], domain[<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    flag = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">for</span> remoteDomain <span class="keyword">in</span> self.remoteRecords:</span><br><span class="line">                        <span class="keyword">if</span> (domain[<span class="string">&#x27;subDomain&#x27;</span>] == remoteDomain[<span class="string">&#x27;name&#x27;</span>]):</span><br><span class="line">                            domain[<span class="string">&#x27;recordId&#x27;</span>] = remoteDomain[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">                            domain[<span class="string">&#x27;value&#x27;</span>] = remoteDomain[<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">                            flag = <span class="literal">True</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> flag:</span><br><span class="line">                        <span class="keyword">if</span> (domain[<span class="string">&#x27;value&#x27;</span>] == domain[<span class="string">&#x27;localValue&#x27;</span>]):</span><br><span class="line">                            <span class="keyword">pass</span></span><br><span class="line">                            <span class="comment"># print(&quot;无需更新ip:%s,本地ip:%s,域名:%s&quot; % (domain[&#x27;value&#x27;],domain[&#x27;localValue&#x27;],domain[&#x27;name&#x27;]))</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            self.updateServerIp(domain)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        domain[<span class="string">&#x27;value&#x27;</span>] = domain[<span class="string">&#x27;localValue&#x27;</span>]</span><br><span class="line">                        self.postServerIp(domain)</span><br><span class="line">                self.clearDnsRecord()</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">                start_time = <span class="built_in">int</span>(time.time())</span><br><span class="line">                <span class="keyword">while</span> self.running:</span><br><span class="line">                    next_time = <span class="built_in">int</span>(time.time()) + self.runningPause</span><br><span class="line">                    <span class="keyword">if</span> (next_time - start_time) &gt; self.runningPause:</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            self.run()</span><br><span class="line">                        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                            <span class="built_in">print</span>(e.__str__())</span><br><span class="line">                        start_time = start_time + self.runningPause</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        time.sleep(self.runningPause / <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">get_string_to_sign</span>(<span class="params">self, method, endpoint, params</span>):</span></span><br><span class="line">                s = method + endpoint + <span class="string">&quot;?&quot;</span></span><br><span class="line">                query_str = <span class="string">&quot;&amp;&quot;</span>.join(<span class="string">&quot;%s=%s&quot;</span> % (k, params[k]) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">sorted</span>(params))</span><br><span class="line">                <span class="comment"># print(s + query_str)</span></span><br><span class="line">                <span class="keyword">return</span> s + query_str</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">sign_str</span>(<span class="params">self, key, s, method</span>):</span></span><br><span class="line">                hmac_str = hmac.new(key.encode(<span class="string">&quot;utf8&quot;</span>), s.encode(<span class="string">&quot;utf8&quot;</span>), method).digest()</span><br><span class="line">                <span class="keyword">return</span> base64.b64encode(hmac_str)</span><br><span class="line"></span><br><span class="line">        t1 = tenXunDDNS_Helper()</span><br><span class="line">        t1.start()</span><br><span class="line">d = DDnsHelper()</span><br><span class="line">d.excute()</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>最后双击运行~ OK  </li>
</ul>
</blockquote>
<h3 id="5-运行原理和注意事项"><a href="#5-运行原理和注意事项" class="headerlink" title="5. 运行原理和注意事项"></a>5. 运行原理和注意事项</h3><blockquote>
<ul>
<li>原理:<br>该脚本是通过查询公网IP接口:<a href="https://www.hosix.cn/ip">https://www.hosix.cn/ip</a> 来判断公网ip是否发生了改变, 如果发生了改变, 就会调用腾讯云API去动态更新域名. 非常简单…..</li>
<li>注意事项:   </li>
</ul>
<p>1.该脚本需要持续运行, 如果是Linux系统, 直接挂后台运行即可, 该脚本资源消耗不高<br>2.如果提示没requests 运行下, 打开cmd窗口<br>输入: <strong>pip install requests</strong><br><img src="/images/img-12.png" alt="pip install requests"><br>3.如运行闪退, 请检查域名等是否正确填写</p>
</blockquote>
<p>如有问题请评论或留言: <a href="mailto:&#x35;&#x34;&#x34;&#x30;&#49;&#48;&#49;&#54;&#x35;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;">&#x35;&#x34;&#x34;&#x30;&#49;&#48;&#49;&#54;&#x35;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;</a></p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>访问家庭内网</tag>
        <tag>动态DDNS</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 整合到 Spring 原理</title>
    <url>/2021/08/07/A/</url>
    <content><![CDATA[<h3 id="1-xml-配置"><a href="#1-xml-配置" class="headerlink" title="1. xml 配置"></a>1. xml 配置</h3><blockquote>
<p>通过在Spring的 applicationContext.xml文件中做以下配置, 指定MyBatis 的mapper.xml 文件扫描路径, MapperScannerConfigurer 是 Mybatis 用于整合 Spring 的核心对象.</p>
</blockquote>
<span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置扫描器，将mybatis的接口实现加入到  IOC容器中  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;mybatis-spring:scan #base-package=&quot;com.dpl.crud.dao&quot;/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mapperScanner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.gupaoedu.crud.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="2-MapperScannerConfigurer-对象"><a href="#2-MapperScannerConfigurer-对象" class="headerlink" title="2. MapperScannerConfigurer 对象"></a>2. MapperScannerConfigurer 对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperScannerConfigurer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">InitializingBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="该对象实现了几个接口-BeanDefinitionRegistryPostProcessor-InitializingBean-ApplicationContextAware-BeanNameAware"><a href="#该对象实现了几个接口-BeanDefinitionRegistryPostProcessor-InitializingBean-ApplicationContextAware-BeanNameAware" class="headerlink" title="该对象实现了几个接口: BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware "></a>该对象实现了几个接口: BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware <br></h4><blockquote>
<p><strong>1). BeanDefinitionRegistryPostProcessor</strong>:  <br><br><img src="/images/pasted-0.png"> <br></p>
</blockquote>
<blockquote>
<p>如下, 重写了 <strong>++postProcessBeanDefinitionRegistry++</strong>(…)  方法, 在该方法中进行扫描对应的 Mapper 文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.processPropertyPlaceHolders) &#123;</span><br><span class="line">      processPropertyPlaceHolders();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line">    scanner.setAddToConfig(<span class="keyword">this</span>.addToConfig);</span><br><span class="line">    scanner.setAnnotationClass(<span class="keyword">this</span>.annotationClass);</span><br><span class="line">    scanner.setMarkerInterface(<span class="keyword">this</span>.markerInterface);</span><br><span class="line">    scanner.setSqlSessionFactory(<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">    scanner.setSqlSessionTemplate(<span class="keyword">this</span>.sqlSessionTemplate);</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(<span class="keyword">this</span>.sqlSessionFactoryBeanName);</span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(<span class="keyword">this</span>.sqlSessionTemplateBeanName);</span><br><span class="line">    scanner.setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    scanner.setBeanNameGenerator(<span class="keyword">this</span>.nameGenerator);</span><br><span class="line">    scanner.setMapperFactoryBeanClass(<span class="keyword">this</span>.mapperFactoryBeanClass);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">      scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    <span class="comment">// *重点在这里</span></span><br><span class="line">    scanner.scan(</span><br><span class="line">        StringUtils.tokenizeToStringArray(<span class="keyword">this</span>.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重点在 <strong>scanner.scan</strong>(…)方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 继续进入该方法</span></span><br><span class="line">        <span class="keyword">this</span>.doScan(basePackages);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">            AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-2.png"></p>
<blockquote>
<p>该方法有两个实现, 首先进入 <strong>ClassPathMapperScanner</strong> 实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// *这里调了父类 ClassPathBeanDefinitionScanner 的doScan 方法, 进入该方法实现</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">      LOGGER.warn(() -&gt; <span class="string">&quot;No MyBatis mapper was found in &#x27;&quot;</span> + Arrays.toString(basePackages)</span><br><span class="line">          + <span class="string">&quot;&#x27; package. Please check your configuration.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      processBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里调了父类 <strong>ClassPathBeanDefinitionScanner</strong> 的 <strong>doScan</strong>() 方法, 进入该方法实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">        Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// *创建 BeanDefinitionHolder 集合, 里面封装的是 BeanDefinition 和 beanName</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        </span><br><span class="line">        String[] var3 = basePackages;</span><br><span class="line">        <span class="keyword">int</span> var4 = basePackages.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">            String basePackage = var3[var5];</span><br><span class="line">            Set&lt;BeanDefinition&gt; candidates = <span class="keyword">this</span>.findCandidateComponents(basePackage);</span><br><span class="line">            Iterator var8 = candidates.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">                BeanDefinition candidate = (BeanDefinition)var8.next();</span><br><span class="line">                ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">                candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">                String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">                <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 检查每个 BeanDefinition 是否在容器中存在, 不存在则返回true</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                    <span class="comment">// 创建 BeanDefinitionHolder 对象封装 BeanDefinition</span></span><br><span class="line">                    BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                    beanDefinitions.add(definitionHolder);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// *将创建好的对象注册到 BeanDefinitionRegistry 容器中交由Spring管理</span></span><br><span class="line">                    <span class="keyword">this</span>.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面将mapper对象封装好了注册到 BeanDefinitionRegistry 容器中交由Spring管理, 接着返回 BeanDefinitionHolder 集合继续处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">      LOGGER.warn(() -&gt; <span class="string">&quot;No MyBatis mapper was found in &#x27;&quot;</span> + Arrays.toString(basePackages)</span><br><span class="line">          + <span class="string">&quot;&#x27; package. Please check your configuration.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// *接下来处理BeanDefinition</span></span><br><span class="line">      processBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">    GenericBeanDefinition definition;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">      definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">      String beanClassName = definition.getBeanClassName();</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">&quot;Creating MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + beanClassName</span><br><span class="line">          + <span class="string">&quot;&#x27; mapperInterface&quot;</span>);</span><br><span class="line"></span><br><span class="line">      definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); <span class="comment">// issue #59</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// mapper接口是Bean的原始类，但是Bean的实际类被替换成了 MapperFactoryBean</span></span><br><span class="line">      <span class="comment">// 这里的 this.mapperFactoryBeanClass 是 MapperFactoryBean.class 对象</span></span><br><span class="line">      <span class="comment">// private Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = MapperFactoryBean.class;</span></span><br><span class="line">      definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBeanClass);</span><br><span class="line"></span><br><span class="line">      definition.getPropertyValues().add(<span class="string">&quot;addToConfig&quot;</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> explicitFactoryUsed = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>, <span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">          LOGGER.warn(</span><br><span class="line">              () -&gt; <span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionTemplate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">          LOGGER.warn(</span><br><span class="line">              () -&gt; <span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>, <span class="keyword">this</span>.sqlSessionTemplate);</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;Enabling autowire by type for MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">      &#125;</span><br><span class="line">      definition.setLazyInit(lazyInitialization);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里 mapper接口是Bean的原始类，但是Bean的实际类被替换成了 MapperFactoryBean, MapperFactoryBean 对象又是什么东西?</p>
</blockquote>
<h3 id="3-MapperFactoryBean-对象"><a href="#3-MapperFactoryBean-对象" class="headerlink" title="3. MapperFactoryBean 对象"></a>3. MapperFactoryBean 对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// *要点一: 该类继承了 SqlSessionDaoSupport, SqlSessionDaoSupport 对象里面可以获取 SqlSessionTemplate 对象</span></span><br><span class="line"><span class="comment">// SqlSessionTemplate 对象是 DefaultSqlSession 的替代品, 实现同一事务的情况下保证线程安全的, 每次请求的时候都会创建一个新的 SqlSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> addToConfig = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// intentionally empty</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperFactoryBean</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkDaoConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.checkDaoConfig();</span><br><span class="line"></span><br><span class="line">    notNull(<span class="keyword">this</span>.mapperInterface, <span class="string">&quot;Property &#x27;mapperInterface&#x27; is required&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Configuration configuration = getSqlSession().getConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.addToConfig &amp;&amp; !configuration.hasMapper(<span class="keyword">this</span>.mapperInterface)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        configuration.addMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Error while adding the mapper &#x27;&quot;</span> + <span class="keyword">this</span>.mapperInterface + <span class="string">&quot;&#x27; to configuration.&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// *要点二: 该类实现了 FactoryBean&lt;T&gt; 接口, 重写 getObject() 方法,</span></span><br><span class="line">  <span class="comment">// 从 SqlSessionTemplate 对象中获取 Mapper 接口的代理对象</span></span><br><span class="line">  <span class="comment">// 后面的逻辑与之前未整合 Spring 的逻辑一致了.....</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getSqlSession().getMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getObjectType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMapperInterface</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddToConfig</span><span class="params">(<span class="keyword">boolean</span> addToConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.addToConfig = addToConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAddToConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addToConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>允许注入MyBatis映射器接口的BeanFactory。 可以使用SqlSessionFactory或预配置的SqlSessionTemplate进行设置。<br><br>*<strong>要点一:</strong> 该类继承了 SqlSessionDaoSupport, SqlSessionDaoSupport 对象里面可以获取 SqlSessionTemplate 对象 <br><br><strong>SqlSessionTemplate</strong> 对象是 DefaultSqlSession 的替代品, <strong>实现同一事务的情况下还保证线程安全的, 每次请求的时候都会创建一个新的 DefualtSqlSession</strong> <br></p>
</blockquote>
<blockquote>
<p>*<strong>要点二:</strong> 该类实现了 FactoryBean<T> 接口, 重写 getObject() 方法, <br><br>从 SqlSessionTemplate 对象中获取 Mapper 接口的代理对象 <br><br>后面的逻辑与之前未整合 Spring 的逻辑一致了….. <br></p>
</blockquote>
<h3 id="4-SqlSessionTemplate-对象"><a href="#4-SqlSessionTemplate-对象" class="headerlink" title="4. SqlSessionTemplate 对象"></a>4. SqlSessionTemplate 对象</h3><h4 id="为什么说-SqlSessionTemplate-在实现同一事务的情况下还保证线程安全的"><a href="#为什么说-SqlSessionTemplate-在实现同一事务的情况下还保证线程安全的" class="headerlink" title="为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的?"></a>为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的?</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionTemplate</span> <span class="keyword">implements</span> <span class="title">SqlSession</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ExecutorType executorType;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSessionProxy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PersistenceExceptionTranslator exceptionTranslator;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span></span><br><span class="line"><span class="params"><span class="function">      PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    notNull(sqlSessionFactory, <span class="string">&quot;Property &#x27;sqlSessionFactory&#x27; is required&quot;</span>);</span><br><span class="line">    notNull(executorType, <span class="string">&quot;Property &#x27;executorType&#x27; is required&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    <span class="keyword">this</span>.executorType = executorType;</span><br><span class="line">    <span class="keyword">this</span>.exceptionTranslator = exceptionTranslator;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 在初始化的时候通过这里创建 SqlSessionFactory 代理类, </span></span><br><span class="line">    <span class="comment">// 该代理类实现SqlSession接口，定义了方法拦截器，如果调用代理类实例中实现SqlSession接口定义的方法，</span></span><br><span class="line">    <span class="comment">// 该调用则被导向 SqlSessionInterceptor 的invoke方法</span></span><br><span class="line">    <span class="keyword">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(</span><br><span class="line">        SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class[] &#123; SqlSession.class &#125;, </span><br><span class="line">        <span class="keyword">new</span> SqlSessionInterceptor()</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ......</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionInterceptor</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 2. 为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的?</span></span><br><span class="line">      <span class="comment">// 此处则是关键, 进入该方法 getSqlSession(...)</span></span><br><span class="line">      SqlSession sqlSession = getSqlSession(SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory,</span><br><span class="line">          SqlSessionTemplate.<span class="keyword">this</span>.executorType, SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator);</span><br><span class="line">          </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用从Spring的事物上下文获取事物范围内的sqlSession对象</span></span><br><span class="line">        Object result = method.invoke(sqlSession, args);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//然后判断一下当前的sqlSession是否被Spring托管 如果未被Spring托管则自动commit</span></span><br><span class="line">        <span class="keyword">if</span> (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory)) &#123;</span><br><span class="line">          <span class="comment">// force commit even on non-dirty sessions because some databases require</span></span><br><span class="line">          <span class="comment">// a commit/rollback before calling close()</span></span><br><span class="line">          sqlSession.commit(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        Throwable unwrapped = unwrapThrowable(t);</span><br><span class="line">        <span class="keyword">if</span> (SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator != <span class="keyword">null</span> &amp;&amp; unwrapped <span class="keyword">instanceof</span> PersistenceException) &#123;</span><br><span class="line">          <span class="comment">// release the connection to avoid a deadlock if the translator is no loaded. See issue #22</span></span><br><span class="line">          closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">          sqlSession = <span class="keyword">null</span>;</span><br><span class="line">          Throwable translated = SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator</span><br><span class="line">              .translateExceptionIfPossible((PersistenceException) unwrapped);</span><br><span class="line">          <span class="keyword">if</span> (translated != <span class="keyword">null</span>) &#123;</span><br><span class="line">            unwrapped = translated;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> unwrapped;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">          closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>在初始化的时候在构造方法中创建 SqlSessionFactory 代理类, <br> 该代理类实现SqlSession接口，定义了方法拦截器，如果调用代理类实例中实现SqlSession接口定义的方法，<br><br>该调用则被导向 SqlSessionInterceptor 的invoke方法 <br></li>
</ol>
<p><strong>(代理对象的 InvocationHandler 就是 SqlSessionInterceptor，如果把它命名为SqlSessionInvocationHandler则更好理解！）</strong></p>
</blockquote>
<blockquote>
<ol start="2">
<li>为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的? <br><br>此处则是关键, 进入该方法 <br><br>SqlSession sqlSession = getSqlSession(SqlSessionTemplate.this.sqlSessionFactory, <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator);</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType,</span></span></span><br><span class="line"><span class="params"><span class="function">      PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);</span><br><span class="line">    notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入 TransactionSynchronizationManager.getResource(...) 方法</span></span><br><span class="line">    <span class="comment">// 根据sqlSessionFactory从当前线程对应的资源map中获取SqlSessionHolder，</span></span><br><span class="line">    <span class="comment">// 当sqlSessionFactory创建了sqlSession，</span></span><br><span class="line">    <span class="comment">// 就会在事务管理器中添加一对映射：key为sqlSessionFactory，value为SqlSessionHolder，该类保存sqlSession及执行方式</span></span><br><span class="line">    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从SqlSessionHolder中提取SqlSession对象</span></span><br><span class="line">    SqlSession session = sessionHolder(executorType, holder);</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">&quot;Creating a new SqlSession&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前事物管理器中获取不到SqlSessionHolder对象就重新创建一个</span></span><br><span class="line">    session = sessionFactory.openSession(executorType);</span><br><span class="line"></span><br><span class="line">    registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>进入 TransactionSynchronizationManager.getResource(…) 方法</strong> <br><br>SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getResource</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里 value 为返回结果, 可以进去看这个 value 是什么对象, 进入 doGetResource() 方法</span></span><br><span class="line">        Object value = doGetResource(actualKey);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Retrieved value [&quot;</span> + value + <span class="string">&quot;] for key [&quot;</span> + actualKey + <span class="string">&quot;] bound to thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>这里 value 为返回结果, 可以进去看这个 value 是什么对象, 进入 doGetResource() 方法</strong> <br><br>Object value = doGetResource(actualKey);</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">doGetResource</span><span class="params">(Object actualKey)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 最后从 resources 这个集合中获取的对象, 然而这个 resources 就是一个 ThreadLocal 对象, 保证了线程安全</span></span><br><span class="line">        Map&lt;Object, Object&gt; map = (Map)resources.get();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object value = map.get(actualKey);</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ResourceHolder &amp;&amp; ((ResourceHolder)value).isVoid()) &#123;</span><br><span class="line">                map.remove(actualKey);</span><br><span class="line">                <span class="keyword">if</span> (map.isEmpty()) &#123;</span><br><span class="line">                    resources.remove();</span><br><span class="line">                &#125;</span><br><span class="line">                value = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后从 resources 这个集合中获取的对象, 然而这个 resources 就是一个 ThreadLocal 对象, 保证了线程安全 <br><br>Map&lt;Object, Object&gt; map = (Map)resources.get();</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSynchronizationManager</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = <span class="keyword">new</span> NamedThreadLocal(<span class="string">&quot;Transactional resources&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-Mybatis-不是有-SqlSessionManager-了吗？为什么又提供了-SqlSessionTemplate？"><a href="#5-Mybatis-不是有-SqlSessionManager-了吗？为什么又提供了-SqlSessionTemplate？" class="headerlink" title="5. Mybatis 不是有 SqlSessionManager 了吗？为什么又提供了 SqlSessionTemplate？"></a>5. Mybatis 不是有 SqlSessionManager 了吗？为什么又提供了 SqlSessionTemplate？</h3><blockquote>
<p><strong>SqlSessionManager</strong>: SqlSessionManager 是由开发者自身决定如何使用 SqlSession 的, 是适合在不整合 Spring 框架的时候使用。</p>
</blockquote>
<blockquote>
<p><strong>SqlSessionTemplate</strong>: SqlSessionTemplate 是 MyBatis 专门为 Spring 提供的，支持 Spring 框架的一个 SqlSession 获取接口。<br><br>主要是为了继承 Spring，并同时将是否共用 SqlSession 的权限交给 Spring 去管理。</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
</search>
