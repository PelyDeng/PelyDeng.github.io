<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MyBatis 运行时序图</title>
    <url>/2021/08/10/MyBatis-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%8F%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="架构分层"><a href="#架构分层" class="headerlink" title="架构分层"></a>架构分层</h3><p><img src="/images/pasted-4.png" alt="架构分层"></p>
<span id="more"></span>

<h4 id="1-创建会话工厂类"><a href="#1-创建会话工厂类" class="headerlink" title="1. 创建会话工厂类"></a>1. 创建会话工厂类</h4><p><img src="/images/pasted-5.png" alt="创建会话过程"></p>
<h4 id="2-创建会话"><a href="#2-创建会话" class="headerlink" title="2. 创建会话"></a>2. 创建会话</h4><p><img src="/images/pasted-6.png" alt="创建会话过程"></p>
<h4 id="3-获取代理对象"><a href="#3-获取代理对象" class="headerlink" title="3. 获取代理对象"></a>3. 获取代理对象</h4><p><img src="/images/pasted-7.png" alt="获取代理对象过程"></p>
<h4 id="4-调用代理对象方法-执行SQL"><a href="#4-调用代理对象方法-执行SQL" class="headerlink" title="4. 调用代理对象方法, 执行SQL"></a>4. 调用代理对象方法, 执行SQL</h4><p><img src="/images/pasted-8.png" alt="调用代理对象方法, 执行SQL过程"></p>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/08/06/newpapername/</url>
    <content><![CDATA[<div class="poem-wrap">
  <div class="poem-border poem-left"></div>
  <div class="poem-border poem-right"></div>
    <h1>念两句诗</h1>
    <p id="poem">挑选中...</p>
    <p id="info">

  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
  <script type="text/javascript">
    jinrishici.load(function(result) {
      poem.innerHTML = result.data.content
      info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
      document.getElementById("poem").value(poem);
      document.getElementById("info").value(info);  
  });
  </script>
</p></div>]]></content>
  </entry>
  <entry>
    <title>MyBatis 整合到 Spring 原理</title>
    <url>/2021/08/07/A/</url>
    <content><![CDATA[<h3 id="1-xml-配置"><a href="#1-xml-配置" class="headerlink" title="1. xml 配置"></a>1. xml 配置</h3><blockquote>
<p>通过在Spring的 applicationContext.xml文件中做以下配置, 指定MyBatis 的mapper.xml 文件扫描路径, MapperScannerConfigurer 是 Mybatis 用于整合 Spring 的核心对象.</p>
</blockquote>
<span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置扫描器，将mybatis的接口实现加入到  IOC容器中  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;mybatis-spring:scan #base-package=&quot;com.dpl.crud.dao&quot;/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mapperScanner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.gupaoedu.crud.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="2-MapperScannerConfigurer-对象"><a href="#2-MapperScannerConfigurer-对象" class="headerlink" title="2. MapperScannerConfigurer 对象"></a>2. MapperScannerConfigurer 对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperScannerConfigurer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">InitializingBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="该对象实现了几个接口-BeanDefinitionRegistryPostProcessor-InitializingBean-ApplicationContextAware-BeanNameAware"><a href="#该对象实现了几个接口-BeanDefinitionRegistryPostProcessor-InitializingBean-ApplicationContextAware-BeanNameAware" class="headerlink" title="该对象实现了几个接口: BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware "></a>该对象实现了几个接口: BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware <br></h4><blockquote>
<p><strong>1). BeanDefinitionRegistryPostProcessor</strong>:  <br><br><img src="/images/pasted-0.png"> <br></p>
</blockquote>
<blockquote>
<p>如下, 重写了 <strong>++postProcessBeanDefinitionRegistry++</strong>(…)  方法, 在该方法中进行扫描对应的 Mapper 文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.processPropertyPlaceHolders) &#123;</span><br><span class="line">      processPropertyPlaceHolders();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line">    scanner.setAddToConfig(<span class="keyword">this</span>.addToConfig);</span><br><span class="line">    scanner.setAnnotationClass(<span class="keyword">this</span>.annotationClass);</span><br><span class="line">    scanner.setMarkerInterface(<span class="keyword">this</span>.markerInterface);</span><br><span class="line">    scanner.setSqlSessionFactory(<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">    scanner.setSqlSessionTemplate(<span class="keyword">this</span>.sqlSessionTemplate);</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(<span class="keyword">this</span>.sqlSessionFactoryBeanName);</span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(<span class="keyword">this</span>.sqlSessionTemplateBeanName);</span><br><span class="line">    scanner.setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    scanner.setBeanNameGenerator(<span class="keyword">this</span>.nameGenerator);</span><br><span class="line">    scanner.setMapperFactoryBeanClass(<span class="keyword">this</span>.mapperFactoryBeanClass);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">      scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    <span class="comment">// *重点在这里</span></span><br><span class="line">    scanner.scan(</span><br><span class="line">        StringUtils.tokenizeToStringArray(<span class="keyword">this</span>.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重点在 <strong>scanner.scan</strong>(…)方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 继续进入该方法</span></span><br><span class="line">        <span class="keyword">this</span>.doScan(basePackages);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">            AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-2.png"></p>
<blockquote>
<p>该方法有两个实现, 首先进入 <strong>ClassPathMapperScanner</strong> 实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// *这里调了父类 ClassPathBeanDefinitionScanner 的doScan 方法, 进入该方法实现</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">      LOGGER.warn(() -&gt; <span class="string">&quot;No MyBatis mapper was found in &#x27;&quot;</span> + Arrays.toString(basePackages)</span><br><span class="line">          + <span class="string">&quot;&#x27; package. Please check your configuration.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      processBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里调了父类 <strong>ClassPathBeanDefinitionScanner</strong> 的 <strong>doScan</strong>() 方法, 进入该方法实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">        Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// *创建 BeanDefinitionHolder 集合, 里面封装的是 BeanDefinition 和 beanName</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        </span><br><span class="line">        String[] var3 = basePackages;</span><br><span class="line">        <span class="keyword">int</span> var4 = basePackages.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">            String basePackage = var3[var5];</span><br><span class="line">            Set&lt;BeanDefinition&gt; candidates = <span class="keyword">this</span>.findCandidateComponents(basePackage);</span><br><span class="line">            Iterator var8 = candidates.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">                BeanDefinition candidate = (BeanDefinition)var8.next();</span><br><span class="line">                ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">                candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">                String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">                <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 检查每个 BeanDefinition 是否在容器中存在, 不存在则返回true</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                    <span class="comment">// 创建 BeanDefinitionHolder 对象封装 BeanDefinition</span></span><br><span class="line">                    BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                    beanDefinitions.add(definitionHolder);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// *将创建好的对象注册到 BeanDefinitionRegistry 容器中交由Spring管理</span></span><br><span class="line">                    <span class="keyword">this</span>.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面将mapper对象封装好了注册到 BeanDefinitionRegistry 容器中交由Spring管理, 接着返回 BeanDefinitionHolder 集合继续处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">      LOGGER.warn(() -&gt; <span class="string">&quot;No MyBatis mapper was found in &#x27;&quot;</span> + Arrays.toString(basePackages)</span><br><span class="line">          + <span class="string">&quot;&#x27; package. Please check your configuration.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// *接下来处理BeanDefinition</span></span><br><span class="line">      processBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">    GenericBeanDefinition definition;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">      definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">      String beanClassName = definition.getBeanClassName();</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">&quot;Creating MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + beanClassName</span><br><span class="line">          + <span class="string">&quot;&#x27; mapperInterface&quot;</span>);</span><br><span class="line"></span><br><span class="line">      definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); <span class="comment">// issue #59</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// mapper接口是Bean的原始类，但是Bean的实际类被替换成了 MapperFactoryBean</span></span><br><span class="line">      <span class="comment">// 这里的 this.mapperFactoryBeanClass 是 MapperFactoryBean.class 对象</span></span><br><span class="line">      <span class="comment">// private Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = MapperFactoryBean.class;</span></span><br><span class="line">      definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBeanClass);</span><br><span class="line"></span><br><span class="line">      definition.getPropertyValues().add(<span class="string">&quot;addToConfig&quot;</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> explicitFactoryUsed = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>, <span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">          LOGGER.warn(</span><br><span class="line">              () -&gt; <span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> RuntimeBeanReference(<span class="keyword">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionTemplate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">          LOGGER.warn(</span><br><span class="line">              () -&gt; <span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>, <span class="keyword">this</span>.sqlSessionTemplate);</span><br><span class="line">        explicitFactoryUsed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;Enabling autowire by type for MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">      &#125;</span><br><span class="line">      definition.setLazyInit(lazyInitialization);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里 mapper接口是Bean的原始类，但是Bean的实际类被替换成了 MapperFactoryBean, MapperFactoryBean 对象又是什么东西?</p>
</blockquote>
<h3 id="3-MapperFactoryBean-对象"><a href="#3-MapperFactoryBean-对象" class="headerlink" title="3. MapperFactoryBean 对象"></a>3. MapperFactoryBean 对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// *要点一: 该类继承了 SqlSessionDaoSupport, SqlSessionDaoSupport 对象里面可以获取 SqlSessionTemplate 对象</span></span><br><span class="line"><span class="comment">// SqlSessionTemplate 对象是 DefaultSqlSession 的替代品, 实现同一事务的情况下保证线程安全的, 每次请求的时候都会创建一个新的 SqlSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> addToConfig = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// intentionally empty</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperFactoryBean</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkDaoConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.checkDaoConfig();</span><br><span class="line"></span><br><span class="line">    notNull(<span class="keyword">this</span>.mapperInterface, <span class="string">&quot;Property &#x27;mapperInterface&#x27; is required&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Configuration configuration = getSqlSession().getConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.addToConfig &amp;&amp; !configuration.hasMapper(<span class="keyword">this</span>.mapperInterface)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        configuration.addMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Error while adding the mapper &#x27;&quot;</span> + <span class="keyword">this</span>.mapperInterface + <span class="string">&quot;&#x27; to configuration.&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// *要点二: 该类实现了 FactoryBean&lt;T&gt; 接口, 重写 getObject() 方法,</span></span><br><span class="line">  <span class="comment">// 从 SqlSessionTemplate 对象中获取 Mapper 接口的代理对象</span></span><br><span class="line">  <span class="comment">// 后面的逻辑与之前未整合 Spring 的逻辑一致了.....</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getSqlSession().getMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getObjectType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMapperInterface</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddToConfig</span><span class="params">(<span class="keyword">boolean</span> addToConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.addToConfig = addToConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAddToConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addToConfig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>允许注入MyBatis映射器接口的BeanFactory。 可以使用SqlSessionFactory或预配置的SqlSessionTemplate进行设置。<br><br>*<strong>要点一:</strong> 该类继承了 SqlSessionDaoSupport, SqlSessionDaoSupport 对象里面可以获取 SqlSessionTemplate 对象 <br><br><strong>SqlSessionTemplate</strong> 对象是 DefaultSqlSession 的替代品, <strong>实现同一事务的情况下还保证线程安全的, 每次请求的时候都会创建一个新的 DefualtSqlSession</strong> <br></p>
</blockquote>
<blockquote>
<p>*<strong>要点二:</strong> 该类实现了 FactoryBean<T> 接口, 重写 getObject() 方法, <br><br>从 SqlSessionTemplate 对象中获取 Mapper 接口的代理对象 <br><br>后面的逻辑与之前未整合 Spring 的逻辑一致了….. <br></T></p>
</blockquote>
<h3 id="4-SqlSessionTemplate-对象"><a href="#4-SqlSessionTemplate-对象" class="headerlink" title="4. SqlSessionTemplate 对象"></a>4. SqlSessionTemplate 对象</h3><h4 id="为什么说-SqlSessionTemplate-在实现同一事务的情况下还保证线程安全的"><a href="#为什么说-SqlSessionTemplate-在实现同一事务的情况下还保证线程安全的" class="headerlink" title="为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的?"></a>为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的?</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionTemplate</span> <span class="keyword">implements</span> <span class="title">SqlSession</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ExecutorType executorType;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSessionProxy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PersistenceExceptionTranslator exceptionTranslator;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span></span><br><span class="line"><span class="params"><span class="function">      PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    notNull(sqlSessionFactory, <span class="string">&quot;Property &#x27;sqlSessionFactory&#x27; is required&quot;</span>);</span><br><span class="line">    notNull(executorType, <span class="string">&quot;Property &#x27;executorType&#x27; is required&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    <span class="keyword">this</span>.executorType = executorType;</span><br><span class="line">    <span class="keyword">this</span>.exceptionTranslator = exceptionTranslator;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 在初始化的时候通过这里创建 SqlSessionFactory 代理类, </span></span><br><span class="line">    <span class="comment">// 该代理类实现SqlSession接口，定义了方法拦截器，如果调用代理类实例中实现SqlSession接口定义的方法，</span></span><br><span class="line">    <span class="comment">// 该调用则被导向 SqlSessionInterceptor 的invoke方法</span></span><br><span class="line">    <span class="keyword">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(</span><br><span class="line">        SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class[] &#123; SqlSession.class &#125;, </span><br><span class="line">        <span class="keyword">new</span> SqlSessionInterceptor()</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ......</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionInterceptor</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 2. 为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的?</span></span><br><span class="line">      <span class="comment">// 此处则是关键, 进入该方法 getSqlSession(...)</span></span><br><span class="line">      SqlSession sqlSession = getSqlSession(SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory,</span><br><span class="line">          SqlSessionTemplate.<span class="keyword">this</span>.executorType, SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator);</span><br><span class="line">          </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用从Spring的事物上下文获取事物范围内的sqlSession对象</span></span><br><span class="line">        Object result = method.invoke(sqlSession, args);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//然后判断一下当前的sqlSession是否被Spring托管 如果未被Spring托管则自动commit</span></span><br><span class="line">        <span class="keyword">if</span> (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory)) &#123;</span><br><span class="line">          <span class="comment">// force commit even on non-dirty sessions because some databases require</span></span><br><span class="line">          <span class="comment">// a commit/rollback before calling close()</span></span><br><span class="line">          sqlSession.commit(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        Throwable unwrapped = unwrapThrowable(t);</span><br><span class="line">        <span class="keyword">if</span> (SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator != <span class="keyword">null</span> &amp;&amp; unwrapped <span class="keyword">instanceof</span> PersistenceException) &#123;</span><br><span class="line">          <span class="comment">// release the connection to avoid a deadlock if the translator is no loaded. See issue #22</span></span><br><span class="line">          closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">          sqlSession = <span class="keyword">null</span>;</span><br><span class="line">          Throwable translated = SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator</span><br><span class="line">              .translateExceptionIfPossible((PersistenceException) unwrapped);</span><br><span class="line">          <span class="keyword">if</span> (translated != <span class="keyword">null</span>) &#123;</span><br><span class="line">            unwrapped = translated;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> unwrapped;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">          closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>在初始化的时候在构造方法中创建 SqlSessionFactory 代理类, <br> 该代理类实现SqlSession接口，定义了方法拦截器，如果调用代理类实例中实现SqlSession接口定义的方法，<br><br>该调用则被导向 SqlSessionInterceptor 的invoke方法 <br></li>
</ol>
<p><strong>(代理对象的 InvocationHandler 就是 SqlSessionInterceptor，如果把它命名为SqlSessionInvocationHandler则更好理解！）</strong></p>
</blockquote>
<blockquote>
<ol start="2">
<li>为什么说 SqlSessionTemplate 在实现同一事务的情况下还保证线程安全的? <br><br>此处则是关键, 进入该方法 <br><br>SqlSession sqlSession = getSqlSession(SqlSessionTemplate.this.sqlSessionFactory, <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator);</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType,</span></span></span><br><span class="line"><span class="params"><span class="function">      PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);</span><br><span class="line">    notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入 TransactionSynchronizationManager.getResource(...) 方法</span></span><br><span class="line">    <span class="comment">// 根据sqlSessionFactory从当前线程对应的资源map中获取SqlSessionHolder，</span></span><br><span class="line">    <span class="comment">// 当sqlSessionFactory创建了sqlSession，</span></span><br><span class="line">    <span class="comment">// 就会在事务管理器中添加一对映射：key为sqlSessionFactory，value为SqlSessionHolder，该类保存sqlSession及执行方式</span></span><br><span class="line">    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从SqlSessionHolder中提取SqlSession对象</span></span><br><span class="line">    SqlSession session = sessionHolder(executorType, holder);</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">&quot;Creating a new SqlSession&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前事物管理器中获取不到SqlSessionHolder对象就重新创建一个</span></span><br><span class="line">    session = sessionFactory.openSession(executorType);</span><br><span class="line"></span><br><span class="line">    registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>进入 TransactionSynchronizationManager.getResource(…) 方法</strong> <br><br>SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getResource</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里 value 为返回结果, 可以进去看这个 value 是什么对象, 进入 doGetResource() 方法</span></span><br><span class="line">        Object value = doGetResource(actualKey);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Retrieved value [&quot;</span> + value + <span class="string">&quot;] for key [&quot;</span> + actualKey + <span class="string">&quot;] bound to thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>这里 value 为返回结果, 可以进去看这个 value 是什么对象, 进入 doGetResource() 方法</strong> <br><br>Object value = doGetResource(actualKey);</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">doGetResource</span><span class="params">(Object actualKey)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 最后从 resources 这个集合中获取的对象, 然而这个 resources 就是一个 ThreadLocal 对象, 保证了线程安全</span></span><br><span class="line">        Map&lt;Object, Object&gt; map = (Map)resources.get();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object value = map.get(actualKey);</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ResourceHolder &amp;&amp; ((ResourceHolder)value).isVoid()) &#123;</span><br><span class="line">                map.remove(actualKey);</span><br><span class="line">                <span class="keyword">if</span> (map.isEmpty()) &#123;</span><br><span class="line">                    resources.remove();</span><br><span class="line">                &#125;</span><br><span class="line">                value = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后从 resources 这个集合中获取的对象, 然而这个 resources 就是一个 ThreadLocal 对象, 保证了线程安全 <br><br>Map&lt;Object, Object&gt; map = (Map)resources.get();</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSynchronizationManager</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = <span class="keyword">new</span> NamedThreadLocal(<span class="string">&quot;Transactional resources&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-Mybatis-不是有-SqlSessionManager-了吗？为什么又提供了-SqlSessionTemplate？"><a href="#5-Mybatis-不是有-SqlSessionManager-了吗？为什么又提供了-SqlSessionTemplate？" class="headerlink" title="5. Mybatis 不是有 SqlSessionManager 了吗？为什么又提供了 SqlSessionTemplate？"></a>5. Mybatis 不是有 SqlSessionManager 了吗？为什么又提供了 SqlSessionTemplate？</h3><blockquote>
<p><strong>SqlSessionManager</strong>: SqlSessionManager 是由开发者自身决定如何使用 SqlSession 的, 是适合在不整合 Spring 框架的时候使用。</p>
</blockquote>
<blockquote>
<p><strong>SqlSessionTemplate</strong>: SqlSessionTemplate 是 MyBatis 专门为 Spring 提供的，支持 Spring 框架的一个 SqlSession 获取接口。<br><br>主要是为了继承 Spring，并同时将是否共用 SqlSession 的权限交给 Spring 去管理。</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>摘抄笔记</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
</search>
